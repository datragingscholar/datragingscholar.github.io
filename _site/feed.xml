<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-22T20:14:48+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Raging Scholar</title><subtitle>A shitposting rehabilitation center</subtitle><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><entry><title type="html">What is wrong with microservice</title><link href="http://localhost:4000/what-is-wrong-with-microservice/" rel="alternate" type="text/html" title="What is wrong with microservice" /><published>2019-07-21T00:00:00+08:00</published><updated>2019-07-21T00:00:00+08:00</updated><id>http://localhost:4000/what-is-wrong-with-microservice</id><content type="html" xml:base="http://localhost:4000/what-is-wrong-with-microservice/">&lt;h1 id=&quot;welcome&quot;&gt;Welcome&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Hello world&lt;/strong&gt;, this is my first Jekyll blog post.&lt;/p&gt;

&lt;p&gt;I hope you like it!&lt;/p&gt;</content><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><summary type="html">Welcome</summary></entry><entry><title type="html">FreeBSD Rootkit Design Howtos - 3 - System Call First Kernel Service Application</title><link href="http://localhost:4000/freebsd-rootkit-design-howtos-3-system-call-first-kernel-service-application/" rel="alternate" type="text/html" title="FreeBSD Rootkit Design Howtos - 3 - System Call First Kernel Service Application" /><published>2012-06-10T00:00:00+08:00</published><updated>2012-06-10T00:00:00+08:00</updated><id>http://localhost:4000/freebsd-rootkit-design-howtos-3-system-call-first-kernel-service-application</id><content type="html" xml:base="http://localhost:4000/freebsd-rootkit-design-howtos-3-system-call-first-kernel-service-application/">&lt;p&gt;Welcome back to FreeBSD Kernel Rootkit Design Howtos, we’ll walk through all
necessary techniques you need to program your own BSD kernel rookit. Please be
sure you’ve read the previous guides before you proceed with this one.&lt;/p&gt;

&lt;h2 id=&quot;review&quot;&gt;Review&lt;/h2&gt;

&lt;p&gt;Same as usual, let’s review what we’ve discussed in the &lt;a href=&quot;/freebsd-rootkit-design-howtos-2-system-call-first-kernel-service-module/&quot;&gt;last session&lt;/a&gt;. Basically a new kind of kernel module was introduced — The system call
module, it registers itself as a kernel service and wait for user to call it via
system calls.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SYSCALL_MODULE&lt;/strong&gt; is the registration macro for system call modules to install
themselves into the running kernel, and it requires five parameters:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;name&lt;/strong&gt; as a generic name for the system call module&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;offset&lt;/strong&gt; value which determines in which location in the sysent[] table to
save our system call module’s sysent structure&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;new_sysent&lt;/strong&gt; pointer to a sysent_t structure that contains basic info about
the system call module such as number of arguments and pointer to it’s
implementation function&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;implementation function&lt;/strong&gt; defines activities you want your system call
module to perform every time when it receives system call&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this session, we’ll make a custom client application that calls our kernel
service module directly without knowing the module’s offset value.&lt;/p&gt;

&lt;h2 id=&quot;the-modfind-function&quot;&gt;The modfind Function&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;modfind&lt;/strong&gt; function is our key to solve the inflexibility issue, it is very
useful but a little bit confusing.&lt;/p&gt;

&lt;p&gt;As the name implies, the modfind function helps us to find a specific module in
a running kernel by giving it the module name. It is sweet ’cause keeping track
of module names is much easier than a bunch of module offset values.&lt;/p&gt;

&lt;p&gt;Now the confusing part is, opposite to what you may have guessed, the return
value of this function is &lt;strong&gt;NOT&lt;/strong&gt; the system call module’s offset value, but it’s
&lt;strong&gt;id&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take a look at a sample piece of modfind function code.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/param.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modfind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-modstat-function&quot;&gt;The modstat Function&lt;/h2&gt;

&lt;p&gt;As we can only obtain the &lt;strong&gt;id&lt;/strong&gt; of the system call module by calling
modfind function, so here’s what really give us answers - the &lt;strong&gt;modstat
function&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/param.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modstat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;int modid&lt;/code&gt; is where we should pass the result of modfind function, but we
won’t get the offset value from the function’s return value.&lt;/p&gt;

&lt;p&gt;Instead, we have to construct a &lt;code class=&quot;highlighter-rouge&quot;&gt;module_stat&lt;/code&gt; structure, and the modstat function
will save results to it. That is why we are passing a pointer to a module_stat
structure as the second parameter.&lt;/p&gt;

&lt;p&gt;The module_stat structure is defined in sys/module.h as shown below&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_stat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/* set to sizeof(struct module_stat) */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;            &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAXMODNAME&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;refs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;modspecific_t&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modspecific&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;intval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_int&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;uintval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;longval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_long&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;ulongval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modspecific_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I know this looks messy, but luckily we don’t need to deal with all of them.&lt;/p&gt;

&lt;p&gt;The first part of the code is the definition of &lt;code class=&quot;highlighter-rouge&quot;&gt;module_stat&lt;/code&gt; structure, and it
contains a &lt;code class=&quot;highlighter-rouge&quot;&gt;modspecific_t&lt;/code&gt; union which is defined in the second part, our offset
value is stored in this union as &lt;code class=&quot;highlighter-rouge&quot;&gt;intval&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Confusing right, you don’t see any variable name here with offset value in it.
The good news is, that’s all we have to learn today, we’ll get to the example
code after the summary.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We now know that having a native client to call system call modules is much
better than the perl command we used in last session. It is better because,&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;We don’t have to remember the offset value of the system call module to call
it. This is especially useful when we have to maintain multiple system call
modules&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The offset value of system call module changes every time we reload it. We’ll
still have our flexibility since we rely on module name which is not likely to
be changed over time&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The way how the client works is that we use modfind to find out the id of a
given module name, but sadly it’s not the module’s offset value, which we can’t
use to issue the system call.&lt;/p&gt;

&lt;p&gt;So we have to utilize another function which is modstat that will give us back a
modspecific union, in which we can get the real offset value we want from the
intval integer.&lt;/p&gt;

&lt;p&gt;Here’s a figure to make your life miserable, you can thank me later. : ] Oh god,
why I’m so bad at drawing…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/freebsd-rootkit-design-howtos/chart3_1.png&quot; alt=&quot;Chart 3&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;example-code&quot;&gt;Example Code&lt;/h2&gt;

&lt;p&gt;Now it’s time for us to see some examples. Let’s firstly start with the example
from Designing BSD Rootkits: An Introduction to Kernel Hacking with some
additional comments to help you understand the code.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/syscall.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Main function of our client application
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Check the parameter passed to the application,
&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;//print out usage help information
&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;//if we got wrong number of parameters.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Usage:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s &amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_stat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//This is the module_stat structure
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syscall_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//We'll get the offset value and store it here.
&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Determine sc_example's offset value. */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//set version to sizeof(struct module_stat)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;modstat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modfind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sc_example&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;syscall_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Call sc_example. */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Return the statues of the system call
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unlike kernel modules which we need a makefile to automate some extreme nasty
stuff, we don’t need one for this simple client side application. We can
directly compile the code like this,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# gcc -o client client.c
client.c: In function 'main':
client.c:12: warning: incompatible implicit declaration of built-in function 'exit'
myBSD# ls
client      client.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looks good so far, we’ve got the client executable file. Let’s load the previous
sc_example module and try to call it with our client application.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# kldload ./sc_example.ko
System call loaded at offset 210.
myBSD# ./client
Usage:
./client &amp;lt;string&amp;gt;
myBSD# ./client Hey\ Kernel!
Bad system call (core dumped)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We loaded the sc_example module at offset value of 210, we got a nice help
message when wrong number of parameter is specified, which is nice, but we end
up with a Bad system call error when we give it the right amount of parameters.&lt;/p&gt;

&lt;p&gt;This is bad, because we’ve got nearly no clue of what had happened, and what
caused it. But just before we panic, let’s calm down and think about this error
message which is our only lead to the problem, which says Bad system call.&lt;/p&gt;

&lt;p&gt;It is obvious that we were calling a bad kernel module, so bad that our little
client crashed. If we called a bad kernel module in our syscall function, then
that means the return value of modfind or modstat function is wrong, or maybe
both of them are wrong, who knows.&lt;/p&gt;

&lt;p&gt;So I did a little bit debugging, and I soon realized that the return value of
modfind is -1, which is obviously bad.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/syscall.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Main function of our client application
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The return value of modfind is: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modfind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sc_example&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The result says&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# gcc -o client client.c
myBSD# ./client
The return value of modfind is: -1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Alright, &lt;strong&gt;&lt;em&gt;-1&lt;/em&gt;&lt;/strong&gt;, it probably means fail to find this module, or given module was not
found. Given that the module name is the only parameter for the modfind
function, it is obvious that the module name is wrong.&lt;/p&gt;

&lt;p&gt;This is interesting, we all know that the module name is right, so there’s
something wrong from the very beginning. The very source of a system call module
is of course it’s declaration macro, so let’s look at there and see if we can
get any luck.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)      \
static struct syscall_module_data name##_syscall_mod = {        \
        evh, arg, offset, new_sysent, { 0, NULL, AUE_NULL }     \
};                                                              \
                                                                \
static moduledata_t name##_mod = {                              \
        &quot;sys/&quot; #name,                                           \
        syscall_module_handler,                                 \
        &amp;amp;name##_syscall_mod                                     \
};
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here we go, a &lt;strong&gt;&lt;em&gt;module name prefix&lt;/em&gt;&lt;/strong&gt;! That means every kernel module
registered with SYSCALL_MODULE will be given a &lt;strong&gt;&lt;em&gt;sys/&lt;/em&gt;&lt;/strong&gt; prefix in front of
their names.&lt;/p&gt;

&lt;p&gt;Now we know the root of the problem, let’s modify our code and try again.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/syscall.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Main function of our client application
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Check the parameter passed to the application,
&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;//print out usage help information
&lt;/span&gt;                     &lt;span class=&quot;c1&quot;&gt;//if we got wrong number of parameters.
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Usage:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;%s &amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_stat&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//We'll get the module statues and store it here.
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syscall_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//We'll get the offset value and store it here.
&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Determine sc_example's offset value. */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//set version to sizeof(struct module_stat)
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;modstat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modfind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sys/sc_example&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//With prefix this time
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;syscall_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/* Call sc_example. */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Return the statues of the system call
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Everything is the same except &lt;code class=&quot;highlighter-rouge&quot;&gt;modstat(modfind(&quot;sys/sc_example&quot;), &amp;amp;stat);&lt;/code&gt;. Now
compile and run.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# gcc -o client client.c
client.c: In function 'main':
client.c:12: warning: incompatible implicit declaration of built-in function 'exit'
myBSD# ./client Hey\ Kernel!\ What\'s\ Up\?
myBSD# dmesg | tail -n1
Hey Kernel! What's Up?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Yada! Our little client is doing it’s job and we’ve achieved our objectives by
calling a system call module without knowing it’s offset value.&lt;/p&gt;

&lt;p&gt;That will be all for today, thank you for reading this tutorial, like it and
share it to support my work, and I’ll see you in the next tutorial!&lt;/p&gt;</content><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><category term="FreeBSD" /><category term="Rootkit" /><category term="C++" /><summary type="html">Welcome back to FreeBSD Kernel Rootkit Design Howtos, we’ll walk through all necessary techniques you need to program your own BSD kernel rookit. Please be sure you’ve read the previous guides before you proceed with this one.</summary></entry><entry><title type="html">FreeBSD Rootkit Design Howtos - 2 - System Call First Kernel Service Module</title><link href="http://localhost:4000/freebsd-rootkit-design-howtos-2-system-call-first-kernel-service-module/" rel="alternate" type="text/html" title="FreeBSD Rootkit Design Howtos - 2 - System Call First Kernel Service Module" /><published>2012-06-09T00:00:00+08:00</published><updated>2012-06-09T00:00:00+08:00</updated><id>http://localhost:4000/freebsd-rootkit-design-howtos-2-system-call-first-kernel-service-module</id><content type="html" xml:base="http://localhost:4000/freebsd-rootkit-design-howtos-2-system-call-first-kernel-service-module/">&lt;p&gt;So, this is the second tutorial on FreeBSD Kernel Rootkit Design. I hope you
have worked through the previous one before you continue, which is obviously a
prerequisite.&lt;/p&gt;

&lt;p&gt;What we’ve discussed are that KLD is the way we interact with kernel, and how to
declare a module by having module name, module data (consists of official name
and event handler function), sub, and order. And we agree on the
not-completely-true assumption that every kernel module should have an event
handler function which deals with event type such as MOD_LOAD, MOD_UNLOAD, and
so on. If any of these terms sounds strange to you, I encourage you to go back
and review &lt;a href=&quot;/freebsd-rootkit-design-howtos-1-kld-first-kernel-loadable-module/&quot;&gt;FreeBSD Kernel Rootkit Design Howtos - 1 - KLD First Kernel Loadable
Module&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-system-call-module&quot;&gt;The System Call Module&lt;/h2&gt;

&lt;p&gt;Today we’re gonna talk about the &lt;em&gt;system call module&lt;/em&gt;, which is a little bit
different compared to the general module we’ve discussed previously.&lt;/p&gt;

&lt;p&gt;A general module which we’ve talked about in the last session performs
programmed actions only when certain actions take place, such as when it loads,
unloads, shutdown, and etc.&lt;/p&gt;

&lt;p&gt;A &lt;em&gt;system call module&lt;/em&gt; on the other hand, is basically as same as the general KLD
module, except that it installs itself as a &lt;em&gt;kernel service request&lt;/em&gt;, and then
&lt;em&gt;listen to certain signals&lt;/em&gt; to perform programmed actions accordingly.&lt;/p&gt;

&lt;p&gt;Such functions can be considered as kinda of a bridge between the kernel space
and the user space, which enables the ability for its users to send signals to
the kernel and make it react accordingly.&lt;/p&gt;

&lt;p&gt;What makes this system call module different is that, instead of printing
messages every time we load or unload the module, we’re gonna make it print
messages every time we send command to it.&lt;/p&gt;

&lt;p&gt;Here in this session, we’re gonna talk about the system call module, its
structure, its declaration routine, and finally write our first system call
module along with a tiny client application to send command to it.&lt;/p&gt;

&lt;h2 id=&quot;the-system-call-function&quot;&gt;The System Call Function&lt;/h2&gt;

&lt;p&gt;A &lt;em&gt;system call function&lt;/em&gt; is a function defined in the system call module, which
contains a list of actions to be taken every time it receives a system call.&lt;/p&gt;

&lt;p&gt;It’s similar to the &lt;em&gt;module event handler&lt;/em&gt; except that we have control over what
command to receive and what actions to perform.&lt;/p&gt;

&lt;p&gt;The prototype of system call function is defined in sys/sysent.h and is shown
below.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sy_call_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The struct &lt;code class=&quot;highlighter-rouge&quot;&gt;struct thread *&lt;/code&gt; points to the current running thread, which you don’t
have to care about it at this stage. The &lt;code class=&quot;highlighter-rouge&quot;&gt;void * points&lt;/code&gt; to the structure of
&lt;strong&gt;system call’s arguments&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Compare to the general KLD module, the system call module can receive multiple
arguments instead of limited and pre-defined ones. So it is your responsibility
to define the arguments that the system call module needs to deal with.&lt;/p&gt;

&lt;p&gt;Since the &lt;strong&gt;system call’s arguments&lt;/strong&gt; are wrapped in a struct, so we can define it
like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Having the &lt;strong&gt;system call’s arguments&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt; successfully defined, we can now
declare our &lt;strong&gt;system call function&lt;/strong&gt; like this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sc_example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;td&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first line is obvious the declaration of the system call function, note that
we can receive all arguments via &lt;code class=&quot;highlighter-rouge&quot;&gt;void *syscall_args&lt;/code&gt; inside the function.&lt;/p&gt;

&lt;p&gt;Let’s now take a look at what happens inside the function, we firstly
initialized (It’s not the precise term, but it helps) a local variable &lt;code class=&quot;highlighter-rouge&quot;&gt;*uap&lt;/code&gt;
using our defined sc_example_args structure.&lt;/p&gt;

&lt;p&gt;And then convert the incoming arguments from &lt;code class=&quot;highlighter-rouge&quot;&gt;*syscall_args&lt;/code&gt; to match our
standard, the sc_examples_args structure, and let the &lt;code class=&quot;highlighter-rouge&quot;&gt;*uap&lt;/code&gt; pointer points to
it. The simple version of this, is we receive arguments from &lt;code class=&quot;highlighter-rouge&quot;&gt;*syscall_args&lt;/code&gt; and
save it in &lt;code class=&quot;highlighter-rouge&quot;&gt;*uap&lt;/code&gt; with the &lt;code class=&quot;highlighter-rouge&quot;&gt;sc_example_args&lt;/code&gt; format.&lt;/p&gt;

&lt;p&gt;Now we can do whatever we want with the arguments received, such as print out
the string like this:  &lt;code class=&quot;highlighter-rouge&quot;&gt;printf(&quot;%s\n&quot;, uap-&amp;gt;str);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Looks we have successfully declared a system call function, but we actually just
made a huge mistake.&lt;/p&gt;

&lt;p&gt;What I mean by mistake is that the code can still be compiled and executed, but
we did it in a very bad manner. You see that modern operating systems segregate
it’s memory areas into user space and kernel space, code running in each section
don’t directly access each other’s resources. The way we assign a user space
structure pointer to a kernel space local variable (&lt;code class=&quot;highlighter-rouge&quot;&gt;uap = (struct
sc_example_args *)syscall_args;&lt;/code&gt;) is unsafe and not recommended.&lt;/p&gt;

&lt;p&gt;Here’s a quote from Designing BSD Rootkits: An Introduction to Kernel Hacking
that explains a little bit about kernel space and user space.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;FreeBSD segregates its virtual memory into two parts: user space and kernel
space. User space is where all user-mode applications run, while kernel space
is where the kernel and kernel extensions (i.e., LKMs) run. Code running in
user space cannot access kernel space directly (but code running in kernel
space can access user space). To access kernel space from user space, an
application issues a system call.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Let’s move on for now and get back to kernel/user space transition in details
later.&lt;/p&gt;

&lt;h2 id=&quot;the-sysent-structure&quot;&gt;The sysent Structure&lt;/h2&gt;

&lt;p&gt;Still remember the general module declaration macro in the previous session?
Well the system call modules need to register themselves by calling a macro as
well, but we have to define a &lt;strong&gt;sysent structure&lt;/strong&gt; first and then pass it to the
declaration macro.&lt;/p&gt;

&lt;p&gt;The sysent structure is similar to the moduledata that we’ve discussed in the
last session, it contains the basic information about the system call. So that
once we register a system call module with sysent structure, the operating
system will know where and how to quickly fire it.&lt;/p&gt;

&lt;p&gt;The FreeBSD system actually maintains &lt;strong&gt;a table of sysent structures&lt;/strong&gt; of all system
call modules that are currently loaded in the running kernel, thus every system
call module has to provide its sysent structure during initialization to
register itself with the &lt;strong&gt;sysent table&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So be sure that you understand how sysent structure differs from sysent table
before we take a look at its definition in sys/sysent.h&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                 &lt;span class=&quot;cm&quot;&gt;/* system call table */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sy_narg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/* number of arguments */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sy_call_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sy_call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* implementing function */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;au_event_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sy_auevent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* audit event associated with syscall */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;systrace_args_func_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sy_systrace_args_func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                                &lt;span class=&quot;cm&quot;&gt;/* optional argument conversion function. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sy_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* DTrace entry ID for systrace. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sy_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* DTrace return ID for systrace. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sy_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* General flags for system calls. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u_int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sy_thrcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;…&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I guess the comments in above code explain exactly what you need to know. Note
that normally we just need to specify &lt;code class=&quot;highlighter-rouge&quot;&gt;sy_narg&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*sy_call&lt;/code&gt; for this to work.&lt;/p&gt;

&lt;p&gt;Now we can extend our previous example code as following:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sc_example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;td&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_sysent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;              &lt;span class=&quot;cm&quot;&gt;/* number of arguments */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sc_example&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* implementing function */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-offset-value&quot;&gt;The Offset Value&lt;/h2&gt;

&lt;p&gt;Same as the system call function and the sysent structure, the &lt;strong&gt;offset value&lt;/strong&gt; is
another parameter you need to set and pass to the system call module declaration
macro. Basically, the offset value is the system call module’s number, which
will be used by the system to refer to its sysent structure in the sysent table.&lt;/p&gt;

&lt;p&gt;It should be an unique integer, and should be explicitly declared in a system
call’s declaration macro. It is considered as a good practice to not to assign
fixed numbers to dynamic system call modules. Instead, we can ask the system to
dynamically assign an unused offset number for our system call module by doing
this:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_SYSCALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NO_SYSCALL&lt;/code&gt; is a constant, meaning the next available slots offset in sysent
table.&lt;/p&gt;

&lt;p&gt;Just in case if you are interested, the value for NO_SYSCALL is -1 as shown below:&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define NO_SYSCALL (-1)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Some of the pre-defined system call offsets are listed in the
/sys/kern/syscalls.master file, here’s some allocations:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Offset Range&lt;/th&gt;
      &lt;th&gt;Comment&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0-150&lt;/td&gt;
      &lt;td&gt;Reserved/unimplemented system calls. For use in future Berkeley releases.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;151-180&lt;/td&gt;
      &lt;td&gt;Reserved for vendor-specific system calls&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;181-199&lt;/td&gt;
      &lt;td&gt;Used by/reserved for BSD&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;210-219&lt;/td&gt;
      &lt;td&gt;Reserved for loadable syscalls&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;220-249&lt;/td&gt;
      &lt;td&gt;Were introduced with NetBSD/4.4Lite-2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;250-299&lt;/td&gt;
      &lt;td&gt;Initially used in OpenBSD&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;300-531&lt;/td&gt;
      &lt;td&gt;Syscall numbers for FreeBSD&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;the-syscall_module-macro&quot;&gt;The SYSCALL_MODULE Macro&lt;/h2&gt;

&lt;p&gt;I said at the beginning of this tutorial that we are gonna need to call a macro
to declare a system call module, but we needed to know few other things first.
We talked about system call function, we talked about sysent structure and we
talked about the offset value.&lt;/p&gt;

&lt;p&gt;We need these declared first and only then we can call the &lt;strong&gt;SYSCALL_MODULE
macro&lt;/strong&gt;. It is defined in sys/sysent.h as following&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Different from the &lt;strong&gt;DECLARE_MODULE&lt;/strong&gt; macro which requires four parameters:
&lt;strong&gt;name&lt;/strong&gt;, &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;sub&lt;/strong&gt;, and &lt;strong&gt;order&lt;/strong&gt;, the &lt;strong&gt;SYSCALL_MODULE&lt;/strong&gt; requires five
parameter to be passed, which are:&lt;/p&gt;

&lt;h3 id=&quot;name&quot;&gt;name&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the generic module name, which is passed as a character string.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;offset&quot;&gt;offset&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the system call’s offset value, which is passed as an integer
pointer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;new_sysent&quot;&gt;new_sysent&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the completed sysent structure, which is passed as a struct
sysent pointer.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;evh&quot;&gt;evh&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the event handler function.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;arg&quot;&gt;arg&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the arguments to be passed to the event handler function. For
our purposes, we’ll always set this parameter to NULL.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Great, we can now further extend our previous example code as following&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sc_example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;td&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_sysent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;              &lt;span class=&quot;cm&quot;&gt;/* number of arguments */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sc_example&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* implementing function */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_SYSCALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;SYSCALL_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc_example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc_example_sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;evh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Don’t worry about the event handler function &lt;code class=&quot;highlighter-rouge&quot;&gt;evh&lt;/code&gt;, it will be exactly same as
general module’s event handler function. You’ll see that in the complete example
soon, for now let’s sum things up first.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;System Call Module is another type of kernel loadable module&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It installs itself in the kernel space and perform programmed activities
according to signals received from user space&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In order to declare a system call module, five parameters are required, name,
offset, new_sysent, evh, and arg&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;name is the general module name&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;offset is the system call module’s offset number&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;It determines where to store the system call module’s sysent structure
in sysent[] table&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;new_sysent is a pointer to the system call module’s sysent structure&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;sysent structure is similar to moduledata&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;It contains basic information about the system call module including&lt;/p&gt;

            &lt;ul&gt;
              &lt;li&gt;
                &lt;p&gt;Number of arguments it expects&lt;/p&gt;
              &lt;/li&gt;
              &lt;li&gt;
                &lt;p&gt;And implementing function&lt;/p&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;The implementation function, also known as the system call function&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;It contains a list of actions to be taken every time it receives a particular signal&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;example-code&quot;&gt;Example Code&lt;/h2&gt;

&lt;p&gt;We can now write the our first system call module, take a look at the following
code, there are some comments there to help you understand. There is absolutely
nothing new except the event handler function, which in fact, isn’t new to us as
well.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * FILE: /root/rootkit/2.1/sc_example.c
 * Example 2.1
 * The First System Call Module
 * FreeBSD Rootkit Design Howtos @ hailang.im
*/&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/param.h&amp;gt;
#include &amp;lt;sys/proc.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
#include &amp;lt;sys/sysent.h&amp;gt;
#include &amp;lt;sys/kernel.h&amp;gt;
#include &amp;lt;sys/systm.h&amp;gt;
#include &amp;lt;sys/sysproto.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* The system call's arguments. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* The system call function. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;sc_example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;td&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;syscall_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uap&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* The sysent for the new system call */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sc_example_sysent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;cm&quot;&gt;/* number of arguments */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sc_example&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/* implementing function */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* The offset in sysent[] where the system call is to be allocated. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_SYSCALL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* The function called at load/unload. */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;System call loaded at offset %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD_UNLOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;System call unloaded from offset %d.&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EOPNOTSUPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Declare the System Call Module */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;SYSCALL_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc_example&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;offset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sc_example_sysent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As usual, we need to have a makefile in the same directory as the source code
file.&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;KMOD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;   sc_example
&lt;span class=&quot;nv&quot;&gt;SRCS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;   sc_example.c

&lt;span class=&quot;err&quot;&gt;.include&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;bsd.kmod.mk&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now build your first system call module by using the make command in the same
directory.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# make
Warning: Object directory not changed from original /root/rootkit/2.1
@ -&amp;gt; /usr/src/sys
machine -&amp;gt; /usr/src/sys/amd64/include
x86 -&amp;gt; /usr/src/sys/x86/include
cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c sc_example.c
ld  -d -warn-common -r -d -o sc_example.ko sc_example.o
:&amp;gt; export_syms
awk -f /sys/conf/kmod_syms.awk sc_example.ko  export_syms | xargs -J% objcopy % sc_example.ko
objcopy --strip-debug sc_example.ko

myBSD# ls
@       export_syms machine     makefile    sc_example.c    sc_example.ko   sc_example.o    x86
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have successfully compiled our first system call module and we got the
&lt;em&gt;*sc_example.ko&lt;/em&gt; file!&lt;/p&gt;

&lt;h2 id=&quot;loading-and-calling&quot;&gt;Loading and Calling&lt;/h2&gt;

&lt;p&gt;Here’s the final step we need to take to make use of our first system call
module, the loading, and the calling. Let’s firstly try to load the module into
the running kernel, and then figure out how to issue the system call.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# kldload ./sc_example.ko
System call loaded at offset 210.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Thanks to our event handler, it prints out the system call number which is the
offset value of the system call module’s sysent structure in sysent[] table.
You’ll soon realize how important it is for us to issue a system call.&lt;/p&gt;

&lt;p&gt;Now we have two ways to send command to our system call module, we can either
write a user space application, or type a simple command. I will talk about the
command first since the user space application will be covered in next session.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# kldload ./sc_example.ko
System call loaded at offset 210.
myBSD# perl -e '$str = &quot;Hello kernel!\n I am here to dance with you!&quot;;' -e 'syscall(210, $str);'
myBSD# dmesg | tail -n 2
Hello kernel!
 I am here to dance with you!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note that we explicitly specified the system call number in that perl command to
send our command to our system call module.&lt;/p&gt;

&lt;p&gt;That’s all for today, we made an upgraded version of fun kernel printing tookit
which can print whatever string you want it to. We’ll talk about how to call a
system call module without knowing it’s offset value in the next tutorial. See
you there.&lt;/p&gt;</content><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><category term="FreeBSD" /><category term="Rootkit" /><category term="C++" /><summary type="html">So, this is the second tutorial on FreeBSD Kernel Rootkit Design. I hope you have worked through the previous one before you continue, which is obviously a prerequisite.</summary></entry><entry><title type="html">FreeBSD Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module</title><link href="http://localhost:4000/freebsd-rootkit-design-howtos-1-kld-first-kernel-loadable-module/" rel="alternate" type="text/html" title="FreeBSD Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module" /><published>2012-06-08T21:53:49+08:00</published><updated>2012-06-08T21:53:49+08:00</updated><id>http://localhost:4000/freebsd-rootkit-design-howtos-1-kld-first-kernel-loadable-module</id><content type="html" xml:base="http://localhost:4000/freebsd-rootkit-design-howtos-1-kld-first-kernel-loadable-module/">&lt;p&gt;Needless to say that the first thing you need to start FreeBSD kernel rootkit
development is a FreeBSD box. There are plenty of installation guides on the
Internet about FreeBSD installation, so that I’ll just skip this part for the
sake of simplicity.&lt;/p&gt;

&lt;p&gt;And FYI, basically you are free to choose any hardware to run FreeBSD as long as
it’s supported. You can even install your FreeBSD as a virtual machine. 5GB hard
drive, at least 256MB memory with any modern CPU will do.&lt;/p&gt;

&lt;h2 id=&quot;the-environment&quot;&gt;The Environment&lt;/h2&gt;

&lt;p&gt;The version of FreeBSD I’m going to use throughout this howtos is FreeBSD 9
Stable, it is recommended that you install at least FreeBSD 9 Release although I
believe code examples in this howtos are able to run on most of versions after
FreeBSD 6.2&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# uname -a
FreeBSD myBSD 9.0-STABLE FreeBSD 9.0-STABLE #0: Thu Mar  8 14:16:25 CST 2012 bestwc@myBSD:/usr/obj/usr/src/sys/GENERIC  amd64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;package-installation&quot;&gt;Package Installation&lt;/h2&gt;

&lt;p&gt;You’ll need the FreeBSD source tree to compile your kernel rootkit, be sure to
install it because it is not included in minimal installation. You can do this
by two ways, the first is to enable src distribution option during installation,
and the recommended way is to perform the following command after the
installation.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# cp /usr/share/examples/cvsup/stable-supfile /root &amp;amp;&amp;amp; cd /root
myBSD# ee stable-supfile
=================================
*default host=CHANGE_THIS.FreeBSD.org ###Change this line
*default host=cvsup.FreeBSD.org ###To this
=================================
myBSD# csup -g -L2 stable-supfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This will sync the source tree on your local file system to the latest one from
remote repository, and this will simply download the latest for you if you don’t
already have the source tree. It is recommended to run the cusp command shown
above to frequently update your source tree, for this will make sure your are
developing rootkit with the newest kernel source code, and potentially make it
more compatible with new FreeBSD releases.&lt;/p&gt;

&lt;p&gt;To examine if you have the src tree on your local box, type the following
command:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# ls /usr/src
COPYRIGHT       ObsoleteFiles.inc       crypto          lib         share
LOCKS           README      etc         libexec         sys
MAINTAINERS     UPDATING    games       release         tools
Makefile        bin         gnu         rescue          usr.bin
Makefile.inc1   cddl        include     sbin            usr.sbin
Makefile.mips   contrib     kerberos5   secure
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-dynamic-kernel-linker-kld&quot;&gt;The Dynamic Kernel Linker (KLD)&lt;/h2&gt;

&lt;p&gt;The Dynamic Kernel Linker (KLD) is a facility in FreeBSD that allows users to
interact with the system kernel by dynamically loading or unloading kernel
modules. It may sounds strange to you, but believe it or not that you have
utilized KLD multiple times during daily operations on your FreeBSD box. The KLD
gets called every time you plug in or plug out a device, or by manually typing
kldload or kldunload commands. It is especially useful to device driver
developers as they can dynamically load their drivers as kernel module and test
the functionalities on the fly without rebooting the system. For more
information on the KLD, please refer to the FreeBSD Handbook.&lt;/p&gt;

&lt;p&gt;The KLD provides a high way for us to put our code into the running kernel space
without recompiling as long as we have the required privilege. So that, if we
have our kernel rootkit compiled as loadable kernel module, then we’ll
theoretically be able to load that module in any FreeBSD machines on the fly.&lt;/p&gt;

&lt;p&gt;Although the KLD interface is not the only way for people to interact with
kernel, but is undoubtedly the easiest and probably the fastest way to do that.
The only question is, will there be any compatibility issues if we stick to KLD
interface?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;In FreeBSD 3.0, substantial changes were made to the kernel module subsystem,
and the LKM Facility was renamed the Dynamic Kernel Linker (KLD) Facility.
Subsequently, the term KLD is commonly used to describe LKMs under FreeBSD.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;According to the quote above from Designing BSD Rootkits: An Introduction to
Kernel Hacking by Joseph Kong, the KLD interface hasn’t been changed since
FreeBSD 3.0, which means our yet-to-be-done rootkit should be able to run on any
(not always true) modern FreeBSD systems without any (not always true as well)
modification.&lt;/p&gt;

&lt;p&gt;Just in case that you haven’t realized, we are going to use KLD interfaces a lot
in this tutorial. Now let’s get to know the KLD interface more.&lt;/p&gt;

&lt;h2 id=&quot;the-module-event-handler&quot;&gt;The Module Event Handler&lt;/h2&gt;

&lt;p&gt;When you load or unload any kernel modules to or from the current running
kernel, the KLD interface will perform some pre-defined routines to prepare the
system. This is called the Module Event Handler, it should be present in
every(!) kernel module to handle the initialization and shutdown processes. This
handler gets called every time when the code enters or exits kernel space.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(!) Just keep in mind that this isn’t always true, as what the quote says below
from Designing BSD Rootkits: An Introduction to Kernel Hacking&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Actually, this isn’t entirely true. You can have a KLD that just includes a
sysctl. You can also dispense with module handlers if you wish and just use
SYSINIT and SYSUNINIT directly to register functions to be invoked on load and
unload, respectively. You can’t, however, indicate failure in those.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The prototype of the module event handler is defined in &lt;em&gt;sys/module.h&lt;/em&gt; and it is
called &lt;em&gt;modeventhand_t&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;myBSD&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modeventhand_t&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;modeventhand_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* modeventtype_t */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And &lt;em&gt;module_t&lt;/em&gt; is a pointer to the module’s struct as defined in the same file.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;em&gt;modeventtype_t&lt;/em&gt; on the other hand is an enumerated type of event types
defined in the same file as well.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modeventtype&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOD_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Set when module is loaded. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOD_UNLOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Set when module is unloaded. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOD_SHUTDOWN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Set on shutdown. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MOD_QUIESCE&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Set on quiesce. */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;modeventtype_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With all these information, we can now try to define a simple module event
handler. Here is a simple event handler function called load, which displays
Hello, world! when it’s loaded, and print Good-bye, cruel world! when it’s
unloaded.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello, world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD_UNLOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;uprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Good-bye, cruel world!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;EOPNOTSUPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//EOPNOTSUPP stands for Error: Operation not supported.
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s perfectly safe if this code doesn’t make much sense to you, as we will get
back later. However, what you do need to understand is the prototype of defining
a &lt;em&gt;module event handler&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This code snippet should present in your first loadable kernel module, and
perform pre-defined routines according to the cmd sent by the kernel
accordingly.&lt;/p&gt;

&lt;p&gt;Consider this to be a protocol between your module and the kernel, which
basically says &lt;em&gt;“Oh the user asked you to unload me? Hold on and let me check my
event handler, alright, I’ll print Good-bye, cruel world! and then go away.”&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-declare_module-macro&quot;&gt;The DECLARE_MODULE Macro&lt;/h2&gt;

&lt;p&gt;It’s time to get back to our module declaration.&lt;/p&gt;

&lt;p&gt;We now know &lt;em&gt;module_t&lt;/em&gt; is a pointer to the module structure, but what on earth is
a module and how do we define it? The thing is, we must let KLD know the basic
information about our module, and it should register itself with kernel when it
loads. This process can be awfully long and complicated, lucky that we have a
pre-defined macro in sys/module.h that just does this to help us.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define DECLARE_MODULE_WITH_MAXVER(name, data, sub, order, maxver)
#define DECLARE_MODULE(name, data, sub, order)
&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;The&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;declared&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DECLARE_MODULE_TIED&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;loaded&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define DECLARE_MODULE_TIED(name, data, sub, order)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As shown above, there are actually tree macros for us to declare a module,
&lt;em&gt;DECLARE_MODULE&lt;/em&gt;, &lt;em&gt;DECLARE_MODULE_TIED&lt;/em&gt;, and &lt;em&gt;DECLARE_MODULE_WITH_MAXVER&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DECLARE_MODULE
    &lt;ul&gt;
      &lt;li&gt;The simplest one that requires only four parameters to be passed, for normal
purposes&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DECLARE_MODULE_TIED
    &lt;ul&gt;
      &lt;li&gt;Use this macro when your kernel module can only be loaded into the kernel
with exactly the same &lt;em&gt;FreeBSD_version&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;DECLARE_MODULE_WITH_MAXVER
    &lt;ul&gt;
      &lt;li&gt;To declare kernel modules that can only run on machines with FreeBSD version
maxver or lower&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll stick with the general &lt;em&gt;DECLARE_MODULE&lt;/em&gt; macro, and now let’s discuss it’s
four parameters: &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;sub&lt;/em&gt;, and &lt;em&gt;order&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;name&quot;&gt;name&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the generic module name, which is passed as a character string.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;data&quot;&gt;data&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This parameter specifies the official module name and event handler function,
which is passed as a moduledata structure.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The &lt;em&gt;moduledata structure&lt;/em&gt; is defined in sys/module.h&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduledata&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;cm&quot;&gt;/* module name */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;modeventhand_t&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;evhand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/* event handler */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;priv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;cm&quot;&gt;/* extra data */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduledata_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;sub&quot;&gt;sub&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the system startup interface namely sysinit_sui_id, which
identifies the module type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We can find a complete list of &lt;em&gt;sysinit_sub_id&lt;/em&gt; from sys/kernel.h&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysinit_sub_id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DUMMY&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* not executed; for linker*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DONE&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* processed*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_TUNABLES&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0700000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* establish tunable values */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_COPYRIGHT&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0800001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* first use of console*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SETTINGS&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0880000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* check and recheck settings */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_MTX_POOL_STATIC&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0900000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* static mutex pool */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_LOCKMGR&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0980000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* lockmgr locks */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_VM&lt;/span&gt;               &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* virtual memory system init*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KMEM&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* kernel memory*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KVM_RSRC&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1A00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* kvm operational limits*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_WITNESS&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1A80000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* witness initialization */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_MTX_POOL_DYNAMIC&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1AC0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* dynamic mutex pool */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_LOCK&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1B00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* various locks */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_EVENTHANDLER&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1C00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* eventhandler init */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_VNET_PRELINK&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1E00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* vnet init before modules */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KLD&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* KLD and module setup */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_CPU&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* CPU resource(s)*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_RACCT&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2110000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* resource accounting */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_RANDOM&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2120000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* random number generator */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KDTRACE&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2140000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Kernel dtrace hooks */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_MAC&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2180000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* TrustedBSD MAC subsystem */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_MAC_POLICY&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x21C0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* TrustedBSD MAC policies */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_MAC_LATE&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x21D0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* TrustedBSD MAC subsystem */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_VNET&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x21E0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* vnet 0 */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_INTRINSIC&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2200000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* proc 0*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_VM_CONF&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* config VM, set limits*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DDB_SERVICES&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2380000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* capture, scripting, etc. */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_RUN_QUEUE&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2400000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* set up run queue*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTRACE&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2480000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* ktrace */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_OPENSOLARIS&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2490000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* OpenSolaris compatibility */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_CYCLIC&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24A0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Cyclic timers */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_AUDIT&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x24C0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* audit */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_CREATE_INIT&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2500000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* create init process*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SCHED_IDLE&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2600000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* required idle procs */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_MBUF&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2700000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* mbuf subsystem */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_INTR&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* interrupt threads */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SOFTINTR&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2800001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* start soft interrupt thread */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_ACL&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2900000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* start for filesystem ACLs */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DEVFS&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2F00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* devfs ready for devices */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_INIT_IF&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* prep for net interfaces */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_NETGRAPH&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3010000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Let Netgraph initialize */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DTRACE&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3020000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* DTrace subsystem */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DTRACE_PROVIDER&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3048000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* DTrace providers */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DTRACE_ANON&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x308C000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* DTrace anon enabling */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DRIVERS&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Let Drivers initialize */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_CONFIGURE&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Configure devices */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_VFS&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x4000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* virtual filesystem*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_CLOCKS&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x4800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* real time and stat clocks*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_CLIST&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x5800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* clists*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SYSV_SHM&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x6400000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* System V shared memory*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SYSV_SEM&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x6800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* System V semaphores*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SYSV_MSG&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x6C00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* System V message queues*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_P1003_1B&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x6E00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* P1003.1B realtime */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PSEUDO&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* pseudo devices*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_EXEC&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x7400000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* execve() handlers */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PROTO_BEGIN&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* XXX: set splimp (kludge)*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PROTO_IF&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8400000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* interfaces*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PROTO_DOMAININIT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8600000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* domain registration system */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PROTO_DOMAIN&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* domains (address families?)*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PROTO_IFATTACHDOMAIN&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8800001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* domain dependent data init*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_PROTO_END&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x8ffffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* XXX: set splx (kludge)*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KPROF&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x9000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* kernel profiling*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KICK_SCHEDULER&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xa000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* start the timeout events*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_INT_CONFIG_HOOKS&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xa800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Interrupts enabled config */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_ROOT_CONF&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xb000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Find root devices */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_DUMP_CONF&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xb200000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Find dump devices */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_RAID&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xb380000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* Configure GEOM classes */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SWAP&lt;/span&gt;             &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xc000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* swap */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_INTRINSIC_POST&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xd000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* proc 0 cleanup*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SYSCALLS&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xd800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* register system calls */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_VNET_DONE&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xdc00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* vnet registration complete */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTHREAD_INIT&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xe000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* init process*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTHREAD_PAGE&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xe400000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* pageout daemon*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTHREAD_VM&lt;/span&gt;       &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xe800000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* vm daemon*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTHREAD_BUF&lt;/span&gt;      &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xea00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* buffer daemon*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTHREAD_UPDATE&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xec00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* update daemon*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_KTHREAD_IDLE&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xee00000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* idle procs*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_SMP&lt;/span&gt;              &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xf000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* start the APs*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_RACCTD&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xf100000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* start raccd*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_SUB_RUN_SCHEDULER&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xfffffff&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* scheduler*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;sysinit_sub_id&lt;/em&gt; is a list of pre-defined enumerated constant data to declare
kernel modules for different purposes. We’ll use &lt;em&gt;SI_SUB_DRIVERS&lt;/em&gt; in our first few
examples, and some other useful subs are to be introduced in later chapters.&lt;/p&gt;

&lt;h3 id=&quot;order&quot;&gt;order&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This specifies the KLD’s order of initialization within the subsystem, namely
the &lt;em&gt;sysinit_elem_order&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;A complete list of &lt;em&gt;sysinit_elem_order&lt;/em&gt; can be found in sys/kernel.h&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;FILE:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sysinit_elem_order&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_ORDER_FIRST&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* first*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_ORDER_SECOND&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* second*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_ORDER_THIRD&lt;/span&gt;          &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000002&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* third*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_ORDER_FOURTH&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000003&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* fourth*/&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_ORDER_MIDDLE&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* somewhere in the middle */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;SI_ORDER_ANY&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xfffffff&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* last*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For the sake of simplicity and to concentrate on our purpose, we’ll stick to
&lt;em&gt;SI_ORDER_MIDDLE&lt;/em&gt; which declares our kernel module somewhere in the middle of the
KLD subsystem. We will discuss the others if we need to.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;We’ve talked lots of concepts and kernel terminology, probably too much for a
beginner. So just before we go for example code, let’s try to quickly review
what we have discussed first.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;KLD&lt;/em&gt; is the way how we interact our code with FreeBSD kernel&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Every KLD module (At least in our case) needs a &lt;em&gt;module event handler&lt;/em&gt; called
&lt;em&gt;modeventhand_t&lt;/em&gt; and it is defined in sys/module.h&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;The prototype of &lt;em&gt;modeventhand_t&lt;/em&gt; requires &lt;em&gt;module_t&lt;/em&gt; and &lt;em&gt;modeventtype_t&lt;/em&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;em&gt;module_t&lt;/em&gt; is a pointer to our yet-to-be-declared module. We use
&lt;em&gt;DECLARE_MODULE&lt;/em&gt; to declare general kernel modules&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;The &lt;em&gt;DECLARE_MODULE&lt;/em&gt; is defined in sys/module.h and it requires four
parameters: &lt;em&gt;name&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;sub&lt;/em&gt;, and &lt;em&gt;order&lt;/em&gt;&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;name is the general name for the module&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;data is passed as moduledata consists of the official name of the module
and the event handler of the module. It is defined in sys/module.h&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;sub is the identifier of the type of the module. It is listed in
sysinit_sub_id enum defined in sys/kernel.h&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;order is the initialization position of the module. It is listed in
sysinitelemorder enum defined in sys/kernel.h&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Finally we need &lt;em&gt;modeventtype_t&lt;/em&gt; to complete &lt;em&gt;modeventhand_t&lt;/em&gt; prototype&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;em&gt;modeventtype_t&lt;/em&gt; is an enum types of events defined in sys/module.h to let
the kernel module perform corresponding actions when certain event happens&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are two figures for you to get an overall understanding of how this works.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/freebsd-rootkit-design-howtos/chart1_1.png&quot; alt=&quot;Chart 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/freebsd-rootkit-design-howtos/chart1_2.png&quot; alt=&quot;Chart 2&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;example-code&quot;&gt;Example Code&lt;/h2&gt;

&lt;p&gt;So, after all these pains and hair-pulling, we are finally gonna have our first
kernel loadable module compiled.&lt;/p&gt;

&lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*
 * FILE: /root/rootkit/1.1/first_module.c
 * Example 1.1
 * The First Kernel Loadable Module
 * FreeBSD Rootkit Design Howtos @ hailang.im
*/&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;sys/param.h&amp;gt;
#include &amp;lt;sys/module.h&amp;gt;
#include &amp;lt;sys/kernel.h&amp;gt;
#include &amp;lt;sys/systm.h&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/* Define a loader function */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;module_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD_LOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;uprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Lets Rock the Kernel!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MOD_UNLOAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;uprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Time to Leave the Party!&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;nl&quot;&gt;default:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EOPNOTSUPP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//Operation not supported
&lt;/span&gt;            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Define a module data structure */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;moduledata_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;first_mlodule&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// Module name
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;module_loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// Event Handler
&lt;/span&gt;    &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;// Extra Data
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* Declare the module */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;DECLARE_MODULE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_mlodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SI_SUB_DRIVERS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SI_ORDER_MIDDLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now there’s just one more thing left before we can compile the code, the
makefile. If you are not familiar with the concept of makeifle, please google it
and get yourself familiar with its basic syntax, just a little bit by now.&lt;/p&gt;

&lt;p&gt;Here’s the content of makefile&lt;/p&gt;

&lt;div class=&quot;language-makefile highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;KMOD&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;   first_module
&lt;span class=&quot;nv&quot;&gt;SRCS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;   first_module.c

&lt;span class=&quot;err&quot;&gt;.include&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;&amp;lt;bsd.kmod.mk&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Save it as makefile in the same folder with first_module.c&lt;/p&gt;

&lt;p&gt;As you can see, we use bsd.kmod.mk macro here to make our life easier, because
otherwise we’ll have to link all kernel source files manually.&lt;/p&gt;

&lt;p&gt;All we have to do here is to fill in the module name and source file name. With
the makefile and the source file with us, we can now go ahead and compile our
first kernel module by entering &lt;em&gt;make&lt;/em&gt; in the same folder.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# make
Warning: Object directory not changed from original /root/rootkit/1.1
cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c first_module.c
ld  -d -warn-common -r -d -o first_module.ko first_module.o
:&amp;gt; export_syms
awk -f /sys/conf/kmod_syms.awk first_module.ko  export_syms | xargs -J% objcopy % first_module.ko
objcopy --strip-debug first_module.ko
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Looks everything is nice and clean, we now have our first module successfully
compiled. Now go ahead and treat yourself a muffin.&lt;/p&gt;

&lt;p&gt;Let’s take a look at what we have now.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# ls
@       export_syms first_module.c  first_module.ko first_module.o  machine     makefile    x86
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We have several files and linkers added here, but hello.ko is what we really
care about. That is the result of all our hard work — the loadable module.&lt;/p&gt;

&lt;p&gt;It’s like an executable file, same as the file you get in regular application
programing, and yes, it is distributable.&lt;/p&gt;

&lt;p&gt;Just before you bite that muffin, let’s have our fun first by loading and
unloading it.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;myBSD# kldload ./first_module.ko
Lets Rock the Kernel!
myBSD# kldunload first_module.ko
Time to Leave the Party!
myBSD#
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Sweet huh? All of your hard works have been paid by seeing these silly but pretty words printing on your screen.&lt;/p&gt;</content><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><category term="FreeBSD" /><category term="Rootkit" /><category term="C++" /><summary type="html">Needless to say that the first thing you need to start FreeBSD kernel rootkit development is a FreeBSD box. There are plenty of installation guides on the Internet about FreeBSD installation, so that I’ll just skip this part for the sake of simplicity.</summary></entry><entry><title type="html">FreeBSD Rootkit Design Howtos - Introduction</title><link href="http://localhost:4000/freebsd-rootkit-design-howtos-introduction/" rel="alternate" type="text/html" title="FreeBSD Rootkit Design Howtos - Introduction" /><published>2012-06-08T13:15:00+08:00</published><updated>2012-06-08T13:15:00+08:00</updated><id>http://localhost:4000/freebsd-rootkit-design-howtos-introduction</id><content type="html" xml:base="http://localhost:4000/freebsd-rootkit-design-howtos-introduction/">&lt;p&gt;As the title suggests, this is a howto tutorial on FreeBSD kernel rootkit
design. It was prepared as notes as I worked on my college final year project
while reading Designing BSD Rootkits: An Introduction to Kernel Hacking, where I
got most of the information I needed. I then posted these notes on my blog
hoping it could serve as a quick introduction to general kernel hacking. Those
notes were filled with unorganized brainstorming and unnecessary technical
details that even I myself couldn’t bear reading a page without drinking way too
much coffee. It clearly failed it’s purpose.&lt;/p&gt;

&lt;p&gt;It took me a year to realize that it’s a shame to give up all that hard work. I
rewrote the whole thing to make them more like tutorials other than academic
class notes.&lt;/p&gt;

&lt;p&gt;I actually wanted to write this howto together with my college final year
project synchronously, but sadly things didn’t work out the way I expected.
It took me almost a year to reach this point of rewriting most of them to make
them more like tutorials other than academic class notes.&lt;/p&gt;

&lt;p&gt;Anyway, here I am, writing this intro again, hoping that I can finally finish it
this time.&lt;/p&gt;

&lt;p&gt;FreeBSD Kernel Rootkit Design and Defense Techniques is the title of my college
final year project, I chose this topic because my lecturer who I consulted with
thinks this one can help me at applying master degree in malicious software
analysis.&lt;/p&gt;

&lt;p&gt;I myself have no interest in pursuing master degree in malicious software
analysis, but it sure sounds cool to me to create my very own rootkit,
especially on my favorite platform, FreeBSD.&lt;/p&gt;

&lt;p&gt;I still remember the lecturer asked me why I wanna make it on FreeBSD instead of
Linux, well, there are two reasons.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I’m more familiar with FreeBSD than Linux&lt;/li&gt;
  &lt;li&gt;I don’t see any recent and public accessible rootkit for FreeBSD&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Furthermore, there is another secret weapon to make my life even easier,
Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong. I
highly recommend you guys to grab a copy of this book. It’s good, and it’s the
only book on FreeBSD kernel rootkit design as far as I know, so you kinda have
no choice here.&lt;/p&gt;

&lt;p&gt;There’s another nice book to start with, The Design and Implementation of the
FreeBSD Operating System By Marshall Kirk McKusick and George V. Neville-Neil.
As the book name suggests, it can give you a detailed understanding of FreeBSD
kernel. Get a copy of this book, read the first few chapters to get a rough
understanding and use it as a reference book later on when you work on specific
modules of the kernel.&lt;/p&gt;

&lt;h2 id=&quot;what-to-expect&quot;&gt;What to Expect&lt;/h2&gt;

&lt;p&gt;Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong is
somehow sufficient for lots of people to kickstart their own rootkit, but you
have to be familiar with modern system kernels and have some experiences in
working in C.&lt;/p&gt;

&lt;p&gt;However, I find this book a little bit rushy, what the author did was to drag
you through lots of kernel terminologies and then give you lots of code snippets
that, I myself at least, couldn’t understand until I read them for multiple
times.&lt;/p&gt;

&lt;p&gt;The Design and Implementation of the FreeBSD Operating System By Marshall Kirk
McKusick and George V. Neville-Neil on the other hand, discusses overall FreeBSD
kernel implementation and as well as each major kernel modules in detail, but
the only drawback is that it doesn’t talk much about rootkit techniques, it only
concentrates on normal kernel development.&lt;/p&gt;

&lt;p&gt;So that’s why I wrote this series on FreeBSD Kernel Rootkit Design, it combines
what I have learned, and what I think is useful from all those books and online
resources.
I also improved some of the examples from Joseph Kong’s book, filled in all
related information which were omitted by the author.&lt;/p&gt;

&lt;p&gt;Consider this as a tutorial series. If you are looking for a quick and
comprehensive from novice to advanced novice guide on writing FreeBSD Kernel
Rookits, then congratulations, this is just right for you.&lt;/p&gt;</content><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><category term="FreeBSD" /><category term="Rootkit" /><category term="C++" /><summary type="html">As the title suggests, this is a howto tutorial on FreeBSD kernel rootkit design. It was prepared as notes as I worked on my college final year project while reading Designing BSD Rootkits: An Introduction to Kernel Hacking, where I got most of the information I needed. I then posted these notes on my blog hoping it could serve as a quick introduction to general kernel hacking. Those notes were filled with unorganized brainstorming and unnecessary technical details that even I myself couldn’t bear reading a page without drinking way too much coffee. It clearly failed it’s purpose.</summary></entry><entry><title type="html">2 Eggs versus 100 Floor</title><link href="http://localhost:4000/the-2-eggs-vs-100-floor-problem/" rel="alternate" type="text/html" title="2 Eggs versus 100 Floor" /><published>2011-06-29T00:00:00+08:00</published><updated>2011-06-29T00:00:00+08:00</updated><id>http://localhost:4000/the-2-eggs-vs-100-floor-problem</id><content type="html" xml:base="http://localhost:4000/the-2-eggs-vs-100-floor-problem/">&lt;p&gt;I saw this problem posted on Facebook today, and find it really intriguing and
quite enjoyable to solve.&lt;/p&gt;

&lt;p&gt;The problem is described as follow:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;You are given 2 eggs.&lt;/li&gt;
    &lt;li&gt;You have access to a 100-storey building.&lt;/li&gt;
    &lt;li&gt;Eggs can be very hard or very fragile means it may break if dropped from the first floor or may not even break if dropped from 100 th floor.Both eggs are identical.&lt;/li&gt;
    &lt;li&gt;You need to figure out the highest floor of a 100-storey building an egg can be dropped without breaking.&lt;/li&gt;
    &lt;li&gt;Now the question is how many drops you need to make. You are allowed to break 2 eggs in the process&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;The following methods, codes, and algorithms are all from a pure computer
  student’s point of view, I know some people can directly solve the problem
  without writing any code, but that’s no fun, is it?&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;understand-the-question&quot;&gt;Understand the question&lt;/h3&gt;
&lt;p&gt;Let’s take a rough look at the question first. Given that these two eggs are identical, the hardness of these two eggs are equally the same, which means that&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hardness(egg1) = hardness(egg2)

highest_breaking_floor(egg1) = highest_breaking_floor(egg2)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’m quite tempted to use binary search, drop the first egg at 50th floor, we
will then have two possible consequences&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;Egg1 breaks&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;This means the highest floor the egg doesn’t break is less than 50, or 1-49th.&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;Egg1 did not break&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;And this means the highest floor the egg can bear to be dropped down from is greater than 50, 51-100th.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This seems to be a very straight forward solution to find out the answer, either
one of these two situations will require a linear search to find out the real answer. This is a general solution to solve the problem, but the performance of total tries are questionable.&lt;/p&gt;

&lt;h2 id=&quot;the-general-solution&quot;&gt;The General Solution&lt;/h2&gt;
&lt;p&gt;In order to better understand how this approach works, let’s look at the
following pseudocode and flowchart.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DROP egg1 AT 50th FLOOR

IF egg1.break == TRUE:
    FOR answer=1, answer&amp;lt;=49,answer++
        DROP egg2 AT answer FLOOR
        IF egg2.break == TRUE:
            PRINT 'The Answer IS:', answer-1
            BREAK

ELSE:
    FOR answer=51, answer&amp;lt;=100,answer++
        DROP egg1 AT answer FLOOR
        IF egg1.break == TRUE:
            PRINT 'The Answer IS:', answer-1
            BREAK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/2-Eggs-versus-100-Floor/flowchart.png&quot; alt=&quot;General Solution Flowchart&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Well, let’s admit it, this is, as the name suggests, a very basic and general
solution. But before we try to figure out better algorithms, let’s look at this
general solution a little bit closer.&lt;/p&gt;

&lt;p&gt;We all know that under most context, a binary search is almost definitely better
than a linear search, then why don’t we keep performing it and instead utilized
linear search after the first try?&lt;/p&gt;

&lt;p&gt;Imagine if we broke the first egg at 50th floor, and wants to continue binary
search, then the next floor to try would be 25th floor. Now if the second egg
breaks at 25th floor, or any other subsequent binary search tries, there would
be no egg left to find out the exact answer.&lt;/p&gt;

&lt;p&gt;However if the first egg does not break when dropped from 50th floor, we now
still have 2 eggs to spare, which would allow us to perform more binary searches
through 51-100th floor until we have only 1 egg left. So in short, we can only
perform binary search when we have both eggs intact, and linear search when
we have only 1 of them left. Pretty straighforward.&lt;/p&gt;

&lt;h2 id=&quot;more-binary-search&quot;&gt;More binary search!&lt;/h2&gt;

&lt;p&gt;Instead of performing 49 linear search plus the initial binary search, scoring a
horrific 50 tries at worst circumstance, let’s find out what is the optimal
number of tries if the first egg manages to survive every binary search
drops.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Count&lt;/th&gt;
      &lt;th&gt;Try At&lt;/th&gt;
      &lt;th&gt;Binary Search Start Value&lt;/th&gt;
      &lt;th&gt;Binary Search End Value&lt;/th&gt;
      &lt;th&gt;Number of Search Values&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;75&lt;/td&gt;
      &lt;td&gt;76&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;88&lt;/td&gt;
      &lt;td&gt;87&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;94&lt;/td&gt;
      &lt;td&gt;93&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;97&lt;/td&gt;
      &lt;td&gt;96&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt;98&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The table above illustrates a typical binary search, we always halve the
&lt;em&gt;Number of Search Values&lt;/em&gt; and add it to the last &lt;em&gt;Try At&lt;/em&gt; to get the next binary
search offset.&lt;/p&gt;

&lt;p&gt;It is clear that the minimal number of tries to get the answer would be 6, we
drop the egg at 99th floor if it manages to survive all previous attempts, the
answer is 98 if it breaks, and 100 if it doesn’t.&lt;/p&gt;

&lt;p&gt;Now we know the range of tries to find the answer is 6 to 50, it is time to
optimize our approach.&lt;/p&gt;

&lt;h2 id=&quot;optimization&quot;&gt;Optimization&lt;/h2&gt;

&lt;p&gt;Every optimization starts with a question, are there room for optimization?
Fortunately, answering this question often brings us right to the optimized
solution, if there is one.&lt;/p&gt;

&lt;p&gt;Let’s assume the optimized maximum number of tries to solve this problew is &lt;em&gt;X&lt;/em&gt;.
We already know that the worst scenario only happen when first binary
search resulted in a broken egg, in that case, we have to linear search from &lt;em&gt;1&lt;/em&gt;
to &lt;em&gt;X-1&lt;/em&gt;, totalling X-1-1+1 linear searches and 1 already performed binary
search.&lt;/p&gt;

&lt;p&gt;This means &lt;em&gt;X&lt;/em&gt; is not only the max number of tries, but also the first binary
search index, or offset if you will. Let’s illustrate this with a table.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Try At (Binary Search Offset)&lt;/th&gt;
      &lt;th&gt;Linear Start&lt;/th&gt;
      &lt;th&gt;Linear End&lt;/th&gt;
      &lt;th&gt;Linear Searches&lt;/th&gt;
      &lt;th&gt;Binary Search Performed&lt;/th&gt;
      &lt;th&gt;Total Tries&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;X-1&lt;/td&gt;
      &lt;td&gt;(X-1-1)+1 = X-1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;X-1+1 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;???&lt;/td&gt;
      &lt;td&gt;X+1&lt;/td&gt;
      &lt;td&gt;???-1&lt;/td&gt;
      &lt;td&gt;(???-1)-(X+1)+1 = &lt;em&gt;X-2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;X-2+2 = X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;It is obvious for the first try, since at this point we only care about maximum
tries, the scenario would be we drop the first egg at Xth floor, it breaks, we
then perform linear search from 1st floor to X-1th floor, resulting (X-1)-1+1 =
X-1 linear searches, adding the first binary seach try we performed to it, we
get X-1+1 = X tries.&lt;/p&gt;

&lt;p&gt;Perfect, it meets our assumption that the maximum tries needed to figure out the
answer is X. But at which floor should us perform the second binary search try
if the egg survived?&lt;/p&gt;

&lt;p&gt;Well, we can’t halve the number of remaining search values like we did
previously, that simply breaks our assumption of getting the answer within &lt;em&gt;X&lt;/em&gt;
tries.&lt;/p&gt;

&lt;p&gt;An easier way to understand it is, let’s assume the second binary search offset
is ???, the linear start would be X+1 since all previous values are ruled out
given the first egg survived, the linear end would be ???-1, then total number
of linear searches needed to perform if the egg broke at the secound try would
be &lt;em&gt;(???-1)-(X+1)+1&lt;/em&gt;, and that value &lt;em&gt;must&lt;/em&gt; equal to &lt;em&gt;X-2&lt;/em&gt; since only then would
total tries equal to &lt;em&gt;X&lt;/em&gt;. Thus,&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;(???-1)-(X+1)+1 = X-2&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;em&gt;??? = 2X-1&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Subsequential offsets can all be calculated similarly.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Try At (Binary Search Offset)&lt;/th&gt;
      &lt;th&gt;Linear Start&lt;/th&gt;
      &lt;th&gt;Linear End&lt;/th&gt;
      &lt;th&gt;Linear Searches&lt;/th&gt;
      &lt;th&gt;Binary Search Performed&lt;/th&gt;
      &lt;th&gt;Total Tries&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;X-1&lt;/td&gt;
      &lt;td&gt;(X-1-1)+1 = X-1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;X-1+1 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2X-1&lt;/td&gt;
      &lt;td&gt;X+1&lt;/td&gt;
      &lt;td&gt;(2X-1)-1&lt;/td&gt;
      &lt;td&gt;(2X-1-1)-(X+1)+1 = &lt;em&gt;X-2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;X-2+2 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3X-3&lt;/td&gt;
      &lt;td&gt;(2X-1)+1 = 2X&lt;/td&gt;
      &lt;td&gt;(3X-3)-1&lt;/td&gt;
      &lt;td&gt;(3X-3-1)-2X = X-3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;X-3+3 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;It is now obvious that the second binary search offset is &lt;em&gt;X+(X-1)&lt;/em&gt; and the
third &lt;em&gt;X+(X-1)+(X-2)&lt;/em&gt;, which allows us to deduce the last try at should be
&lt;em&gt;X+(X-1)+(X-2)+…+[X-(X-2)]+1&lt;/em&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Try At (Binary Search Offset)&lt;/th&gt;
      &lt;th&gt;Linear Start&lt;/th&gt;
      &lt;th&gt;Linear End&lt;/th&gt;
      &lt;th&gt;Linear Searches&lt;/th&gt;
      &lt;th&gt;Binary Search Performed&lt;/th&gt;
      &lt;th&gt;Total Tries&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;X-1&lt;/td&gt;
      &lt;td&gt;(X-1-1)+1 = X-1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;X-1+1 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X+(X-1)&lt;/td&gt;
      &lt;td&gt;X+1&lt;/td&gt;
      &lt;td&gt;(2X-1)-1&lt;/td&gt;
      &lt;td&gt;(2X-1-1)-(X+1)+1 = &lt;em&gt;X-2&lt;/em&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;X-2+2 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X+(X-1)+(X-2)&lt;/td&gt;
      &lt;td&gt;(2X-1)+1 = 2X&lt;/td&gt;
      &lt;td&gt;(3X-3)-1&lt;/td&gt;
      &lt;td&gt;(3X-3-1)-2X = X-3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;X-3+3 = X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt;…&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;X+(X-1)+(X-2)+…+[X-(X-2)]+1&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The last binary search we perform should not require any further linear search,
thus resulting in &lt;em&gt;X&lt;/em&gt; total binary searches, and consequentially &lt;em&gt;X&lt;/em&gt; total
tries.&lt;/p&gt;

&lt;p&gt;In order to fulfil the assumption that the last offset should require no further
linear search, which in other words, means we should cover all floors with the
last binary search offset, we can conclude that&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;X+(X-1)+(X-2)+…+[X-(X-2)]+1 &amp;gt;= 100&lt;/em&gt;.&lt;/p&gt;

  &lt;p&gt;Equally&lt;/p&gt;

  &lt;p&gt;&lt;em&gt;(X+1)X/2 &amp;gt;= 100&lt;/em&gt;&lt;/p&gt;

  &lt;p&gt;&lt;em&gt;X = 14&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;sample-code&quot;&gt;Sample Code&lt;/h2&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;####Dummy Optimized General Solution for 2 Eggs VS 100th Floor###&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;total_floor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;total_try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;max_floor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'---===2 Eggs VS 100th Floor===---'&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'+Type '&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;' to quit the program!'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;raw_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'+Start? [Press Enter]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'exit'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;last_try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;#Which means we can still use binary search until we break one egg.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]&amp;lt;!!!-Stage 1-!!!&amp;gt; --&amp;gt; Performing Binary Serach...'&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]count_try = '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]try_at = '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]last_try_at = '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_try_at&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;#This is the extreme case where the binary search was performed at 99th floor, and&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;#it breaks, which means 98 is the answer in this context.&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]The asnwer is 98!'&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Total Number of Tries: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;linear_start&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;linear_end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Egg1 Broke!'&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Correct answer is in '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'to'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear_end&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]&amp;lt;!!!-Stage 2-!!!&amp;gt; --&amp;gt; Performing Linear Search...'&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linear_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear_end&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Egg broke at'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]The answer is'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Total Number of Tries: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;
                    &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Egg did not break at'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Egg survived all linear searches.'&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]The answer is'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear_end&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Total Number of Tries: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;#This is the extreme case where the binary search was performed at 99th floor, and&lt;/span&gt;
                &lt;span class=&quot;c&quot;&gt;#it didn't break, which means 100 is the answer in this context.&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]The asnwer is 100!'&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Total Number of Tries: '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;
                &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;last_try_at&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Egg1 did not break at '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_at&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;[Debug]Continue binary search...'&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;drop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;global&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;No egg available for testing, program failed!'&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;#Egg is gonna break&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;Drop egg at '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'floor: [Broken!]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'egg left!'&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'-&amp;gt;Drop egg at '&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'floor: [Did not break!]'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total_egg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'egg left!'&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;count_try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Run this piece of code, you’ll get the number of total tries at the end of each
run. To simulate the one of the worst scenario, simply change &lt;em&gt;max_floor&lt;/em&gt; to 13.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;EDIT: I find myself extremely lack of mathematical thinking at the time of
writing this post. However, it is fun to observe your though process many
years ago, plus I did manage to get an answer :-D&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Hai Lang</name><email>ragingscholar@protonmail.com</email></author><category term="Algorithm" /><category term="Python" /><summary type="html">I saw this problem posted on Facebook today, and find it really intriguing and quite enjoyable to solve.</summary></entry></feed>